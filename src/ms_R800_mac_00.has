*
*	Ｍｓｘ Ｓｉｍｕｌａｔｅｒ
*
*		[[[ Ｒ８００ Ｓｉｍｕｌａｔｅｒ ]]]		
*
*				1995.8.28		by Kuni.
*


*	ＲＥＴＮとＲＥＴＩをちゃんとやってない


*	 31     16 15       0
*	｜        ｜   ｜ A ｜  d4	Ａレジスタ
*	｜        ｜   ｜HC1｜  d5	フラグ
*	｜        ｜ F ｜ SZ｜  d6	フラグ
*	｜ PC page｜PC(16k) ｜	d7
*	｜     registers    ｜	a3	a3 = レジスターの格納されているアドレス
*	｜    PC Base ADD   ｜	a4
*
*	PC Base ADD + PC(16k) = 実アドレス
*
*	PC page は PC(R800) の上位２ビットの値が入っている
*	PC(16k) は PC(R800) の下位14ビットの値
*
*		PC(R800)  $8100  =   %10___000001_00000000 
*
*		=> d7 %00000000_00000010_00000001_00000000
*
*
*	flag = 00000000
*		   | |+--Cy
*		   | +---N
*		   +-----HC のモード。0の時通常モード。1の時 ADC,SBC モード。
*
*	registers:
*	a:	.dc.b	0		* Ａレジスタは d4 に入ってるから使わない
*	f:	.dc.b	0
*	b:	.dc.b	0
*	c:	.dc.b	0
*	d:	.dc.b	0
*	e:	.dc.b	0
*	h:	.dc.b	0
*	l:	.dc.b	0
*
*	ix_h:	.dc.b	0
*	ix_l:	.dc.b	0
*	iy_h:	.dc.b	0
*	iy_l:	.dc.b	0
*
*	s:	.dc.b	0
*	p:	.dc.b	0
*
*	    7  6  5  4  3  2  1  0
*	F:| s| z|  | H|  |PV| N|CY|
*
*		H と P/V は、その 0,1 を判定するための値をそれぞれ
*		HC1,HC2 と PV に保存し、必用な時に計算する。
*
*		S と Z は、その 0,1 を判断するための値を SZ に保存
*		し、必用な時に計算する。
*

	.68000

	.include	iocscall.equ
	.include	doscall.equ

	.text
	.even

	.xref	MS_JPT			* ６８ネイティブルーチンのジャンプテーブル
	.xref	VDP			* VDP処理ルーチンのアドレス


	.xref	wt_VDP_0
	.xref	wt_VDP_1
	.xref	wt_VDP_2
	.xref	wt_VDP_3

	.xref	rd_VDP_0
	.xref	rd_VDP_1
	.xref	rd_VDP_2
	.xref	rd_VDP_3

	.xdef	_emulate
	.xdef	page0
	.xdef	page1
	.xdef	page2
	.xdef	page3
	.xdef	base

headerlength	equ	8		* 各ページの情報を示したヘッダーの長さ

a	equ	0
f	equ	1	
b	equ	2	
c	equ	3	
d	equ	4
e	equ	5
h	equ	6
l	equ	7
ix_h	equ	8
ix_l	equ	9
iy_h	equ	10
iy_l	equ	11
s	equ	12
p	equ	13

bc	equ	2
de	equ	4
hl	equ	6
ix	equ	8
iy	equ	10
sp_	equ	12

a_	equ	14
f_	equ	15	
b_	equ	16	
c_	equ	17	
d_	equ	18
e_	equ	19
h_	equ	20
l_	equ	21

af_	equ	14
bc_	equ	16
de_	equ	18
hl_	equ	20

r	equ	r_-base
i	equ	i_-base

HC2	equ	HC2_-base
PV	equ	PV_-base

HC1_d	equ	HC1_d_-base
HC2_d	equ	HC2_d_-base
PV_d	equ	PV_d_-base
SZ_d	equ	SZ_d_-base



*	このルーチンはたぶん要らない
*
*	int emulater_ini();		/* ＳＰ(R800)を返す	*/
*
*		ＳＰの設定などをする
*
*_emulater_ini:
*	move.l	a3,-(sp)
*	movea.l	Main_Mem,a3	* a3 <- メインメモリのアドレス
*
*
*	move.w	#$fffd,d0	* $FFFD 番地に終了コードを書く
*	move.b	#$FD,0(a3,d0)
*	move.b	#$FF,1(a3,d0)
*
*	move.l	#$f000,d0	* sp を $f000 にする。（暫定的）
*
*	move.l	(sp)+,a3
*
*	rts
*

*
*	void start();
*
_emulate:
	lea.l	registers,a3
	clr.w	d7			* pc = 0
	bsr	PC_page_set
	clr.w	sp_(a3)			* sp = 0
	move.b	#$80,interrupt_status	* DI に
	clr.w	interrupt_mode		* IM を０に
main:
	move.b	interrupt_status-base(a3),d0
	bpl	INT			* 割り込みがかかった時
	clr.l	d0			* d0 の上位ビットを０にクリア
	move.b	0(a4,d7.w),d0		* 命令を読み込む
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	add.w	d0,d0		* d0 = d0 x 2
	move.w	instructions(pc,d0.w),d0
	jmp	instructions(pc,d0.w)


PC_page_CHG:
	swap	d7
	addq.w	#1,d7
	andi.w	#3,d7
	move.w	d7,-(sp)
	lsl.w	#2,d7			* d7 = d7 * 4
	movea.l	page0-base(a3,d7.w),a4
	move.w	(sp)+,d7
	swap	d7
	rts	

PC_page_set:				* JP命令等で PCが変わった時の処理
	move.w	d0,-(sp)
	move.w	d7,d0
	clr.l	d7			* d7 の上位ワードを０にする。符号拡張ではだめ
	move.w	d0,d7
	andi.w	#%00111111_11111111,d0
	lsl.l	#2,d7
	move.w	d0,d7
	swap	d7
	move.w	d7,d0
	swap	d7
	lsr.w	#2,d0			* d0 = page * 4
	movea.l	page0-base(a3,d0.w),a4
	move.w	(sp)+,d0
	rts	

end:	DOS	_EXIT

instructions:
	.dc.w	nop-instructions		* $00
	.dc.w	LD_BC_nn-instructions
	.dc.w	LD_lBCl_A-instructions
	.dc.w	INC_BC-instructions
	.dc.w	INC_B-instructions
	.dc.w	DEC_B-instructions
	.dc.w	LD_B_n-instructions
	.dc.w	RLCA-instructions
	.dc.w	EX_AF_AFd-instructions	* $08
	.dc.w	ADD_HL_BC-instructions
	.dc.w	LD_A_lBCl-instructions
	.dc.w	DEC_BC-instructions
	.dc.w	INC_C-instructions
	.dc.w	DEC_C-instructions
	.dc.w	LD_C_n-instructions
	.dc.w	RRCA-instructions		* $0f

	.dc.w	DJNZ-instructions		* $10
	.dc.w	LD_DE_nn-instructions
	.dc.w	LD_lDEl_A-instructions
	.dc.w	INC_DE-instructions
	.dc.w	INC_D-instructions
	.dc.w	DEC_D-instructions
	.dc.w	LD_D_n-instructions
	.dc.w	RLA-instructions
	.dc.w	JR-instructions		* $18
	.dc.w	ADD_HL_DE-instructions
	.dc.w	LD_A_lDEl-instructions
	.dc.w	DEC_DE-instructions
	.dc.w	INC_E-instructions
	.dc.w	DEC_E-instructions
	.dc.w	LD_E_n-instructions
	.dc.w	RRA-instructions		* $1f

	.dc.w	JR_NZ-instructions		* $20
	.dc.w	LD_HL_nn-instructions
	.dc.w	LD_lnnl_HL-instructions
	.dc.w	INC_HL-instructions
	.dc.w	INC_H-instructions
	.dc.w	DEC_H-instructions
	.dc.w	LD_H_n-instructions
	.dc.w	DAA-instructions
	.dc.w	JR_Z-instructions		* $28
	.dc.w	ADD_HL_HL-instructions
	.dc.w	LD_HL_lnnl-instructions
	.dc.w	DEC_HL-instructions
	.dc.w	INC_L-instructions
	.dc.w	DEC_L-instructions
	.dc.w	LD_L_n-instructions
	.dc.w	CPL-instructions		* $2f

	.dc.w	JR_NC-instructions		* $30
	.dc.w	LD_SP_nn-instructions
	.dc.w	LD_lnnl_A-instructions
	.dc.w	INC_SP-instructions
	.dc.w	INC_lHLl-instructions
	.dc.w	DEC_lHLl-instructions
	.dc.w	LD_lHLl_n-instructions
	.dc.w	SCF-instructions
	.dc.w	JR_C-instructions		* $08
	.dc.w	ADD_HL_SP-instructions
	.dc.w	LD_A_lnnl-instructions
	.dc.w	DEC_SP-instructions
	.dc.w	INC_A-instructions
	.dc.w	DEC_A-instructions
	.dc.w	LD_A_n-instructions
	.dc.w	CCF-instructions		* $0f

	.dc.w	LD_B_B-instructions		* 0
	.dc.w	LD_B_C-instructions
	.dc.w	LD_B_D-instructions
	.dc.w	LD_B_E-instructions
	.dc.w	LD_B_H-instructions
	.dc.w	LD_B_L-instructions
	.dc.w	LD_B_lHLl-instructions
	.dc.w	LD_B_A-instructions
	.dc.w	LD_C_B-instructions		* $08
	.dc.w	LD_C_C-instructions
	.dc.w	LD_C_D-instructions
	.dc.w	LD_C_E-instructions
	.dc.w	LD_C_H-instructions
	.dc.w	LD_C_L-instructions
	.dc.w	LD_C_lHLl-instructions
	.dc.w	LD_C_A-instructions		* $0f

	.dc.w	LD_D_B-instructions		* $50
	.dc.w	LD_D_C-instructions
	.dc.w	LD_D_D-instructions
	.dc.w	LD_D_E-instructions
	.dc.w	LD_D_H-instructions
	.dc.w	LD_D_L-instructions
	.dc.w	LD_D_lHLl-instructions
	.dc.w	LD_D_A-instructions
	.dc.w	LD_E_B-instructions		* $58
	.dc.w	LD_E_C-instructions
	.dc.w	LD_E_D-instructions
	.dc.w	LD_E_E-instructions
	.dc.w	LD_E_H-instructions
	.dc.w	LD_E_L-instructions
	.dc.w	LD_E_lHLl-instructions
	.dc.w	LD_E_A-instructions		* $5f

	.dc.w	LD_H_B-instructions		* $60
	.dc.w	LD_H_C-instructions
	.dc.w	LD_H_D-instructions
	.dc.w	LD_H_E-instructions
	.dc.w	LD_H_H-instructions
	.dc.w	LD_H_L-instructions
	.dc.w	LD_H_lHLl-instructions
	.dc.w	LD_H_A-instructions
	.dc.w	LD_L_B-instructions		* $68
	.dc.w	LD_L_C-instructions
	.dc.w	LD_L_D-instructions
	.dc.w	LD_L_E-instructions
	.dc.w	LD_L_H-instructions
	.dc.w	LD_L_L-instructions
	.dc.w	LD_L_lHLl-instructions
	.dc.w	LD_L_A-instructions		* $6f

	.dc.w	LD_lHLl_B-instructions		* $70
	.dc.w	LD_lHLl_C-instructions
	.dc.w	LD_lHLl_D-instructions
	.dc.w	LD_lHLl_E-instructions
	.dc.w	LD_lHLl_H-instructions
	.dc.w	LD_lHLl_L-instructions
	.dc.w	HALT-instructions
	.dc.w	LD_lHLl_A-instructions
	.dc.w	LD_A_B-instructions		* $78
	.dc.w	LD_A_C-instructions
	.dc.w	LD_A_D-instructions
	.dc.w	LD_A_E-instructions
	.dc.w	LD_A_H-instructions
	.dc.w	LD_A_L-instructions
	.dc.w	LD_A_lHLl-instructions
	.dc.w	LD_A_A-instructions		* $7f

	.dc.w	ADD_A_B-instructions		* $80
	.dc.w	ADD_A_C-instructions
	.dc.w	ADD_A_D-instructions
	.dc.w	ADD_A_E-instructions
	.dc.w	ADD_A_H-instructions
	.dc.w	ADD_A_L-instructions
	.dc.w	ADD_A_lHLl-instructions
	.dc.w	ADD_A_A-instructions
	.dc.w	ADC_A_B-instructions		* $88
	.dc.w	ADC_A_C-instructions
	.dc.w	ADC_A_D-instructions
	.dc.w	ADC_A_E-instructions
	.dc.w	ADC_A_H-instructions
	.dc.w	ADC_A_L-instructions
	.dc.w	ADC_A_lHLl-instructions
	.dc.w	ADC_A_A-instructions		* $8f

	.dc.w	SUB_B-instructions		* $90
	.dc.w	SUB_C-instructions
	.dc.w	SUB_D-instructions
	.dc.w	SUB_E-instructions
	.dc.w	SUB_H-instructions
	.dc.w	SUB_L-instructions
	.dc.w	SUB_lHLl-instructions
	.dc.w	SUB_A-instructions
	.dc.w	SBC_A_B-instructions		* $98
	.dc.w	SBC_A_C-instructions
	.dc.w	SBC_A_D-instructions
	.dc.w	SBC_A_E-instructions
	.dc.w	SBC_A_H-instructions
	.dc.w	SBC_A_L-instructions
	.dc.w	SBC_A_lHLl-instructions
	.dc.w	SBC_A_A-instructions		* $9f

	.dc.w	AND_B-instructions		* $A0
	.dc.w	AND_C-instructions
	.dc.w	AND_D-instructions
	.dc.w	AND_E-instructions
	.dc.w	AND_H-instructions
	.dc.w	AND_L-instructions
	.dc.w	AND_lHLl-instructions
	.dc.w	AND_A-instructions
	.dc.w	XOR_B-instructions		* $A8
	.dc.w	XOR_C-instructions
	.dc.w	XOR_D-instructions
	.dc.w	XOR_E-instructions
	.dc.w	XOR_H-instructions
	.dc.w	XOR_L-instructions
	.dc.w	XOR_lHLl-instructions
	.dc.w	XOR_A-instructions		* $Af

	.dc.w	OR_B-instructions		* $B0
	.dc.w	OR_C-instructions
	.dc.w	OR_D-instructions
	.dc.w	OR_E-instructions
	.dc.w	OR_H-instructions
	.dc.w	OR_L-instructions
	.dc.w	OR_lHLl-instructions
	.dc.w	OR_A-instructions
	.dc.w	CP_B-instructions		* $B8
	.dc.w	CP_C-instructions
	.dc.w	CP_D-instructions
	.dc.w	CP_E-instructions
	.dc.w	CP_H-instructions
	.dc.w	CP_L-instructions
	.dc.w	CP_lHLl-instructions
	.dc.w	CP_A-instructions		* $Bf

	.dc.w	RET_NZ-instructions		* $C0
	.dc.w	POP_BC-instructions
	.dc.w	JP_NZ-instructions
	.dc.w	JP-instructions
	.dc.w	CALL_NZ-instructions
	.dc.w	PUSH_BC-instructions
	.dc.w	ADD_A_n-instructions
	.dc.w	RST_00H-instructions
	.dc.w	RET_Z-instructions		* $C8
	.dc.w	RET-instructions
	.dc.w	CALL_Z-instructions
	.dc.w	CB-instructions		* $CB ライン命令
	.dc.w	CALL_Z-instructions
	.dc.w	CALL-instructions
	.dc.w	ADC_A_n-instructions
	.dc.w	RST_08H-instructions		* $Cf

	.dc.w	RET_NC-instructions		* $D0
	.dc.w	POP_DE-instructions
	.dc.w	JP_NC-instructions
	.dc.w	OUT_n_A-instructions
	.dc.w	CALL_NC-instructions
	.dc.w	PUSH_DE-instructions
	.dc.w	SUB_n-instructions
	.dc.w	RST_10H-instructions
	.dc.w	RET_C-instructions		* $D8
	.dc.w	EXX-instructions
	.dc.w	JP_C-instructions
	.dc.w	IN_A_n-instructions
	.dc.w	CALL_C-instructions
	.dc.w	DD-instructions		* $DD ライン命令
	.dc.w	SBC_A_n-instructions
	.dc.w	RST_18H-instructions		* $Df

	.dc.w	RET_PO-instructions		* $E0
	.dc.w	POP_HL-instructions
	.dc.w	JP_PO-instructions
	.dc.w	EX_lSPl_HL-instructions
	.dc.w	CALL_PO-instructions
	.dc.w	PUSH_HL-instructions
	.dc.w	AND_n-instructions
	.dc.w	RST_20H-instructions
	.dc.w	RET_PE-instructions		* $E8
	.dc.w	JP_lHLl-instructions
	.dc.w	JP_PE-instructions
	.dc.w	EX_DE_HL-instructions
	.dc.w	CALL_PE-instructions
	.dc.w	ED-instructions		* $ED ライン命令
	.dc.w	XOR_n-instructions
	.dc.w	RST_28H-instructions	* $Ef

	.dc.w	RET_NC-instructions		* $D0
	.dc.w	POP_AF-instructions
	.dc.w	JP_P-instructions
	.dc.w	DI-instructions
	.dc.w	CALL_P-instructions
	.dc.w	PUSH_AF-instructions
	.dc.w	SUB_n-instructions
	.dc.w	RST_30H-instructions
	.dc.w	RET_M-instructions		* $F8
	.dc.w	LD_SP_HL-instructions
	.dc.w	JP_M-instructions
	.dc.w	EI-instructions
	.dc.w	CALL_M-instructions
	.dc.w	FD-instructions			* $FD ライン命令
	.dc.w	CP_n-instructions
	.dc.w	RST_38H-instructions		* $ff


*	------ 割り込み処理 ------
INT:	cmpi.w	#1,interrupt_mode	* 割り込みがかかった時の処理
	bhi	mode2
					* モード０割り込みは実現できない
mode1:	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16

	move.w	#$0038,d7
	bsr	PC_page_set
	bra	main

mode2:	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16

	move.b	i(a3),-(sp)
	move.w	(sp)+,d0
	clr.b	d0

	bsr	read_mem_16
	move.w	d0,d7
	bsr	PC_page_set
	bra	main

*	------ ＮＯＰ ------
nop:	bra	main

*
*	-------- ＬＤ --------
*
*	------ ＬＤ Ａ,？ ------
LD_A_A:
	bra	main
LD_A_B:
	move.b	b(a3),d4
	bra	main
LD_A_C:
	move.b	c(a3),d4
	bra	main
LD_A_D:
	move.b	d(a3),d4
	bra	main
LD_A_E:
	move.b	e(a3),d4
	bra	main
LD_A_H:
	move.b	h(a3),d4
	bra	main
LD_A_L:
	move.b	l(a3),d4
	bra	main
LD_A_lHLl:
	move.w	hl(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	bra	main
LD_A_lBCl:
	move.b	bc(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	bra	main
LD_A_lDEl:
	move.b	de(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	bra	main
LD_A_lnnl:
	clr.w	d1
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	1f
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	bra	main
1:	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	2f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	bra	main
2:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d1
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	bra	main

LD_A_n:	move.b	0(a4,d7.w),d4
	addq.w	#1,d7			* PC += 1
	andi.w	#$3fff,d7		* PC がページ境界をまたいだか？
	bne	main
	bsr	PC_page_CHG
	bra	main

*	------ ＬＤ Ｂ,？ ------
LD_B_A:	move.b	d4,b(a3)
	bra	main

LD_B_B:	bra	main

LD_B_C:	move.b	c(a3),b(a3)
	bra	main

LD_B_D:	move.b	d(a3),b(a3)
	bra	main

LD_B_E:	move.b	e(a3),b(a3)
	bra	main

LD_B_H:	move.b	h(a3),b(a3)
	bra	main

LD_B_L:	move.b	l(a3),b(a3)
	bra	main

LD_B_lHLl:
	move.w	hl(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,b(a3)
	bra	main

LD_B_n:	move.b	0(a4,d7.w),b(a3)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＬＤ Ｃ,？ ------
LD_C_A:	move.b	d4,c(a3)
	bra	main

LD_C_B:	move.b	b(a3),c(a3)
	bra	main

LD_C_C:	bra	main

LD_C_D:	move.b	d(a3),c(a3)
	bra	main

LD_C_E:	move.b	e(a3),c(a3)
	bra	main

LD_C_H:	move.b	h(a3),c(a3)
	bra	main

LD_C_L:	move.b	l(a3),c(a3)
	bra	main

LD_C_lHLl:
	move.w	hl(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,c(a3)
	bra	main

LD_C_n:	move.b	0(a4,d7.w),c(a3)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＬＤ Ｄ,？ ------
LD_D_A:	move.b	d4,d(a3)
	bra	main

LD_D_B:	move.b	b(a3),d(a3)
	bra	main

LD_D_C:	move.b	c(a3),d(a3)
	bra	main

LD_D_D:	bra	main

LD_D_E:	move.b	e(a3),d(a3)
	bra	main

LD_D_H:	move.b	h(a3),d(a3)
	bra	main

LD_D_L:	move.b	l(a3),d(a3)
	bra	main

LD_D_lHLl:
	move.w	hl(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d(a3)
	bra	main

LD_D_n:	move.b	0(a4,d7.w),d(a3)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＬＤ Ｅ,？ ------
LD_E_A:	move.b	d4,e(a3)
	bra	main

LD_E_B:	move.b	b(a3),e(a3)
	bra	main

LD_E_C:	move.b	c(a3),e(a3)
	bra	main

LD_E_D:	move.b	d(a3),e(a3)
	bra	main

LD_E_E:	bra	main

LD_E_H:	move.b	h(a3),e(a3)
	bra	main

LD_E_L:	move.b	l(a3),e(a3)
	bra	main

LD_E_lHLl:
	move.w	hl(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,e(a3)
	bra	main

LD_E_n:	move.b	0(a4,d7.w),e(a3)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＬＤ Ｈ,？ ------
LD_H_A:	move.b	d4,h(a3)
	bra	main

LD_H_B:	move.b	b(a3),h(a3)
	bra	main

LD_H_C:	move.b	c(a3),h(a3)
	bra	main

LD_H_D:	move.b	d(a3),h(a3)
	bra	main

LD_H_E:	move.b	e(a3),h(a3)
	bra	main

LD_H_H:	bra	main

LD_H_L:	move.b	l(a3),h(a3)
	bra	main

LD_H_lHLl:
	move.w	hl(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,h(a3)
	bra	main

LD_H_n:	move.b	0(a4,d7.w),h(a3)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＬＤ Ｌ,？ ------
LD_L_A:	move.b	d4,l(a3)
	bra	main

LD_L_B:	move.b	b(a3),l(a3)
	bra	main

LD_L_C:	move.b	c(a3),l(a3)
	bra	main

LD_L_D:	move.b	d(a3),l(a3)
	bra	main

LD_L_E:	move.b	e(a3),l(a3)
	bra	main

LD_L_H:	move.b	h(a3),l(a3)
	bra	main

LD_L_L:	bra	main

LD_L_lHLl:
	move.w	hl(a3),d0
	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,l(a3)
	bra	main

LD_L_n:	move.b	0(a4,d7.w),l(a3)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＬＤ （ＨＬ）,？
LD_lHLl_A:
	move.w	hl(a3),d0
	move.b	d4,d1
	bsr	write_mem
	bra	main
LD_lHLl_B:
	move.w	hl(a3),d0
	move.b	b(a3),d1
	bsr	write_mem
	bra	main
LD_lHLl_C:
	move.w	hl(a3),d0
	move.b	c(a3),d1
	bsr	write_mem
	bra	main
LD_lHLl_D:
	move.w	hl(a3),d0
	move.b	e(a3),d1
	bsr	write_mem
	bra	main
LD_lHLl_E:
	move.w	hl(a3),d0
	move.b	e(a3),d1
	bsr	write_mem
	bra	main
LD_lHLl_H:
	move.w	hl(a3),d0
	move.b	h(a3),d1
	bsr	write_mem
	bra	main
LD_lHLl_L:
	move.w	hl(a3),d0
	move.b	l(a3),d1
	bsr	write_mem
	bra	main
LD_lHLl_n:
	move.w	hl(a3),d0
	move.b	0(a4,d7.w),d1
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	bne	next_LDhln
	bsr	write_mem
	bra	main
next_LDhln
	bsr	PC_page_CHG
	bsr	write_mem
	bra	main
LD_lBCl_A:
	move.w	bc(a3),d0
	move.b	d4,d1
	bsr	write_mem
	bra	main
LD_lDEl_A:
	move.w	de(a3),d0
	move.b	d4,d1
	bsr	write_mem
	bra	main
LD_lnnl_A:
	move.b	d4,d1
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	next_LDnna
	bsr	write_mem
	bra	main
next_LDnna
	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	write_mem
	bra	main
@@:					* d7 = 1 の時
	move.b	d0,d2			* nn の下位８ビットをとっておく
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d1
	bsr	write_mem
	bra	main

*	------ ＬＤ ＸＸ,nn ------
LD_BC_nn:
	move.b	0(a4,d7.w),c(a3)	* nn の下位８ビットを読む 
	move.b	1(a4,d7.w),b(a3)	* nn の上位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bra	main
@@:	bsr	PC_page_CHG		* d7 = 1 の時
	move.b	(a4),b(a3)		* nn の上位８ビットを読む
	bra	main

LD_DE_nn:
	move.b	0(a4,d7.w),e(a3)	* nn の下位８ビットを読む 
	move.b	1(a4,d7.w),d(a3)	* nn の上位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bra	main
@@:	bsr	PC_page_CHG		* d7 = 1 の時
	move.b	(a4),d(a3)		* nn の上位８ビットを読む
	bra	main

LD_HL_nn:
	move.b	0(a4,d7.w),l(a3)	* nn の下位８ビットを読む 
	move.b	1(a4,d7.w),h(a3)	* nn の上位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bra	main
@@:	bsr	PC_page_CHG		* d7 = 1 の時
	move.b	(a4),h(a3)		* nn の上位８ビットを読む
	bra	main

LD_SP_nn:
	move.b	0(a4,d7.w),p(a3)	* nn の下位８ビットを読む 
	move.b	1(a4,d7.w),s(a3)	* nn の上位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bra	main
@@:	bsr	PC_page_CHG		* d7 = 1 の時
	move.b	(a4),s(a3)		* nn の上位８ビットを読む
	bra	main
	
LD_SP_HL:
	move.w	hl(a3),sp_(a3)
	bra	main

*	------ ＬＤ ＸＸ,(nn) ------
LD_BC_lnnl:
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	1f
	bsr	read_mem_16
	move.w	d0,bc(a3)
	bra	main
1:	tst.w	d7			* 命令がページ境界をまたぐ時
	bne	2f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	read_mem_16
	move.w	d0,bc(a3)
	bra	main
2:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	read_mem_16
	move.w	d0,bc(a3)
	bra	main

LD_DE_lnnl:
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	1f
	bsr	read_mem_16
	move.w	d0,de(a3)
	bra	main
1:	tst.w	d7			* 命令がページ境界をまたぐ時
	bne	2f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	read_mem_16
	move.w	d0,de(a3)
	bra	main
2:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	read_mem_16
	move.w	d0,de(a3)
	bra	main

LD_HL_lnnl:
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	1f
	bsr	read_mem_16
	move.w	d0,bc(a3)
	bra	main
1:	tst.w	d7			* 命令がページ境界をまたぐ時
	bne	2f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	read_mem_16
	move.w	d0,hl(a3)
	bra	main
2:	move.b	d0,d2				* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	read_mem_16
	move.w	d0,hl(a3)
	bra	main

LD_SP_lnnl:
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	1f
	bsr	read_mem_16
	move.w	d0,sp_(a3)
	bra	main
1:	tst.w	d7			* 命令がページ境界をまたぐ時
	bne	2f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	read_mem_16
	move.w	d0,sp_(a3)
	bra	main
2:	move.b	d0,d2				* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	read_mem_16
	move.w	d0,sp_(a3)
	bra	main

*	------ ＬＤ (nn),ＸＸ ------
LD_lnnl_BC:
	move.w	bc(a3),d1
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	bsr	write_mem_16
	bra	main
@@:	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	write_mem_16
	bra	main
@@:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	write_mem_16
	bra	main

LD_lnnl_DE:
	move.w	de(a3),d1
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	bsr	write_mem_16
	bra	main
@@:	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	write_mem_16
	bra	main
@@:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	write_mem_16
	bra	main

LD_lnnl_HL:
	move.w	hl(a3),d1
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	bsr	write_mem_16
	bra	main
@@:	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	write_mem_16
	bra	main
@@:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	write_mem_16
	bra	main

LD_lnnl_SP:
	move.w	sp_(a3),d1
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	bsr	write_mem_16
	bra	main
@@:	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	write_mem_16
	bra	main
@@:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	write_mem_16
	bra	main

*******************************************************************
*
*	メモリから 8ビットのデータを読み込むサブルーチン。
*（引数）
*	d0.w ・・・ アドレス
*（動作）
*	d0.b にメモリから読み込んだ値が入る
*
*******************************************************************
read_mem:
	bclr.l	#15,d0
	bne	page_2or3_r8
	bclr.l	#14,d0
	bne	page_1_r8
page_0_r8:
	movea.l	page0-base(a3),a0
	movea.l	rd8_sub_add_p0-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
page_1_r8:
	movea.l	page1-base(a3),a0
	movea.l	rd8_sub_add_p1-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
page_2or3_r8:
	bclr.l	#14,d0
	bra	page_3_r8
page_2_r8:
	movea.l	page2-base(a3),a0
	movea.l	rd8_sub_add_p2-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
page_3_r8:
	movea.l	page3-base(a3),a0
	movea.l	rd8_sub_add_p3-base(a3),a1
	cmp.w	#$3fff,d0
	beq	next_r8
	jmp	(a1)				* rts を省略するために jmp にしてある
next_r8:
	bra	exslotreg_read			* rts を省略するために jmp にしてある

*******************************************************************
*
*	メモリへ 8ビットのデータを書き込むサブルーチン。
*（引数）
*	d0.w ・・・ アドレス
*	d1.b ・・・ 書き込む値
*（動作）
*	d0.w のアドレスに d1の値を書き込む。  
*
*	d2 破壊可能性あり
*
*******************************************************************
write_mem:
	bclr.l	#15,d0
	bne	page_2or3_w8
	bclr.l	#14,d0
	bne	page_1_w8
page_0_w8:
	movea.l	page0-base(a3),a0
	movea.l	wt8_sub_add_p0-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
page_1_w8:
	movea.l	page1-base(a3),a0
	movea.l	wt8_sub_add_p1-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
page_2or3_w8:
	bclr.l	#14,d0
	bne	page_3_w8
page_2_w8:
	movea.l	page2-base(a3),a0
	movea.l	wt8_sub_add_p2-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
page_3_w8:
	movea.l	page3-base(a3),a0
	movea.l	wt8_sub_add_p3-base(a3),a1
	cmp.w	#$3fff,d0
	beq	next_w8
	jmp	(a1)				* rts を省略するために jmp にしてある
next_w8:
	bra	exslotreg_write			* rts を省略するために jmp にしてある

*******************************************************************
*
*	メモリから 16ビットのデータを読み込むサブルーチン。
*（引数）
*	d0.w ・・・ アドレス
*（動作）
*	d0.w にメモリから読み込んだ値が入る
*
*******************************************************************
read_mem_16:
	bclr.l	#15,d0
	bne	page_2or3_r16
	bclr.l	#14,d0
	bne	page_1_r16
page_0_r16:
	movea.l	page0-base(a3),a0
	cmpi.w	#$3fff,d0
	beq	@f				* ページ境界をまたがって読み込む時
	movea.l	rd16_sub_add_p0-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	movea.l	rd8_sub_add_p0-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	clr.w	d0				* ページ１の $0000番地を読む
	movea.l	rd8_sub_add_p1-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	move.w	(sp)+,d0			* 上位バイト読み込み
	move.b	(sp)+,d0			* 下位バイト読み込み
	rts

page_1_r16:
	movea.l	page1-base(a3),a0
	cmpi.w	#$3fff,d0
	beq	@f				* ページ境界をまたがって読み込む時
	movea.l	rd16_sub_add_p1-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	movea.l	rd8_sub_add_p1-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	clr.w	d0				* ページ２の $0000番地を読む
	movea.l	rd8_sub_add_p2-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	move.w	(sp)+,d0			* 上位バイト読み込み
	move.b	(sp)+,d0			* 下位バイト読み込み
	rts

page_2or3_r16:
	bclr.l	#14,d0
	bra	page_3_r16
page_2_r16:
	movea.l	page2-base(a3),a0
	cmpi.w	#$3fff,d0
	beq	@f				* ページ境界をまたがって読み込む時
	movea.l	rd16_sub_add_p2-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	movea.l	rd8_sub_add_p1-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	clr.w	d0				* ページ３の $0000番地を読む
	movea.l	rd8_sub_add_p2-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	move.w	(sp)+,d0			* 上位バイト読み込み
	move.b	(sp)+,d0			* 下位バイト読み込み
	rts

page_3_r16:
	movea.l	page3-base(a3),a0
	move.w	d0,d2				* 0xffffか0xfffeからワード読み込みしよ 
	addq.w	#2,d2				* うとしているか？
	andi.w	#$4000,d2
	bne	@f
	movea.l	rd16_sub_add_p3-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	cmpi.w	#$3fff,d0
	beq	@f
	movea.l	rd8_sub_add_p3-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	bsr	exslotreg_read
	move.b	d0,-(sp)
	move.w	(sp)+,d0			* 上位バイト読み込み
	move.b	(sp)+,d0			* 下位バイト読み込み
	rts
@@:	bsr	exslotreg_read
	move.b	d0,-(sp)
	clr.w	d0
	movea.l	rd8_sub_add_p0-base(a3),a1
	jsr	(a1)
	move.b	d0,-(sp)
	move.w	(sp)+,d0			* 上位バイト読み込み
	move.b	(sp)+,d0			* 下位バイト読み込み
	rts

*******************************************************************
*
*	メモリへ 16ビットのデータを書き込むサブルーチン。
*（引数）
*	d0.w ・・・ アドレス
*（動作）
*	d1.w の内容をメモリに書き込む
*
*	d2 破壊可能性あり
*
*******************************************************************
write_mem_16:
	bclr.l	#15,d0
	bne	page_2or3_w16
	bclr.l	#14,d0
	bne	page_1_w16
page_0_w16:
	movea.l	page0-base(a3),a0
	cmpi.w	#$3fff,d0
	beq	@f				* ページ境界をまたがって読み込む時
	movea.l	wt16_sub_add_p0-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	move.w	d1,-(sp)
	movea.l	wt8_sub_add_p0-base(a3),a1
	jsr	(a1)
	clr.w	d0
	move.b	(sp)+,d1			* d1.b = 上位バイト
	movea.l	wt8_sub_add_p1-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある

page_1_w16:
	movea.l	page1-base(a3),a0
	cmpi.w	#$3fff,d0
	beq	@f				* ページ境界をまたがって読み込む時
	movea.l	wt16_sub_add_p1-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	move.w	d1,-(sp)
	movea.l	wt8_sub_add_p1-base(a3),a1
	jsr	(a1)
	clr.w	d0
	move.b	(sp)+,d1			* d1.b = 上位バイト
	movea.l	wt8_sub_add_p2-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある

page_2or3_w16:
	bclr.l	#14,d0
	bra	page_3_w16
page_2_w16:
	movea.l	page2-base(a3),a0
	cmpi.w	#$3fff,d0
	beq	@f				* ページ境界をまたがって読み込む時
	movea.l	wt16_sub_add_p2-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	move.w	d1,-(sp)
	movea.l	wt8_sub_add_p2-base(a3),a1
	jsr	(a1)
	clr.w	d0
	move.b	(sp)+,d1			* d1.b = 上位バイト
	movea.l	wt8_sub_add_p3-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある

page_3_w16:
	movea.l	page3-base(a3),a0
	move.w	d0,d2				* 0xffffか0xfffeからワード読み込みしよ 
	addq.w	#2,d2				* うとしているか？
	andi.w	#$4000,d2
	bne	@f
	movea.l	wt16_sub_add_p3-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある
@@:	move.w	d1,-(sp)
	cmpi.w	#$3fff,d0
	beq	@f
	movea.l	wt8_sub_add_p3-base(a3),a1
	jsr	(a1)
	move.b	(sp)+,d1			* d1.b = 上位バイト
	bra	exslotreg_write			* rts を省略するために bra にしてある
@@:	move.w	d1,-(sp)
	bsr	exslotreg_write
	clr.w	d0
	move.b	(sp)+,d1			* d1.b = 上位バイト
	movea.l	wt8_sub_add_p0-base(a3),a1
	jmp	(a1)				* rts を省略するために jmp にしてある

*************************************************************************
*
*	拡張スロット選択レジスタの値の読み込み
*
*	d0.b 読み込んだ値
*
*************************************************************************
exslotreg_read:
	move.b	slot_reg,d0			* page 3 のスロット番号を調べる
	lsr.b	#6,d0
	ext.w	d0
	cmpi.b	#0,slot_0_ex-base(a3,d0.w)	* そのスロットは拡張されているか？
	beq	not_extend_r
	move.b	exslot_reg_0-base(a3,d0.w),d0	* 拡張スロット選択レジスタの値を読む
	eori.b	#$ff,d0				* １の補数を取る
	rts
not_extend_r:					* 拡張されてなければそのまま読む
	jmp	(a1)				* rts省略のため jmpにしてある

*****************************************************************************
*
*	拡張スロット選択レジスタへの値の書き込み。切り替えたスロットが
*	表に出ていればそれを切り替える。
*
*	d1.b ・・・ 書き込む値
*
*****************************************************************************
exslotreg_write:
	move.b	slot_reg,d2			* page 3 のスロット番号を調べる
	lsr.b	#6,d2
	ext.w	d2
	cmpi.b	#0,slot_0_ex-base(a3,d2.w)	* そのスロットは拡張されているか？
	beq	not_extend_w
	move.b	d1,exslot_reg_0-base(a3,d2.w)	* 拡張スロット選択レジスタへ値を書く

	move.l	a2,-(sp)
	move.l	a1,-(sp)
	lea.l	base2,a2
	lea.l	slot_0_0,a1

*	ページ３は当然表に出ているので切り替え
	move.w	d2,-(sp)
	lsl.w	#4,d2				* d2 = 切り替えたスロット番号 * 64
	move.b	d1,d0
	andi.w	#%00000000_11000000,d0
	lsr.w	#2,d0				* d0 = 拡張スロット番号 * 16
	add.w	d2,d0
	movea.l	4*3(a1,d0.w),a0
	move.l	a0,page3-base(a3)

	move.b	-headerlength(a0),d0		* スロットの種類に応じて読み書きルーチ
	ext.w	d0				* ンを設定
	lsl.w	#2,d0
	move.l	 wt8_sub_add_0-base2(a2,d0.w), wt8_sub_add_p3-base2(a2)
	move.l	wt16_sub_add_0-base2(a2,d0.w),wt16_sub_add_p3-base2(a2)
	move.l	 rd8_sub_add_0-base2(a2,d0.w), rd8_sub_add_p3-base2(a2)
	move.l	rd16_sub_add_0-base2(a2,d0.w),rd16_sub_add_p3-base2(a2)

*	ページ０は表に出てるか？
	move.b	slot_reg,d0
	andi.w	#%00000000_00000011,d0
	move.w	(sp),d2
	lsr.w	#2,d2
	cmp.w	d2,d0
	bne	not_exist0
	lsl.w	#6,d2				* d2 = 切り替えたスロット番号 * 64
	move.b	d1,d0
	andi.w	#%00000000_00000011,d0
	lsl.w	#4,d0				* d0 = 拡張スロット番号 * 16
	add.w	d2,d0
	movea.l	4*0(a1,d0.w),a0
	move.l	a0,page0-base(a3)

	move.b	-headerlength(a0),d0		* スロットの種類に応じて読み書きルーチ
	ext.w	d0				* ンを設定
	lsl.w	#2,d0
	move.l	 wt8_sub_add_0-base2(a2,d0.w), wt8_sub_add_p0-base2(a2)
	move.l	wt16_sub_add_0-base2(a2,d0.w),wt16_sub_add_p0-base2(a2)
	move.l	 rd8_sub_add_0-base2(a2,d0.w), rd8_sub_add_p0-base2(a2)
	move.l	rd16_sub_add_0-base2(a2,d0.w),rd16_sub_add_p0-base2(a2)

*	ページ１は表に出てるか？
not_exist0:
	move.b	slot_reg,d0	
	andi.w	#%00000000_00001100,d0
	move.w	(sp),d2
	cmp.w	d2,d0
	bne	not_exist1
	lsl.w	#4,d2				* d2 = 切り替えたスロット番号 * 64
	move.b	d1,d0
	andi.w	#%00000000_00001100,d0
	lsl.w	#2,d0				* d0 = 拡張スロット番号 * 16
	add.w	d2,d0
	movea.l	4*1(a1,d0.w),a0
	move.l	a0,page1-base(a3)

	move.b	-headerlength(a0),d0		* スロットの種類に応じて読み書きルーチ
	ext.w	d0				* ンを設定
	lsl.w	#2,d0
	move.l	 wt8_sub_add_0-base2(a2,d0.w), wt8_sub_add_p1-base2(a2)
	move.l	wt16_sub_add_0-base2(a2,d0.w),wt16_sub_add_p1-base2(a2)
	move.l	 rd8_sub_add_0-base2(a2,d0.w), rd8_sub_add_p1-base2(a2)
	move.l	rd16_sub_add_0-base2(a2,d0.w),rd16_sub_add_p1-base2(a2)

*	ページ２は表に出てるか？
not_exist1:
	move.b	slot_reg,d0
	andi.w	#%00000000_00110000,d0
	move.w	(sp),d2
	lsl.w	#2,d2
	cmp.w	d2,d0
	bne	not_exist2
	lsl.w	#2,d2				* d2 = 切り替えたスロット番号 * 64
	move.b	d1,d0
	andi.w	#%00000000_00110000,d0		* d0 = 拡張スロット番号 * 16
	add.w	d2,d0
	movea.l	4*2(a1,d0.w),a0
	move.l	a0,page2-base(a3)

	move.b	-headerlength(a0),d0		* スロットの種類に応じて読み書きルーチ
	ext.w	d0				* ンを設定
	lsl.w	#2,d0
	move.l	 wt8_sub_add_0-base2(a2,d0.w), wt8_sub_add_p2-base2(a2)
	move.l	wt16_sub_add_0-base2(a2,d0.w),wt16_sub_add_p2-base2(a2)
	move.l	 rd8_sub_add_0-base2(a2,d0.w), rd8_sub_add_p2-base2(a2)
	move.l	rd16_sub_add_0-base2(a2,d0.w),rd16_sub_add_p2-base2(a3)
not_exist2:
	move.l	(sp)+,a1
	move.l	(sp)+,a2
	rts

not_extend_w:				* 拡張されてなければそのまま書き込む
	jmp	(a1)			* rts省略のため jmpにしてある


*------ ＡＤＤ ------
ADD_A_A:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d4,HC2(a3)		* 足す数を HC2に
	add.b	d4,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
NC_ADD_A1:
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

V_ADD_A:
	bcc	NC_ADD_A2
	ori.w	#%00000001_00000000,d6	* Ｃをセット
NC_ADD_A2:
	clr.b	PV(a3)			* PVをセット
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

ADD_A_B:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	b(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

ADD_A_C:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	c(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

ADD_A_D:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

ADD_A_E:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	e(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

ADD_A_H:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	h(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

ADD_A_L:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	l(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADD_A_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	move.b	d4,d5
	bra	main
ADD_A_n:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	move.b	d4,d5
	bra	main

ADD_HL_BC:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	bc(a3),d0
	add.w	d0,hl(a3)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main

ADD_HL_DE:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	de(a3),d0
	add.w	d0,hl(a3)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main

ADD_HL_HL:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	hl(a3),d0
	add.w	d0,hl(a3)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main

ADD_HL_SP:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	sp_(a3),d0
	add.w	d0,hl(a3)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main


*	------ ＡＤＣ ------
ADC_A_A:
	btst.l	#8,d6
	beq	ADD_A_A			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,HC2(a3)		* 足す数を HC2に
	addx.b	d4,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
NC_ADC_A1:
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

V_ADC_A:
	bcc	NC_ADC_A2
	ori.w	#%00000001_00000000,d6	* Ｃをセット
NC_ADC_A2:
	clr.b	PV(a3)			* PVをセット	
	move.b	d4,d6
	move.b	d4,d5
	bra	main

ADC_A_B:
	btst.l	#8,d6
	beq	ADD_A_B			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	b(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_C:
	btst.l	#8,d6
	beq	ADD_A_C			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	c(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_D:
	btst.l	#8,d6
	beq	ADD_A_D			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_E:
	btst.l	#8,d6
	beq	ADD_A_E			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	e(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_H:
	btst.l	#8,d6
	beq	ADD_A_H			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	h(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_L:
	btst.l	#8,d6
	beq	ADD_A_L			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	l(a3),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_lHLl:
	btst.l	#8,d6
	beq	ADD_A_lHLl		* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	move.w	hl(a3),d0
	bsr	read_mem
	clr.b	d6			* X ビットをセット
	subq.b	#1,d6
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_n:
	btst.l	#8,d6
	beq	ADD_A_n			* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	clr.b	d6			* X ビットをセット
	subq.b	#1,d6
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main


*	------ ＳＵＢ ------
SUB_A:	andi.w	#%11110110_00000000,d6	* Ｃ,HC mode をクリア。 SZ を０に
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d6,d4
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d5
	move.b	d4,HC2(a3)
	bra	main

C_SUB_A1:
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	bra	main

V_SUB_A:
	bcc	NC_SUB_A2
	ori.w	#%00000001_00000000,d6	* Ｃをセット
NC_SUB_A2:
	clr.b	PV(a3)		* PVをセット	
	move.b	d4,d6			* 結果を SZ にセット		
	bra	main

SUB_B:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	b(a3),HC2(a3)		* 引く数を HC2に
	sub.b	b(a3),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	bra	main

SUB_C:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	c(a3),HC2(a3)		* 引く数を HC2に
	sub.b	c(a3),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SUB_D:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d(a3),HC2(a3)		* 引く数を HC2に
	sub.b	d(a3),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SUB_E:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	e(a3),HC2(a3)		* 引く数を HC2に
	sub.b	e(a3),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SUB_H:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	h(a3),HC2(a3)		* 引く数を HC2に
	sub.b	h(a3),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SUB_L:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	l(a3),HC2(a3)		* 引く数を HC2に
	sub.b	l(a3),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SUB_lHLl:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	sub.b	d0,d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SUB_n:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	sub.b	d0,d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main


*	------ ＳＢＣ ------
SBC_A_A:
	btst.l	#8,d6
	beq	SUB_A			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_11111111,d6	* Ｎ,Ｃ, HC mode をセット。SZ を $ffに
	move.b	d6,d4			* A レジスタを $FFに
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d5,HC2(a3)		* HC1と HC2を同じに
	clr.b	d6			* SZ を０に
	bra	main

NC_SBC_A1:
	andi.w	#%11111110_11111111,d6	* Ｃをクリア
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main

V_SBC_A:
	bcs	C_SBC_A2
	andi.w	#%11111110_11111111,d6	* Ｃをクリア
C_SBC_A2:
	clr.b	PV(a3)		* PVをセット	
	move.b	d4,d6			* sz をセット
	bra	main

SBC_A_B:
	btst.l	#8,d6
	beq	SUB_B			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	b(a3),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_C:
	btst.l	#8,d6
	beq	SUB_C			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	c(a3),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_D:
	btst.l	#8,d6
	beq	SUB_D			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d(a3),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_E:
	btst.l	#8,d6
	beq	SUB_E			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	e(a3),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_H:
	btst.l	#8,d6
	beq	SUB_H			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	h(a3),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_L:
	btst.l	#8,d6
	beq	SUB_L			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	l(a3),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_lHLl:
	btst.l	#8,d6
	beq	SUB_lHLl		* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	move.w	hl(a3),d0
	bsr	read_mem
	clr.b	d6			* X ビットをセット
	subq.b	#1,d6
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_n:
	btst.l	#8,d6
	beq	SUB_n			* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	clr.b	d6			* X ビットをセット
	subq.b	#1,d6
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main


*	------ ＡＮＤ ------
AND_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	b(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	c(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	d(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	e(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	h(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	l(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	move.w	hl(a3),d0
	bsr	read_mem
	and.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

AND_n:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	next_andn
	bsr	PC_page_CHG
next_andn:
	and.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

*	------ ＸＯＲ ------
XOR_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	eor.b	d4,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	b(a3),d0		* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	c(a3),d0		* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	d(a3),d0		* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	e(a3),d0		* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	h(a3),d0		* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	l(a3),d0		* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.w	hl(a3),d0
	bsr	read_mem
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_n:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	next_xorn
	bsr	PC_page_CHG
next_xorn:
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	


*	------ ＯＲ ------
OR_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	b(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	c(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	d(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	e(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	h(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	l(a3),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.w	hl(a3),d0
	bsr	read_mem
	or.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_n:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	next_orn
	bsr	PC_page_CHG
next_orn:
	or.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

*	------ ＣＰ ------
CP_A:	andi.w	#%11110110_00000000,d6	* Ｃ,HC mode をクリア。 SZを０に
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d5
	move.b	d4,HC2(a3)
	bra	main

C_CP_A1:
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6			* 結果を SZ にセット		
	bra	main

V_CP_A:
	bcc	NC_CP_A2
	ori.w	#%00000001_00000000,d6	* Ｃをセット
NC_CP_A2:
	clr.b	PV(a3)		* PVをセット	
	move.b	d1,d6			* 結果を SZ にセット		
	bra	main

CP_B:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	b(a3),HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	b(a3),d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6			* 結果を SZ にセット		
	bra	main

CP_C:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	c(a3),HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	c(a3),d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

CP_D:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d(a3),HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	d(a3),d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

CP_E:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	e(a3),HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	e(a3),d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

CP_H:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	h(a3),HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	h(a3),d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

CP_L:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	l(a3),HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	l(a3),d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

CP_lHLl:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	d0,d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

CP_n:	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	0(a4,d7.w),d0
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	move.b	d4,d1	
	sub.b	d0,d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

*	------ ＩＮＣ ------
INC_A:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	addq.b	#1,d4
	bVS	V_incA
	move.b	#1,PV(a3)		* PVをクリア
V_incA:
	move.b	d4,d6
	move.b	d4,d5
	move.b	#1,HC2(a3)
	bra	main

INC_B:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	b(a3),d0
	addq.b	#1,d0
	bVS	V_incB
	move.b	#1,PV(a3)		* PVをクリア
V_incB:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,b(a3)
	move.b	#1,HC2(a3)
	bra	main

INC_C:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	c(a3),d0
	addq.b	#1,d0
	bVS	V_incC
	move.b	#1,PV(a3)		* PVをクリア
V_incC:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,c(a3)
	move.b	#1,HC2(a3)
	bra	main

INC_D:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	d(a3),d0
	addq.b	#1,d0
	bVS	V_incD
	move.b	#1,PV(a3)		* PVをクリア
V_incD:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,d(a3)
	move.b	#1,HC2(a3)
	bra	main

INC_E:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	e(a3),d0
	addq.b	#1,d0
	bVS	V_incE
	move.b	#1,PV(a3)		* PVをクリア
V_incE:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,e(a3)
	move.b	#1,HC2(a3)
	bra	main

INC_H:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	h(a3),d0
	addq.b	#1,d0
	bVS	V_incH
	move.b	#1,PV(a3)		* PVをクリア
V_incH:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,h(a3)
	move.b	#1,HC2(a3)
	bra	main

INC_L:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	l(a3),d0
	addq.b	#1,d0
	bVS	V_incL
	move.b	#1,PV(a3)		* PVをクリア
V_incL:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,l(a3)
	move.b	#1,HC2(a3)
	bra	main

INC_lHLl:
	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)			* PVをセット	
	move.w	hl(a3),d0
	bsr	read_mem
	addq.b	#1,d0
	bVS	V_inchl
	move.b	#1,PV(a3)		* PVをクリア
V_inchl:
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,l(a3)
	move.b	#1,HC2(a3)
	bra	main

INC_BC:
	addq.w	#1,bc(a3)
	bra	main
INC_DE:
	addq.w	#1,de(a3)
	bra	main
INC_HL:
	addq.w	#1,hl(a3)
	bra	main
INC_SP:
	addq.l	#1,sp_(a3)
	bra	main

*	------ ＤＥＣ ------
DEC_A:	ori.w	#%00001010_00000000,d6	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	subq.b	#1,d4
	bVS	V_decA
	move.b	#1,PV(a3)		* PVをクリア
V_decA:
	move.b	d4,d6
	move.b	d4,d5
	clr.b	HC2(a3)			 *引く数を０に(HC modeが 1になっていることに注意)
	bra	main

DEC_B:	ori.w	#%00001010_00000000,d6	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	b(a3),d0
	subq.b	#1,d0
	bVS	V_decB
	move.b	#1,PV(a3)		* PVをクリア
V_decB:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,b(a3)
	clr.b	HC2(a3)
	bra	main

DEC_C:	ori.w	#%00001010_00000000,d6	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	c(a3),d0
	subq.b	#1,d0
	bVS	V_decC
	move.b	#1,PV(a3)		* PVをクリア
V_decC:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,c(a3)
	clr.b	HC2(a3)
	bra	main

DEC_D:	ori.w	#%00001010_00000000,d6	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	d(a3),d0
	subq.b	#1,d0
	bVS	V_decD
	move.b	#1,PV(a3)		* PVをクリア
V_decD:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,d(a3)
	clr.b	HC2(a3)
	bra	main

DEC_E:	ori.w	#%00001010_00000000,d6	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	e(a3),d0
	subq.b	#1,d0
	bVS	V_decE
	move.b	#1,PV(a3)		* PVをクリア
V_decE:
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,e(a3)
	clr.b	HC2(a3)
	bra	main

DEC_H:	ori.w	#%00001010_00000000,d6	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	h(a3),d0
	subq.b	#1,d0
	bVS	@f
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,h(a3)
	clr.b	HC2(a3)
	bra	main

DEC_L:	ori.w	#%00001010_00000000,d6	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	l(a3),d0
	subq.b	#1,d0
	bVS	@f
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,l(a3)
	clr.b	HC2(a3)
	bra	main

DEC_lHLl:
	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	clr.b	PV(a3)			* PVをセット	
	move.w	hl(a3),d0
	bsr	read_mem
	subq.b	#1,d0
	bVS	V_dechl
	move.b	#1,PV(a3)		* PVをクリア
V_dechl:
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,l(a3)
	move.b	#1,HC2(a3)
	bra	main

DEC_BC:
	subq.w	#1,bc(a3)
	bra	main
DEC_DE:
	subq.w	#1,de(a3)
	bra	main
DEC_HL:
	subq.w	#1,hl(a3)
	bra	main
DEC_SP:
	subq.l	#1,sp_(a3)
	bra	main


*	Ａレジスタの値が規定外の時の動きが正しいかどうかわからない
*	------ ＤＡＡ ------
DAA:	btst.l	#9,d6			* N フラグを調べる
	bne	1f			* 減算の時

	move.w	d6,d0			* ハーフキャリーフラグを調べる
	andi.w	#%00001000_00000000,d0	* HC mode を調べる
	rol.w	#5,d0
	move.b	HC2(a3),d1		
	andi.w	#$000f,d5		* HC1 HC2 を４ビットのみ有効にする
	andi.w	#$000f,d1
	add.w	d0,d1
	cmp.w	d0,d5			* HC1-(HC2 + HC mode)
	bcs	@f			* HC が１の時
	move.b	d4,d0
	andi.b	#%0000_1111,d0
	cmpi.b	#$0a,d0
	bmi	2f			* １ケタめが０〜９の範囲に入っていた時
@@:	addq.b	#$06,d4
	bcs	@f			* ケタ上がりが起きた時(普通は起きない)

2:	btst.l	#8,d6			* Ｃを調べる
	bne	@f			* Ｃが１の時
	move.b	d4,d0
	andi.b	#%1111_0000,d0
	cmpi.b	#$a0,d0
	bmi	2f			* ２ケタ目が０〜９の範囲に入っていた時
@@:	addi.b	#$60,d4	
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main

2:	andi.w	#%11111110_11111111,d6	* Ｃをクリア
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main

1:					* 減算の時
	btst.l	#8,d6			* Ｃを調べる
	bne	@f			* Ｃが１の時
	move.b	d4,d0
	andi.b	#%1111_0000,d0
	cmpi.b	#$a0,d0
	bmi	2f			* ２ケタめが０〜９の範囲に入っていた時
@@:	subi.b	#$60,d4
	ori.w	#%00000001_00000000,d6	* Ｃをセット

2:	move.w	d6,d0			* ハーフキャリーフラグを調べる
	andi.w	#%00001000_00000000,d0	* HC mode を調べる
	rol.w	#5,d0
	move.b	HC2(a3),d1		
	andi.w	#$000f,d5		* HC1 HC2 を４ビットのみ有効にする
	andi.w	#$000f,d1
	add.w	d0,d1
	cmp.w	d0,d5			* HC1-(HC2 + HC mode)
	bcs	@f			* HC が１の時
	move.b	d4,d0
	andi.b	#%0000_1111,d0
	cmpi.b	#$0a,d0
	bmi	2f			* １ケタ目が０〜９の範囲に入っていた時
@@:	subq.b	#$06,d4	
2:	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main


*	------ ＪＰ ------
JP:	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	cmpi.w	#$3fff,d7
	beq	next_jp
	move.w	d0,d7
	bsr	PC_page_set
	bra	main
next_jp:				* 命令がページ境界をまたいでいる時
	move.b	d0,d2			* 下位８ビットをとっておく
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d7
	move.b	d2,d7
	bsr	PC_page_set
	bra	main

JP_lHLl:
	move.w	hl(a3),d7
	bsr	PC_page_set
	bra	main

JP_C:	btst.l	#8,d6		* Ｃｙフラグをテスト
	bne	JP		* Ｃｙが１ならジャンプ
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JP_NC:	btst.l	#8,d6		* Ｃｙフラグをテスト
	beq	JP		* Ｃｙが０ならジャンプ
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JP_Z:	move.b	d6,d6		* Ｚフラグをテスト
	beq	JP		* ０ならジャンプ
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JP_NZ:	tst.b	d6		* Ｚフラグをテスト
	bne	JP		* ０でないならジャンプ
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JP_PE:	move.b	PV(a3),d0
	clr.w	d1
	clr.w	d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	andi.b	#1,d2	
	beq	JP
	addq.w	#2,d7		* 奇数だからジャンプしない
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JP_PO:	move.b	PV(a3),d0
	clr.w	d1
	clr.w	d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	andi.b	#1,d2	
	bne	JP		* 奇数だからジャンプ
	addq.w	#2,d7		* 偶数だからジャンプしない
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JP_P:	tst.b	d6
	bpl	JP
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JP_M:	tst.b	d6
	bmi	JP
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

*	------ ＪＲ ------
JR:	move.l	d7,d0
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d7		* d7 = PC (R800)
	addq.w	#1,d7		* d7 = 次の命令の位置
	move.b	0(a4,d7.w),d0	* 相対移動量を読み込む
	ext.w	d0		* ワードに符号拡張
	add.w	d0,d7		* 足し算
	bsr	PC_page_set
	bra	main

JR_NZ:	tst.b	d6		* Ｚフラグをテスト
	bne	JR		* ０でないならジャンプ
	addq.l	#1,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JR_Z:	tst.b	d6		* Ｚフラグをテスト
	beq	JR		* ０ならジャンプ
	addq.l	#1,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JR_NC:	btst.l	#8,d6		* Ｃｙフラグをテスト
	beq	JR		* Ｃｙが０ならジャンプ
	addq.l	#1,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

JR_C:	btst.l	#8,d6		* Ｃｙフラグをテスト
	bne	JR		* Ｃｙが１ならジャンプ
	addq.l	#1,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG	* 命令がページ境界をまたいだ時
	bra	main

*	------ ＣＡＬＬ ------
CALL:	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16

	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 

	cmpi.w	#$3fff,d7
	beq	next_call
	move.w	d0,d7
	bsr	PC_page_set
	bra	main
next_call:				* 命令がページ境界をまたいだ時
	move.b	d0,d2			* 下位８ビットをとっておく
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d7
	move.b	d2,d7
	bsr	PC_page_set
	bra	main

CALL_C:	btst.l	#8,d6		* Ｃｙフラグをテスト
	bne	CALL		* Ｃｙが１ならコール
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

CALL_NC: btst.l	#8,d6		* Ｃｙフラグをテスト
	beq	CALL		* Ｃｙが０ならコール
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

CALL_Z:	tst.b	d6		* Ｚフラグをテスト
	beq	CALL		* ０ならコール
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

CALL_NZ: tst.b	d6		* Ｚフラグをテスト
	bne	CALL		* ０でないならコール
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

CALL_PE:
	move.b	PV(a3),d0
	clr.w	d1
	clr.w	d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	andi.b	#1,d2	
	beq	CALL		* 偶数だからコール
	addq.w	#2,d7		* 奇数だからコールしない
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

CALL_PO:
	move.b	PV(a3),d0
	clr.w	d1
	clr.w	d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	lsr.b	#1,d0
	addx.w	d1,d2
	andi.b	#1,d2	
	bne	CALL		* 奇数だからコール
	addq.w	#2,d7		* 偶数だからコールしない
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

CALL_P:	tst.b	d6
	bpl	CALL
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

CALL_M:	tst.b	d6
	bmi	CALL
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＲＥＴ ------
RET:	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,d7
	bsr	PC_page_set
	bra	main

RET_C:	btst.l	#8,d6		* Ｃｙフラグをテスト
	bne	RET		* Ｃｙが１ならリターン
	bra	main

RET_NC:	btst.l	#8,d6		* Ｃｙフラグをテスト
	beq	RET		* Ｃｙが０ならリターン
	bra	main

RET_Z:	tst.b	d6		* Ｚフラグをテスト
	beq	RET		* ０ならリターン
	bra	main

RET_NZ:	tst.b	d6		* Ｚフラグをテスト
	bne	RET		* ０でないならリターン
	bra	main

RET_M:	tst.b	d6		* Ｚフラグをテスト
	bmi	RET		* ０ならリターン
	bra	main

RET_PE:	move.b	PV(a3),d0
	moveq.l	#8,d1		* ループカウンタ
loop_RET_PE_Even:
	lsr.b	#1,d0
	bcs	loop_RET_PO_Odd	* 奇数へ
	subq.w	#1,d1
	bne	loop_RET_PO_Even
	bra	RET		* 最終的にこっちに来た時は、偶数だからリターン
loop_RET_PE_Odd:
	lsr.b	#1,d0
	bcs	loop_RET_PO_Even	* 奇数へ
	subq.w	#1,d1
	bne	loop_RET_PO_Odd
	addq.l	#2,a4		* 最終的にこっちに来た時は、奇数だからリターンしない
	bra	main

RET_PO:	move.b	PV(a3),d0
	moveq.l	#8,d1		* ループカウンタ
loop_RET_PO_Even:
	lsr.b	#1,d0
	bcs	loop_RET_PO_Odd	* 奇数へ
	subq.w	#1,d1
	bne	loop_RET_PO_Even
	addq.l	#2,a4		* 最終的にこっちに来た時は、偶数だからリターンしない
	bra	main
loop_RET_PO_Odd:
	lsr.b	#1,d0
	bcs	loop_RET_PO_Even	* 奇数へ
	subq.w	#1,d1
	bne	loop_RET_PO_Odd
	bra	RET		* 最終的にこっちに来た時は、奇数だからリターン

*	------ ＤＪＮＺ ------
DJNZ:	subq.w	#1,b(a3)	* b = b-1
	bne	JR		* b != 0 ならブランチ
	addq.w	#1,d7
	bclr.l	#14,d7
	beq	main
	bsr	PC_page_CHG
	bra	main

*	------ ＰＵＳＨ  ＰＯＰ ------
PUSH_AF: move.b	PV(a3),d0
	ori.w	#%00000100_00000000,d6	* P/V フラグをセット
	moveq.l	#8,d1
loop_PUSH_AF:
	lsr.b	#1,d0
	bcc	not_1
	eori.w	#%00000100_00000000,d6	* P/V フラグを反転
not_1:	subq.w	#1,d1
	bne	loop_PUSH_AF

	andi.w	#%00101111_11111111,d6	* SZH フラグをリセット
	move.w	d6,d0			* ハーフキャリーフラグを調べる
	andi.w	#%00001000_00000000,d0	* HC mode を調べる
	rol.w	#5,d0
	move.b	HC2(a3),d1		
	andi.w	#$000f,d5		* HC1 HC2 を４ビットのみ有効にする
	andi.w	#$000f,d1
	add.w	d0,d1
	cmp.w	d0,d5			* HC1-(HC2 + HC mode)
	bcc	not_HC_1
	ori.w	#%00010000_00000000,d6	* H フラグをセット
not_HC_1:
	tst.b	d6
	bmi	minus
	bne	next_pushAF
	ori.w	#%01000000_00000000,d6	* Z フラグをセット
	bra	next_pushAF
minus:
	ori.w	#%10000000_00000000,d6	* S フラグをセット
next_pushAF:
	move.b	d4,-(sp)
	move.w	(sp)+,d1		* A レジスタをロード
	move.w	d6,-(sp)
	move.b	(sp)+,d1		* フラグのロード
	andi.b	#%11010111,d1		* フラグと関係無い部分の削除
	move.b	f(a3),d0
	andi.b	#%00101000,d0		* フラグと関係無い部分のロード
	or.b	d0,d1
	subq.w	#2,sp_(a3)
	move.w	sp_(a3),d0
	bsr	write_mem_16
	bra	main

POP_AF:	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)

	move.w	d0,-(sp)		* Aレジスタをセット
	move.b	(sp)+,d4
	move.b	d0,f(a3)		* フラグのロード
	clr.b	PV(a3)
	btst.l	#2,d0			* P/V フラグを調べる
	bne	not_0_popAF
	move.b	#1,PV(a3)		* 奇数にする
not_0_popAF:
	move.b	d0,-(sp)
	move.w	(sp)+,d6		* フラグのロード
	andi.w	#%00000011_00000000,d6	* N,Cのみ有効に。SZ, HC mode を０に
	clr.b	d5			* HC1
	clr.b	HC2(a3)

	btst.l	#4,d0			* HC フラグを調べる
	beq	SZ_test
	move.w	#1,HC2(a3)
SZ_test:
	andi.b	#%11000000,d0
	beq	plus_popAF		* 全部立っていなければプラス
	bpl	main			* S フラグが立っていなければゼロ
	move.b	#-1,d6
	bra	main
plus_popAF:
	move.b	#1,d6
	bra	main

PUSH_BC:
	subq.w	#2,sp_(a3)
	move.w	sp_(a3),d0
	move.w	bc(a3),d0
	bsr	write_mem_16
	bra	main
POP_BC:
	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,bc(a3)
	bra	main

PUSH_DE:
	subq.w	#2,sp_(a3)
	move.w	sp_(a3),d0
	move.w	de(a3),d0
	bsr	write_mem_16
	bra	main
POP_DE:
	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,de(a3)
	bra	main

PUSH_HL:
	subq.w	#2,sp_(a3)
	move.w	sp_(a3),d0
	move.w	hl(a3),d0
	bsr	write_mem_16
	bra	main
POP_HL:
	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,hl(a3)
	bra	main

*	------ ＥＸ ------
EX_lSPl_HL:
	move.w	sp_(a3),d0
	bsr	read_mem_16
	move.w	hl(a3),d1
	move.w	d0,hl(a3)
	move.w	sp_(a3),d0
	bsr	write_mem_16
	bra	main

EXX:	move.l	bc(a3),d0	* d0 = bc, de
	move.w	hl(a3),d1

	move.l	bc_(a3),bc(a3)
	move.w	hl_(a3),hl(a3)

	move.l	d0,bc_(a3)
	move.w	d1,hl_(a3)

	bra	main

EX_DE_HL:
	move.w	de(a3),d0
	move.w	hl(a3),de(a3)
	move.w	d0,hl(a3)
	bra	main

EX_AF_AFd:
	move.w	af_(a3),d0
	move.b	f(a3),f_(a3)
	move.b	d0,f(a3)
	move.b	d4,a_(a3)
	move.w	d0,-(sp)
	move.b	(sp)+,d4

	move.b	HC1_d(a3),d0		* フラグの入れ換え
	move.l	d5,HC1_d(a3)
	move.l	d0,d5

	move.l	PV(a3),d0
	move.l	PV_d(a3),PV(a3)
	move.l	d0,PV_d(a3)

	bra	main


CCF:	andi.w	#%11110101_11111111,d6	* HC mode と Nを０に
	bchg.l	#8,d6			* Cyを調べて反転
	beq	Cy_0
	clr.b	d5			* HC を１に。HC には Cyの元の値が入る
	move.b	#1,HC2(a3)
	bra	main	
Cy_0:
	move.b	d5,HC2(a3)		* HC を０に。
	bra	main

SCF:	andi.w	#%11110101_11111111,d6	* HC mode と Nを０に
	ori.w	#%00000001_00000000,d6	* Cy を１に
	move.b	d5,HC2(a3)		* HC を０に。
	bra	main

CPL:	ori.w	#%00001010_00000000,d6	* N,HC mode を１に
	move.b	d5,HC2(a3)		* HC を０に。（HC mode が 1だから０になる）
	eori.b	#$ff,d4			* Aレジスタを反転
	bra	main

DI:	bset.b	#7,interrupt_status
	bra	main

EI:	bclr.b	#7,interrupt_status	* EIは１命令おいて実行される
	clr.l	d0			* d0 の上位ビットを０にクリア
	move.b	0(a4,d7.w),d0		* 命令を読み込む
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	add.w	d0,d0		* d0 = d0 x 2
	lea.l	instructions(pc),a0
	move.w	0(a0,d0.w),d0
	jmp	0(a0,d0.w)


RST_00H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0000,d7
	bsr	PC_page_set
	bra	main
RST_08H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0008,d7
	bsr	PC_page_set
	bra	main
RST_10H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0010,d7
	bsr	PC_page_set
	bra	main
RST_18H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0018,d7
	bsr	PC_page_set
	bra	main
RST_20H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0020,d7
	bsr	PC_page_set
	bra	main
RST_28H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0028,d7
	bsr	PC_page_set
	bra	main
RST_30H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0030,d7
	bsr	PC_page_set
	bra	main
RST_38H:
	move.l	d7,d0
	move.l	d7,d1
	swap	d0		* d0 = 00000000_000000pp
	ror.w	#2,d0		* d0 = pp000000_00000000
	or.w	d0,d1		* d1 = PC (R800)
	addq.w	#2,d1		* d1 = next Instruction
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	bsr	write_mem_16
	move.w	#$0038,d7
	bsr	PC_page_set
	bra	main


*	------ ＲＬＣＡ ------
RLCA:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	rol.b	#1,d4
	bcc	main
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
	bra	main

*	------ ＲＲＣＡ ------
RRCA:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	ror.b	#1,d4
	bcc	main
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
	bra	main

*	------ ＲＬＡ ------
RLA:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	RLA_2			* CY が０の時
	lsl.b	#1,d4
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	ori.w	#%00000000_00000001,d4	* 最下位ビットをセット
	bra	main

RLA_2:	lsl.b	#1,d4
	bcc	main
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
	bra	main


*	------ ＲＲＡ ------
RRA:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	RRA_2			* CY が０の時
	lsr.b	#1,d4
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	ori.w	#%00000000_00000001,d4	* 最下位ビットをセット
	bra	main

RRA_2:	lsr.b	#1,d4
	bcc	main
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
	bra	main

*	------ ＨＡＬＴ ------
HALT:	clr.w	CPU_mode-base(a3)
@@:	tst.w	CPU_mode-base(a3)	* 割り込みによって CPU_mode が１になるまで
	beq	@b			* ループ
	bra	main



*
*	＄ＣＢライン命令
*
*	  c    b   
*	%1100_1011_cccc_crrr
*
*		ccccc ・ 00000	RLC
*			 00001	RRC
*			 00010	RL
*			 00011	RR
*			 00100	SLA
*			 00101	SRA
*			 00110	SLL		* undifined instruction
*			 00111	SRL
*
*			 01000
*			   |	BIT 0〜7
*			 01111
*
*			 10000
*			   |	RES 0〜7
*			 10111
*
*			 11000
*			   |	SET 0〜7
*			 11111
*
*		rrr ・・ 000 - b
*			 001 - c
*			 010 - d
*			 011 - e
*			 100 - h
*			 101 - l
*			 110 - (hl)
*			 111 - a
*
*
CB:
	move.b	0(a4,d7.w),d0		* 第二オペコードを読み込む
	addq.w	#1,d7
	bclr.l	#14,d7
	beq	next_cb
	bsr	PC_page_CHG
next_cb:
	bclr.l	#7,d0			* ００Ｈ〜７ＦＨの命令かどうか
	beq	case2			* そうなら case2へ
case1:
	bclr.l	#6,d0
	beq	RES			* ＲＥＳ命令

*	------ ＳＥＴ ------
SET:	move.b	d0,d1
	andi.w	#%00000000_00111000,d0		* BIT_n_? の n を d0にロード
	lsr.w	#3,d0

	andi.w	#%00000000_00000111,d1		* レジスタの値をロード
	addq.w	#2,d1
	bclr.l	#3,d1
	bne	SET_aorhl			* SET A, SET (HL)の時
	bset.b	d0,a(a3,d1.w)			* レジスタの nビット目をセット
	bra	main

SET_aorhl:
	tst.w	d1
	beq	set_lhll
	bset.l	d0,d4				* A レジスタの nビット目をセット
	bra	main
set_lhll
	move.w	d0,d1
	move.w	hl(a3),d0
	bsr	read_mem
	bset.l	d1,d0				* (HL)の nビット目をセット
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem		
	bra	main

*	------ ＲＥＳ ------
RES:	move.b	d0,d1
	andi.w	#%0011_1000,d0			* BIT_n_? の n を d0にロード
	lsr.w	#3,d0

	addq.w	#2,d1
	bclr.l	#3,d1
	bne	RES_aorhl			* RES A, RES (HL)の時
	bclr.b	d0,a(a3,d1.w)			* レジスタの nビット目をセット
	bra	main
RES_aorhl:
	tst.w	d1
	beq	RES_lhll
	bclr.l	d0,d4				* A レジスタの nビット目をセット
	bra	main
RES_lhll
	move.w	d0,d1
	move.w	hl(a3),d0
	bsr	read_mem
	bclr.l	d1,d0				* (HL)の nビット目をセット
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem		
	bra	main


case2:
	bclr.l	#6,d0
	beq	rot_sft			* ローテート、シフト関係の命令

*	------ ＢＩＴ ------
BIT:	move.w	d1,d0
	andi.w	#%0011_1000,d0			* BIT_n_? の n を d0にロード
	lsr.w	#3,d0

	andi.w	#%0000_0000_0000_0111,d1
	addq.w	#2,d1
	bclr.l	#3,d1
	bne	BIT_aorhl			* BIT A, BIT (HL)の時

	andi.w	#%11110101_00000000,d6	* N, HC modeを０に。 ＳＺを０に
	clr.b	d5			* HC を１に
	move.b	#1,HC2(a3)
	btst.b	d0,a(a3,d1.w)		* レジスタの nビット目をテスト
	beq	main
	move.b	#1,d6
	bra	main

BIT_aorhl:
	tst.w	d1
	beq	BIT_lHLl
	andi.w	#%11110101_00000000,d6	* N, HC modeを０に。 ＳＺを０に
	clr.b	d5			* HC を１に
	move.b	#1,HC2(a3)
	btst.l	d0,d4			* レジスタの nビット目をテスト
	beq	main
	move.b	#1,d6
	bra	main
BIT_lHLl:
	andi.w	#%11110101_00000000,d6	* N, HC modeを０に。 ＳＺを０に
	clr.b	d5			* HC を１に
	move.b	#1,HC2(a3)
	move.w	d0,d1
	move.w	hl(a3),d0
	bsr	read_mem
	btst.l	d1,d0			* (HL)の nビット目をテスト
	beq	main
	move.b	#1,d6
	bra	main


*	------ ローテート,シフト ------
rot_sft:
	andi.w	#%0000_0000_0011_1111,d1	* 命令にジャンプ
	lsl.w	#1,d1
	move.w	Rot_Sft_JPT(pc,d1.w),d0
	jmp	Rot_Sft_JPT(pc,d0.w)

Rot_Sft_JPT:
	.dc.w	RLC_B-Rot_Sft_JPT	* $00
	.dc.w	RLC_C-Rot_Sft_JPT
	.dc.w	RLC_D-Rot_Sft_JPT
	.dc.w	RLC_E-Rot_Sft_JPT
	.dc.w	RLC_H-Rot_Sft_JPT
	.dc.w	RLC_L-Rot_Sft_JPT
	.dc.w	RLC_lHLl-Rot_Sft_JPT
	.dc.w	RLC_A-Rot_Sft_JPT
	.dc.w	RRC_B-Rot_Sft_JPT	* $08
	.dc.w	RRC_C-Rot_Sft_JPT
	.dc.w	RRC_D-Rot_Sft_JPT
	.dc.w	RRC_E-Rot_Sft_JPT
	.dc.w	RRC_H-Rot_Sft_JPT
	.dc.w	RRC_L-Rot_Sft_JPT
	.dc.w	RRC_lHLl-Rot_Sft_JPT
	.dc.w	RRC_A-Rot_Sft_JPT	* $0f

	.dc.w	RL_B-Rot_Sft_JPT	* $10
	.dc.w	RL_C-Rot_Sft_JPT
	.dc.w	RL_D-Rot_Sft_JPT
	.dc.w	RL_E-Rot_Sft_JPT
	.dc.w	RL_H-Rot_Sft_JPT
	.dc.w	RL_L-Rot_Sft_JPT
	.dc.w	RL_lHLl-Rot_Sft_JPT
	.dc.w	RL_A-Rot_Sft_JPT
	.dc.w	RR_B-Rot_Sft_JPT	* $18
	.dc.w	RR_C-Rot_Sft_JPT
	.dc.w	RR_D-Rot_Sft_JPT
	.dc.w	RR_E-Rot_Sft_JPT
	.dc.w	RR_H-Rot_Sft_JPT
	.dc.w	RR_L-Rot_Sft_JPT
	.dc.w	RR_lHLl-Rot_Sft_JPT
	.dc.w	RR_A-Rot_Sft_JPT	* $1f

	.dc.w	SLA_B-Rot_Sft_JPT	* $20
	.dc.w	SLA_C-Rot_Sft_JPT
	.dc.w	SLA_D-Rot_Sft_JPT
	.dc.w	SLA_E-Rot_Sft_JPT
	.dc.w	SLA_H-Rot_Sft_JPT
	.dc.w	SLA_L-Rot_Sft_JPT
	.dc.w	SLA_lHLl-Rot_Sft_JPT
	.dc.w	SLA_A-Rot_Sft_JPT
	.dc.w	SRA_B-Rot_Sft_JPT	* $28
	.dc.w	SRA_C-Rot_Sft_JPT
	.dc.w	SRA_D-Rot_Sft_JPT
	.dc.w	SRA_E-Rot_Sft_JPT
	.dc.w	SRA_H-Rot_Sft_JPT
	.dc.w	SRA_L-Rot_Sft_JPT
	.dc.w	SRA_lHLl-Rot_Sft_JPT
	.dc.w	SRA_A-Rot_Sft_JPT	* $2f

	.dc.w	SLA_B-Rot_Sft_JPT	* $30	SLL 未定義命令(Shift Left Logical?)
	.dc.w	SLA_C-Rot_Sft_JPT	*	SLA と全く同じらしい
	.dc.w	SLA_D-Rot_Sft_JPT
	.dc.w	SLA_E-Rot_Sft_JPT
	.dc.w	SLA_H-Rot_Sft_JPT
	.dc.w	SLA_L-Rot_Sft_JPT
	.dc.w	SLA_lHLl-Rot_Sft_JPT
	.dc.w	SLA_A-Rot_Sft_JPT
	.dc.w	SRL_B-Rot_Sft_JPT	* $38
	.dc.w	SRL_C-Rot_Sft_JPT
	.dc.w	SRL_D-Rot_Sft_JPT
	.dc.w	SRL_E-Rot_Sft_JPT
	.dc.w	SRL_H-Rot_Sft_JPT
	.dc.w	SRL_L-Rot_Sft_JPT
	.dc.w	SRL_lHLl-Rot_Sft_JPT
	.dc.w	SRL_A-Rot_Sft_JPT	* $3f

*	------ ＲＬＣ ------
RLC_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	rol.b	#1,d4
	bcc	NC_RLC_A
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_A:
	move.b	d4,d6			* ＳＺをセット
	move.b	d4,PV(a3)		* ＰＶをセット
	bra	main

RLC_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	b(a3),d0
	rol.b	#1,d0
	bcc	NC_RLC_B
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_B:
	move.b	d0,b(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RLC_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	c(a3),d0
	rol.b	#1,d0
	bcc	NC_RLC_C
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_C:
	move.b	d0,c(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RLC_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	d(a3),d0
	rol.b	#1,d0
	bcc	NC_RLC_D
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_D:
	move.b	d0,d(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RLC_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	e(a3),d0
	rol.b	#1,d0
	bcc	NC_RLC_E
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_E:
	move.b	d0,e(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RLC_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	h(a3),d0
	rol.b	#1,d0
	bcc	NC_RLC_H
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_H:
	move.b	d0,h(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RLC_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	l(a3),d0
	rol.b	#1,d0
	bcc	NC_RLC_L
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_L:
	move.b	d0,l(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RLC_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	rol.b	#1,d0
	bcc	NC_RLC_hl
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
NC_RLC_hl:
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main


*	------ ＲＲＣ ------
RRC_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	ror.b	#1,d4
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d4,d6			* ＳＺをセット
	move.b	d4,PV(a3)		* ＰＶをセット
	bra	main

RRC_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	b(a3),d0
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,b(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RRC_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	c(a3),d0
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,c(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RRC_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	d(a3),d0
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,d(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RRC_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	e(a3),d0
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,e(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RRC_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	h(a3),d0
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,h(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RRC_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	l(a3),d0
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,l(a3)
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RRC_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main


*	------ ＲＬ ------
RL_A:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_A			* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	lsl.b	#1,d4
	bcc	NC_RL_A
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RL_A:
	ori.w	#%00000000_00000001,d4	* 最下位ビットをセット
	move.b	d4,d6
	move.b	d4,PV(a3)
	bra	main

RL_B:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_B			* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	b(a3),d0
	lsl.b	#1,d0
	bcc	NC_RL_B
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RL_B:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,b(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RL_C:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_C			* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	c(a3),d0
	lsl.b	#1,d0
	bcc	NC_RL_C
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RL_C:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,c(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RL_D:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_D			* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	d(a3),d0
	lsl.b	#1,d0
	bcc	NC_RL_D
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RL_D:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,d(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RL_E:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_E			* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	e(a3),d0
	lsl.b	#1,d0
	bcc	NC_RL_E
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RL_E:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,e(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RL_H:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_H			* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	h(a3),d0
	lsl.b	#1,d0
	bcc	NC_RL_H
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RL_H:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,h(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RL_L:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_L			* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	l(a3),d0
	lsl.b	#1,d0
	bcc	NC_RL_L
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RL_L:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,l(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RL_lHLl:
	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_lHLl		* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	lsl.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	bra	main

*	------ ＲＲ ------
RR_A:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_A			* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	lsr.b	#1,d4
	bcc	NC_RR_A
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RR_A:
	ori.w	#%00000000_00000001,d4	* 最下位ビットをセット
	move.b	d4,d6
	move.b	d4,PV(a3)
	bra	main

RR_B:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_B			* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	b(a3),d0
	lsr.b	#1,d0
	bcc	NC_RR_B
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RR_B:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,b(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RR_C:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_C			* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	c(a3),d0
	lsr.b	#1,d0
	bcc	NC_RR_C
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RR_C:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,c(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RR_D:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_D			* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	d(a3),d0
	lsr.b	#1,d0
	bcc	NC_RR_D
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RR_D:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,d(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RR_E:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_E			* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	e(a3),d0
	lsr.b	#1,d0
	bcc	NC_RR_E
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RR_E:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,e(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RR_H:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_H			* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	h(a3),d0
	lsr.b	#1,d0
	bcc	NC_RR_H
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RR_H:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,h(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RR_L:	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_L			* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	l(a3),d0
	lsr.b	#1,d0
	bcc	NC_RR_L
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
NC_RR_L:
	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,l(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

RR_lHLl:
	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_lHLl		* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	bra	main


*	------ ＳＬＡ ------
SLA_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	lsl.b	#1,d4
	bcc	NC_SLA_A
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SLA_A:
	move.b	d4,d6
	move.b	d4,PV(a3)
	bra	main

SLA_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	b(a3),d0
	lsl.b	#1,d0
	bcc	NC_SLA_B
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SLA_B:
	move.b	d0,b(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SLA_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	c(a3),d0
	lsl.b	#1,d0
	bcc	NC_SLA_C
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SLA_C:
	move.b	d0,c(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SLA_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	d(a3),d0
	lsl.b	#1,d0
	bcc	NC_SLA_D
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SLA_D:
	move.b	d0,d(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SLA_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	e(a3),d0
	lsl.b	#1,d0
	bcc	NC_SLA_E
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SLA_E:
	move.b	d0,e(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SLA_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	h(a3),d0
	lsl.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,h(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SLA_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	l(a3),d0
	lsl.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,l(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SLA_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	lsl.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	bra	main


*	------ ＳＲＡ ------
SRA_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	asr.b	#1,d4
	bcc	NC_SRA_A
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SRA_A:
	move.b	d4,d6
	move.b	d4,PV(a3)
	bra	main

SRA_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	b(a3),d0
	asr.b	#1,d0
	bcc	NC_SRA_B
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SRA_B:
	move.b	d0,b(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRA_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	c(a3),d0
	asr.b	#1,d0
	bcc	NC_SRA_C
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SRA_C:
	move.b	d0,c(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRA_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	d(a3),d0
	asr.b	#1,d0
	bcc	NC_SRA_D
	ori.w	#%00000001_00000000,d6	* CY をセット
NC_SRA_D:
	move.b	d0,d(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRA_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	e(a3),d0
	asr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,e(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRA_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	h(a3),d0
	asr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,h(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRA_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	l(a3),d0
	asr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,l(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRA_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	asr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	bra	main


*	------ ＳＲＬ ------
SRL_A:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	lsr.b	#1,d4
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d4,d6
	move.b	d4,PV(a3)
	bra	main

SRL_B:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	b(a3),d0
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,b(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRL_C:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	c(a3),d0
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,c(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRL_D:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	d(a3),d0
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,d(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRL_E:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	e(a3),d0
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,e(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRL_H:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	h(a3),d0
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,h(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRL_L:	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.b	l(a3),d0
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* CY をセット
@@:	move.b	d0,l(a3)
	move.b	d0,d6
	move.b	d0,PV(a3)
	bra	main

SRL_lHLl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	hl(a3),d0
	bsr	read_mem
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	bra	main


*	------ ＲＬＤ,ＲＲＤ ------
RLD_lHLl:
	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア

	move.w	hl(a3),d0		* d0.w = |00|00| (HL) |
	bsr	read_mem
	andi.w	#%11111111_00000000,d0

	lsl.w	#4,d0			* d0.w = |00| (HL) |00|
	move.b	d4,d1
	andi.w 	#%00000000_00001111,d1
	or.b	d0,d1			* d1.w = |00| (HL) |Al|

	andi.b	#%11110000,d4
	move.w	d1,-(sp)
	add.b	(sp)+,d4		* d4.b = |Ah| (H|

	move.w	hl(a3),d0
	bsr	write_mem

	move.b	d4,d6			* SZ をセット
	move.b	d4,PV(a3)
	bra	main

RRD_lHLl:
	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア

	move.w	hl(a3),d0		* d0.w = |?????| (HL) |
	bsr	read_mem

	move.b	d4,-(sp)
	move.w	(sp)+,d1		* d1.w = |  A  |??????|
	move.b	d0,d1			* d1.w = |  A  | (HL) |

	lsr.w	#4,d1			* d1.w = |00|  A   |(H|
	andi.w 	#%00000000_00001111,d0	* d0.w = |000000000|L)| 
	andi.b	#%11110000,d4		* d4.b =       | Ah|00|
	or.b	d0,d4			* d4.b =       | Ah|L)|

	move.w	hl(a3),d0
	bsr	write_mem

	move.b	d4,d6			* SZ をセット
	move.b	d4,PV(a3)
	bra	main

********************************************************************
*
*	＄ＥＤライン命令
*
********************************************************************
ED:	clr.w	d0
	move.b	0(a4,d7.w),d0			* 第二オペコードを読み込む
	addq.w	#1,d7
	bclr.l	#14,d7
	beq	next_ed
	bsr	PC_page_CHG
next_ed:
	subi.w	#$40,d0
	bcs	other				* ＄３ｆ以下の時は特殊命令へ
	lsl.w	#1,d0
	move.w	ED_JPT(pc,d0.w),d1

	jmp	ED_JPT(pc,d1.w)

ED_JPT:
	.dc.w	IN_B_c-ED_JPT		* $40
	.dc.w	OUT_c_B-ED_JPT
	.dc.w	SBC_HL_BC-ED_JPT
	.dc.w	LD_lnnl_BC-ED_JPT
	.dc.w	NEG-ED_JPT
	.dc.w	RETN-ED_JPT
	.dc.w	IM_0-ED_JPT
	.dc.w	LD_I_A-ED_JPT
	.dc.w	IN_C_c-ED_JPT		* $48
	.dc.w	OUT_c_C-ED_JPT
	.dc.w	ADC_HL_BC-ED_JPT
	.dc.w	LD_BC_lnnl-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	RETI-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	LD_R_A-ED_JPT			* $4f

	.dc.w	IN_D_c-ED_JPT		* $50
	.dc.w	OUT_c_D-ED_JPT
	.dc.w	SBC_HL_DE-ED_JPT
	.dc.w	LD_lnnl_DE-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	IM_1-ED_JPT
	.dc.w	LD_A_I-ED_JPT
	.dc.w	IN_E_c-ED_JPT		* $58
	.dc.w	OUT_c_E-ED_JPT
	.dc.w	ADC_HL_DE-ED_JPT
	.dc.w	LD_DE_lnnl-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	IM_2-ED_JPT
	.dc.w	LD_R_A-ED_JPT		* $5f

	.dc.w	IN_H_c-ED_JPT		* $60
	.dc.w	OUT_c_H-ED_JPT
	.dc.w	SBC_HL_HL-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	RRD_lHLl-ED_JPT
	.dc.w	IN_L_c-ED_JPT		* $68
	.dc.w	OUT_c_L-ED_JPT
	.dc.w	ADC_HL_HL-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	RLD_lHLl-ED_JPT		* $6f

	.dc.w	IN_F_c-ED_JPT		* $70
	.dc.w	none_ED-ED_JPT
	.dc.w	SBC_HL_SP-ED_JPT
	.dc.w	LD_lnnl_SP-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	IN_A_c-ED_JPT		* $78
	.dc.w	OUT_c_A-ED_JPT
	.dc.w	ADC_HL_SP-ED_JPT
	.dc.w	LD_SP_lnnl-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $7f

	.dc.w	none_ED-ED_JPT		* $80
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $88
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $8f

	.dc.w	none_ED-ED_JPT		* $90
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $98
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $9f

	.dc.w	LDI-ED_JPT		* $a0
	.dc.w	CPI-ED_JPT
	.dc.w	INI-ED_JPT
	.dc.w	OUTI-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	LDD-ED_JPT		* $a8
	.dc.w	CPD-ED_JPT
	.dc.w	IND-ED_JPT
	.dc.w	OUTD-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $af

	.dc.w	LDIR-ED_JPT		* $b0
	.dc.w	CPIR-ED_JPT
	.dc.w	INIR-ED_JPT
	.dc.w	OTIR-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	LDDR-ED_JPT		* $b8
	.dc.w	CPDR-ED_JPT
	.dc.w	INDR-ED_JPT
	.dc.w	OTDR-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $bf

	.dc.w	none_ED-ED_JPT		* $c0
	.dc.w	MULB_A_B-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	MULW_HL_BC-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $c8
	.dc.w	MULB_A_C-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $cf

	.dc.w	none_ED-ED_JPT		* $d0
	.dc.w	MULB_A_D-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	MULW_HL_DE-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $d8
	.dc.w	MULB_A_E-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $df

	.dc.w	none_ED-ED_JPT		* $e0
	.dc.w	MULB_A_H-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	MULW_HL_HL-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $e8
	.dc.w	MULB_A_L-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $ef

	.dc.w	none_ED-ED_JPT		* $f0
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	MULW_HL_SP-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $f8
	.dc.w	MULB_A_A-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT
	.dc.w	none_ED-ED_JPT		* $ff

none_ED:					* おかしな命令を実行しました
	addq.l	#4,sp
	bra	end


other:					* ＭＳ用に拡張した命令
	add.w	#$20,d0
	bpl	CALL68

JP68:	add.w	#$20,d0
	move.b	d0,-(sp)
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* d0 = ルーチン番号
	addq.w	#1,d7
	bclr.l	#14,d7
	beq	next_jp68
	bsr	PC_page_CHG
next_jp68:
	lsl.w	#2,d1			* d0 = d0 * 4
	lea.l	MS_JPT,a0
	move.l	0(a0,d0.w),a0
	jsr	(a0)

	move.w	d0,d7			* d0.w に戻り先の番地が入っている
	bsr	PC_page_set
	bra	main

CALL68:	add.w	#$20,d0
	move.b	d0,-(sp)
	move.b	(sp)+,d0
	move.b	0(a4,d7.w),d0		* d0 = ルーチン番号
	addq.w	#1,d7
	bclr.l	#14,d7
	beq	next_call68
	bsr	PC_page_CHG
next_call68:
	lsl.w	#2,d0			* d0 = d0 * 4
	lea.l	MS_JPT,a0
	move.l	0(a0,d0.w),a0

	jsr	(a0)

	bra	main

*	------ ＩＭ ------
IM_0:	move.w	#0,interrupt_mode-base(a3)
	rts

IM_1:	move.w	#0,interrupt_mode-base(a3)
	rts

IM_2:	move.w	#0,interrupt_mode-base(a3)
	rts


***************************** フラグの動きが正しいかわからない *********************
*	------ ＡＤＣ ------
ADC_HL_BC:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	NC_adchlbc
	sub.w	#1,d0			* X ビットを１に
NC_adchlbc:
	move.w	hl(a3),d0
	move.w	bc(a3),d1
	addx.w	d1,d0

F_set_adchl:
	bcs	C_adchl
	bvc	NV_adchl_1
	clr.b	PV(a3)
NV_adchl_1:
	andi.w	#%11111100_11111111,d6	* Ｎ,Ｃ を０に
	bra	next_adchl

C_adchl:
	bvc	NV_adchl_2
	clr.b	PV(a3)
NV_adchl_2:
	andi.w	#%11111101_11111111,d6	* Ｎ を０に
	ori.w	#%00000001_11111111,d6	* Ｃ を１に

next_adchl:
	tst.w	d0
	bmi	minus_adchl
	beq	zero_adchl
	move.b	#1,d6			* プラス
	bra	main
zero_adchl:
	clr.b	d6			* ゼロ
	bra	main
minus_adchl:
	move.b	#-1,d6			* マイナス
	bra	main

ADC_HL_DE:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	NC_adchlde
	sub.w	#1,d0			* X ビットを１に
NC_adchlde:
	move.w	hl(a3),d0
	move.w	de(a3),d1
	addx.w	d1,d0
	bra	F_set_adchl

ADC_HL_HL:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	NC_adchlhl
	sub.w	#1,d0			* X ビットを１に
NC_adchlhl:
	move.w	hl(a3),d0
	addx.w	d0,d0
	bra	F_set_adchl

ADC_HL_SP:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	NC_adchlsp
	sub.w	#1,d0			* X ビットを１に
NC_adchlsp:
	move.w	hl(a3),d0
	move.w	sp_(a3),d1
	addx.w	d1,d0
	bra	F_set_adchl

*	------ ＳＢＣ ------
SBC_HL_BC:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	@f			* Cyが０のとき
	sub.w	#1,d0			* X ビットを１に
@@:	move.w	hl(a3),d0
	move.w	bc(a3),d1
	subx.w	d1,d0

F_set_sbchl:
	bcs	C_sbchl
	bvc	@f
	clr.b	PV(a3)
@@:	andi.w	#%11111110_11111111,d6	* Ｃ を０に
	ori.w	#%00000010_11111111,d6	* Ｎ を１に
	bra	next_sbchl

C_sbchl:
	bvc	@f
	clr.b	PV(a3)
@@:	ori.w	#%00000011_11111111,d6	* Ｎ,Ｃ を１に

next_sbchl:
	move.w	d0,hl(a3)
	bmi	minus_sbchl
	beq	zero_sbchl
	move.b	#1,d6			* プラス
	bra	main
zero_sbchl:
	clr.b	d6			* ゼロ
	bra	main
minus_sbchl:
	move.b	#-1,d6			* マイナス
	bra	main

SBC_HL_DE:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	@f
	sub.w	#1,d0			* X ビットを１に
@@:	move.w	hl(a3),d0
	move.w	de(a3),d1
	subx.w	d1,d0
	bra	F_set_sbchl

SBC_HL_HL:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	@f
	sub.w	#1,d0			* X ビットを１に
@@:	move.w	hl(a3),d0
	subx.w	d0,d0
	bra	F_set_sbchl

SBC_HL_SP:
	sub.w	d0,d0			* C,X ビットを０に
	move.b	#1,PV(a3)		* PV をクリア
	btst.l	#8,d6			* Cy を調べる
	beq	@f
	sub.w	#1,d0			* X ビットを１に
@@:	move.w	hl(a3),d0
	move.w	sp_(a3),d1
	subx.w	d1,d0
	bra	F_set_sbchl


*	------ ＬＤＩ ------
LDI:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	move.b	d5,HC2(a3)		* Ｈを０に
	move.w	#0,PV(a3)
	move.w	hl(a3),d0
	bsr	read_mem_16
	move.w	d0,d1
	move.w	de(a3),d0
	bsr	write_mem_16
	addq.w	#1,hl(a3)
	addq.w	#1,de(a3)
	subq.w	#1,bc(a3)
	bne	main
	move.b	#1,PV(a3)
	bra	main

******** もっと高速化したい。 read mem, write mem の展開等 ***********
LDIR:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	move.b	d5,HC2(a3)		* Ｈを０に
	move.w	#1,PV(a3)
loop_LDIR:
	move.w	hl(a3),d0
	bsr	read_mem
	move.w	d0,d1
	move.w	de(a3),d0
	bsr	write_mem

	addq.w	#1,hl(a3)
	addq.w	#1,de(a3)
	subq.w	#1,bc(a3)
	bne	loop_LDIR
	bra	main

LDD:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	move.b	d5,HC2(a3)		* Ｈを０に
	move.w	#0,PV(a3)
	move.w	hl(a3),d0
	bsr	read_mem
	move.w	d0,d1
	move.w	de(a3),d0
	bsr	write_mem
	subq.w	#1,hl(a3)
	subq.w	#1,de(a3)
	subq.w	#1,bc(a3)
	bne	main
	move.b	#1,PV(a3)
	bra	main

******** もっと高速化したい。 read mem, write mem の展開等 ***********
LDDR:	andi.w	#%11110101_11111111,d6	* Ｎ,HC modeをクリア
	move.b	d5,HC2(a3)		* Ｈを０に
	move.w	#1,PV(a3)
loop_LDDR:
	move.w	hl(a3),d0
	bsr	read_mem
	move.w	d0,d1
	move.w	de(a3),d0
	bsr	write_mem

	subq.w	#1,hl(a3)
	subq.w	#1,de(a3)
	subq.w	#1,bc(a3)
	bne	loop_LDDR
	bra	main


*	------ ＣＰＩ , ＣＰＤ ------
CPI:	andi.w	#%11110111_11111111,d6	* HC modeをクリア
	ori.w	#%00000010_00000000,d6	* Ｎ をセット
	clr.w	PV(a3)			* PV をセット		
	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	addq.w	#1,hl(a3)
	subq.w	#1,bc(a3)
	bne	@f
	move.w	#1,PV(a3)		* PV をクリア
@@:	move.b	d4,d6
	sub.b	d0,d6			* 比較 かつ 結果を SZ にセット
	bra	main

CPIR:	andi.w	#%11110111_11111111,d6	* HC modeをクリア
	ori.w	#%00000010_00000000,d6	* Ｎ をセット
	clr.w	PV(a3)		* PV をセット		
loop_CPIR:
	move.w	hl(a3),d0
	bsr	read_mem
	addq.w	#1,hl(a3)
	subq.w	#1,bc(a3)
	beq	@f
	move.b	d4,d6
	sub.b	d0,d6			* 比較 かつ 結果を SZ にセット
	bne	loop_CPIR
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	bra	main	
@@:	move.w	#1,PV(a3)		* PV をクリア
	move.b	d4,d6
	sub.b	d0,d6			* 比較 かつ 結果を SZ にセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	bra	main	

CPD:	andi.w	#%11110111_11111111,d6	* HC modeをクリア
	ori.w	#%00000010_00000000,d6	* Ｎ をセット
	clr.w	PV(a3)		* PV をセット		
	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subq.w	#1,hl(a3)
	subq.w	#1,bc(a3)
	bne	@f
	move.w	#1,PV(a3)		* PV をクリア
@@:	move.b	d4,d6
	sub.b	d0,d6			* 比較 かつ 結果を SZ にセット
	bra	main

CPDR:	andi.w	#%11110111_11111111,d6	* HC modeをクリア
	ori.w	#%00000010_00000000,d6	* Ｎ をセット
	clr.w	PV(a3)		* PV をセット		
loop_CPDR:
	move.w	hl(a3),d0
	bsr	read_mem
	subq.w	#1,hl(a3)
	subq.w	#1,bc(a3)
	beq	@f
	move.b	d4,d6
	sub.b	d0,d6			* 比較 かつ 結果を SZ にセット
	bne	loop_CPDR
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	bra	main	
@@:	move.w	#1,PV(a3)		* PV をクリア
	move.b	d4,d6
	sub.b	d0,d6			* 比較 かつ 結果を SZ にセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	bra	main	

*****************  フラグの動きが怪しい（たぶん大丈夫っぽいけど）***************
*	------ ＮＥＧ ------
NEG:	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ,HC modeをセット
	move.b	#1,PV(a3)		* PVをクリア
	eori.b	#$ff,d4
	addq.b	#1,d4
	bvs	V_NEG
	bcs	C_NEG_1
	andi.w	#%11111110_11111111,d6	* Ｃをクリア
C_NEG_1:
	move.b	d4,d6			* SZ を設定
	move.b	d4,d5
	clr.b	HC2(a3)			* HC mode を１にしたから
	bra	main
V_NEG:
	bcs	C_NEG_2
	andi.w	#%11111110_11111111,d6	* Ｃをクリア
C_NEG_2:
	clr.b	PV(a3)			* PVをセット
	move.b	d4,d6			* SZ を設定
	move.b	d4,d5
	clr.b	HC2(a3)			* HC mode を１にしたから
	bra	main

*	------ 掛け算命令 ------
MULB_A_A:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	mulu.w	d0,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	andi.w	#$ff00,d0
	beq	main
	ori.w	#%00000001_00000000,d6
	bra	main

MULB_A_B:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	move.b	b(a3),d1		* d1 <- B
	mulu.w	d1,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	andi.w	#$ff00,d0
	beq	main
	ori.w	#%00000001_00000000,d6
	bra	main

MULB_A_C:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	move.b	c(a3),d1		* d1 <- B
	mulu.w	d1,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	andi.w	#$ff00,d0
	beq	main
	ori.w	#%00000001_00000000,d6
	bra	main

MULB_A_D:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	move.b	d(a3),d1		* d1 <- B
	mulu.w	d1,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	andi.w	#$ff00,d0
	beq	main
	ori.w	#%00000001_00000000,d6
	bra	main

MULB_A_E:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	move.b	e(a3),d1		* d1 <- B
	mulu.w	d1,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	andi.w	#$ff00,d0
	beq	main
	ori.w	#%00000001_00000000,d6
	bra	main

MULB_A_H:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	move.b	h(a3),d1		* d1 <- B
	mulu.w	d1,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	andi.w	#$ff00,d0
	beq	main
	ori.w	#%00000001_00000000,d6
	bra	main

MULB_A_L:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	move.b	l(a3),d1		* d1 <- B
	mulu.w	d1,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	andi.w	#$ff00,d0
	beq	main
	ori.w	#%00000001_00000000,d6
	bra	main

MULW_HL_BC:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	move.w	hl(a3),d0		* d0 <- A
	mulu.w	bc(a3),d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	swap	d0
	move.w	d0,de(a3)		* 上位ワードを格納
	beq	main			* 上位ワードが０の時はそのまま
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	bra	main

MULW_HL_DE:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	move.w	hl(a3),d0		* d0 <- A
	mulu.w	de(a3),d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	swap	d0
	move.w	d0,de(a3)		* 上位ワードを格納
	beq	main			* 上位ワードが０の時はそのまま
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	bra	main

MULW_HL_HL:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	move.w	hl(a3),d0		* d0 <- A
	mulu.w	d0,d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	swap	d0
	move.w	d0,de(a3)		* 上位ワードを格納
	beq	main			* 上位ワードが０の時はそのまま
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	bra	main

MULW_HL_SP:
	andi.w	#%11111110_00000000,d6	* Ｃ,SZ をクリア
	move.b	#1,PV(a3)		* PV をクリア
	move.w	hl(a3),d0		* d0 <- A
	mulu.w	sp_(a3),d0
	beq	@f
	move.b	#1,d6			* S フラグは常にクリアされるため
@@:	move.w	d0,hl(a3)		* このようにしないとダメ
	swap	d0
	move.w	d0,de(a3)		* 上位ワードを格納
	beq	main			* 上位ワードが０の時はそのまま
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	bra	main


*	------ ＬＤ Ｒ ------
LD_A_R:	andi.w	#%11110101_11111111,d6	* HC mode, N をクリア
	move.b	#1,PV(a3)		* PV をクリア
	move.b	r(a3),d0		* ５倍して１を足す
	lsl.b	#2,d0
	add.b	r(A3),d0
	addq.b	#1,d0
	move.b	d0,r(a3)
	move.b	d0,d4
	move.b	d4,d6			* SZ をセット
	move.b	d5,HC2(a3)		* HC を０に
	btst.b	#7,interrupt_status	* IFF の設定
	bne	main			* DI 状態の時 P/V <- 0
	move.b	#0,PV(a3)		* PV をセット
	bra	main

LD_R_A:	move.b	d4,r(a3)
	bra	main


*	------ ＬＤ Ｉ ------
LD_A_I:	andi.w	#%11110101_11111111,d6	* HC mode, N をクリア
	move.b	#1,PV(a3)		* PV をクリア
	move.b	i(a3),d4
	move.b	d4,d6			* SZ をセット
	move.b	d5,HC2(a3)		* HC を０に
	btst.b	#7,interrupt_status	* IFF の設定
	bne	main			* DI 状態の時 P/V <- 0
	move.b	#0,PV(a3)		* PV をセット
	bra	main

LD_I_A:	move.b	d4,i(a3)
	bra	main

*	ちゃんとやってない
*	------ ＲＥＴＮ ------
RETN:	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,d7
	bsr	PC_page_set
	bra	main

*	------ ＲＥＴＩ ------
RETI:	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,d7
	bsr	PC_page_set
	bra	main

*************************************************************************
*
*	＄ＤＤ,＄ＦＤライン命令
*		（Ｉｎｄｅｘ関係）
*
*************************************************************************
DD:	clr.w	d0
	move.b	0(a4,d7.w),d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	lsl.w	#1,d0
	move.w	DD_FD_JPT(pc,d0.w),d0
	clr.l	d1
	jmp	DD_FD_JPT(pc,d0.w)

FD:	clr.w	d0
	move.b	0(a4,d7.w),d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	lsl.w	#1,d0
	move.w	DD_FD_JPT(pc,d0.w),d0
	moveq.l	#2,d1
	jmp	DD_FD_JPT(pc,d0.w)

DD_FD_JPT:
	.dc.w	none_DD_FD-DD_FD_JPT		* $00
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	LD_B_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $08
	.dc.w	ADD_Idx_BC-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	LD_C_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $0f

	.dc.w	none_DD_FD-DD_FD_JPT		* $10
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	LD_D_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $18
	.dc.w	ADD_Idx_DE-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	LD_E_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $1f

	.dc.w	none_DD_FD-DD_FD_JPT		* $20
	.dc.w	LD_Idx_nn-DD_FD_JPT
	.dc.w	LD_lnnl_Idx-DD_FD_JPT
	.dc.w	INC_Idx-DD_FD_JPT
	.dc.w	INC_IdxH-DD_FD_JPT
	.dc.w	DEC_IdxH-DD_FD_JPT
	.dc.w	LD_IdxH_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $28
	.dc.w	ADD_Idx_Idx-DD_FD_JPT
	.dc.w	LD_Idx_lnnl-DD_FD_JPT
	.dc.w	DEC_Idx-DD_FD_JPT
	.dc.w	INC_IdxL-DD_FD_JPT
	.dc.w	DEC_IdxL-DD_FD_JPT
	.dc.w	LD_IdxL_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $2f

	.dc.w	none_DD_FD-DD_FD_JPT		* $30
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	INC_lIdx_dl-DD_FD_JPT
	.dc.w	DEC_lIdx_dl-DD_FD_JPT
	.dc.w	LD_lIdx_dl_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $38
	.dc.w	ADD_Idx_SP-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	LD_A_n-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $3f

	.dc.w	LD_B_B-DD_FD_JPT		* $40
	.dc.w	LD_B_C-DD_FD_JPT
	.dc.w	LD_B_D-DD_FD_JPT
	.dc.w	LD_B_E-DD_FD_JPT
	.dc.w	LD_B_IdxH-DD_FD_JPT
	.dc.w	LD_B_IdxL-DD_FD_JPT
	.dc.w	LD_B_lIdx_dl-DD_FD_JPT
	.dc.w	LD_B_A-DD_FD_JPT
	.dc.w	LD_C_B-DD_FD_JPT		* $48
	.dc.w	LD_C_C-DD_FD_JPT
	.dc.w	LD_C_D-DD_FD_JPT
	.dc.w	LD_C_E-DD_FD_JPT
	.dc.w	LD_C_IdxH-DD_FD_JPT
	.dc.w	LD_C_IdxL-DD_FD_JPT
	.dc.w	LD_C_lIdx_dl-DD_FD_JPT
	.dc.w	LD_C_A-DD_FD_JPT		* $4f

	.dc.w	LD_D_B-DD_FD_JPT		* $50
	.dc.w	LD_D_C-DD_FD_JPT
	.dc.w	LD_D_D-DD_FD_JPT
	.dc.w	LD_D_E-DD_FD_JPT
	.dc.w	LD_D_IdxH-DD_FD_JPT
	.dc.w	LD_D_IdxL-DD_FD_JPT
	.dc.w	LD_D_lIdx_dl-DD_FD_JPT
	.dc.w	LD_D_A-DD_FD_JPT
	.dc.w	LD_E_B-DD_FD_JPT		* $58
	.dc.w	LD_E_C-DD_FD_JPT
	.dc.w	LD_E_D-DD_FD_JPT
	.dc.w	LD_E_E-DD_FD_JPT
	.dc.w	LD_E_IdxH-DD_FD_JPT
	.dc.w	LD_E_IdxL-DD_FD_JPT
	.dc.w	LD_E_lIdx_dl-DD_FD_JPT
	.dc.w	LD_E_A-DD_FD_JPT		* $5f

	.dc.w	LD_IdxH_B-DD_FD_JPT		* $60
	.dc.w	LD_IdxH_C-DD_FD_JPT
	.dc.w	LD_IdxH_D-DD_FD_JPT
	.dc.w	LD_IdxH_E-DD_FD_JPT
	.dc.w	LD_IdxH_IdxH-DD_FD_JPT
	.dc.w	LD_IdxH_IdxL-DD_FD_JPT
	.dc.w	LD_H_lIdx_dl-DD_FD_JPT
	.dc.w	LD_IdxH_A-DD_FD_JPT
	.dc.w	LD_IdxL_B-DD_FD_JPT		* $68
	.dc.w	LD_IdxL_C-DD_FD_JPT
	.dc.w	LD_IdxL_D-DD_FD_JPT
	.dc.w	LD_IdxL_E-DD_FD_JPT
	.dc.w	LD_IdxL_IdxH-DD_FD_JPT
	.dc.w	LD_IdxL_IdxL-DD_FD_JPT
	.dc.w	LD_L_lIdx_dl-DD_FD_JPT
	.dc.w	LD_IdxL_A-DD_FD_JPT		* $6f

	.dc.w	LD_lIdx_dl_B-DD_FD_JPT	* $70
	.dc.w	LD_lIdx_dl_C-DD_FD_JPT
	.dc.w	LD_lIdx_dl_D-DD_FD_JPT
	.dc.w	LD_lIdx_dl_E-DD_FD_JPT
	.dc.w	LD_lIdx_dl_H-DD_FD_JPT
	.dc.w	LD_lIdx_dl_L-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	LD_lIdx_dl_A-DD_FD_JPT
	.dc.w	LD_A_B-DD_FD_JPT		* $78
	.dc.w	LD_A_C-DD_FD_JPT
	.dc.w	LD_A_D-DD_FD_JPT
	.dc.w	LD_A_E-DD_FD_JPT
	.dc.w	LD_A_IdxH-DD_FD_JPT
	.dc.w	LD_A_IdxL-DD_FD_JPT
	.dc.w	LD_A_lIdx_dl-DD_FD_JPT
	.dc.w	LD_A_A-DD_FD_JPT		* $7f

	.dc.w	none_DD_FD-DD_FD_JPT		* $80
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	ADD_A_IdxH-DD_FD_JPT
	.dc.w	ADD_A_IdxL-DD_FD_JPT
	.dc.w	ADD_A_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $88
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	ADC_A_IdxH-DD_FD_JPT
	.dc.w	ADC_A_IdxL-DD_FD_JPT
	.dc.w	ADC_A_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $8f

	.dc.w	none_DD_FD-DD_FD_JPT		* $90
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	SUB_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $98
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	SBC_A_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $9f

	.dc.w	none_DD_FD-DD_FD_JPT		* $a0
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	AND_IdxH-DD_FD_JPT
	.dc.w	AND_IdxL-DD_FD_JPT
	.dc.w	AND_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $a8
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	XOR_IdxH-DD_FD_JPT
	.dc.w	XOR_IdxL-DD_FD_JPT
	.dc.w	XOR_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $af

	.dc.w	none_DD_FD-DD_FD_JPT		* $b0
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	OR_IdxH-DD_FD_JPT
	.dc.w	OR_IdxL-DD_FD_JPT
	.dc.w	OR_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $b8
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	CP_IdxH-DD_FD_JPT
	.dc.w	CP_IdxL-DD_FD_JPT
	.dc.w	CP_lIdx_dl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $bf

	.dc.w	none_DD_FD-DD_FD_JPT		* $c0
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $c8
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	DD_FD_CB-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $cf

	.dc.w	none_DD_FD-DD_FD_JPT		* $d0
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $d8
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	DD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $df

	.dc.w	none_DD_FD-DD_FD_JPT		* $e0
	.dc.w	POP_Idx-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	EX_lSPl_Idx-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	PUSH_Idx-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $e8
	.dc.w	JP_lIdxl-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $ef

	.dc.w	none_DD_FD-DD_FD_JPT		* $f0
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT		* $f8
	.dc.w	LD_SP_Idx-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	FD-DD_FD_JPT
	.dc.w	none_DD_FD-DD_FD_JPT
	.dc.w	system_end-DD_FD_JPT		* $ff

none_DD_FD:					* おかしな命令を実行しました
	bra	end

LD_A_IdxH:
	move.b	ix_h(a3,d1.w),d4
	bra	main
LD_A_IdxL:
	move.b	ix_l(a3,d1.w),d4
	bra	main
LD_B_IdxH:
	move.b	ix_h(a3,d1.w),b(a3)
	bra	main
LD_B_IdxL:
	move.b	ix_l(a3,d1.w),b(a3)
	bra	main
LD_C_IdxH:
	move.b	ix_h(a3,d1.w),c(a3)
	bra	main
LD_C_IdxL:
	move.b	ix_l(a3,d1.w),c(a3)
	bra	main
LD_D_IdxH:
	move.b	ix_h(a3,d1.w),d(a3)
	bra	main
LD_D_IdxL:
	move.b	ix_l(a3,d1.w),d(a3)
	bra	main
LD_E_IdxH:
	move.b	ix_h(a3,d1.w),e(a3)
	bra	main
LD_E_IdxL:
	move.b	ix_l(a3,d1.w),e(a3)
	bra	main


LD_IdxH_A:
	move.b	d4,ix_h(a3,d1.w)
	bra	main
LD_IdxL_A:
	move.b	d4,ix_l(a3,d1.w)
	bra	main
LD_IdxH_B:
	move.b	b(a3),ix_h(a3,d1.w)
	bra	main
LD_IdxL_B:
	move.b	b(a3),ix_l(a3,d1.w)
	bra	main
LD_IdxH_C:
	move.b	c(a3),ix_h(a3,d1.w)
	bra	main
LD_IdxL_C:
	move.b	c(a3),ix_l(a3,d1.w)
	bra	main
LD_IdxH_D:
	move.b	d(a3),ix_h(a3,d1.w)
	bra	main
LD_IdxL_D:
	move.b	d(a3),ix_l(a3,d1.w)
	bra	main
LD_IdxH_E:
	move.b	e(a3),ix_h(a3,d1.w)
	bra	main
LD_IdxL_E:
	move.b	e(a3),ix_l(a3,d1.w)
	bra	main
LD_IdxH_IdxH:
	bra	main
LD_IdxL_IdxH:
	move.b	ix_h(a3,d1.w),ix_l(a3,d1.w)
	bra	main
LD_IdxH_IdxL:
	move.b	ix_l(a3,d1.w),ix_h(a3,d1.w)
	bra	main
LD_IdxL_IdxL:
	bra	main
LD_IdxH_n:
	move.b	0(a4,d7.w),ix_h(a3,d1.w)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main
LD_IdxL_n:
	move.b	0(a4,d7.w),ix_l(a3,d1.w)
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	main
	bsr	PC_page_CHG
	bra	main

ADD_A_IdxH:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	ix_h(a3,d1.w),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADD_A_IdxL:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	ix_l(a3,d1.w),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

ADC_A_IdxH:
	btst.l	#8,d6
	beq	ADD_A_IdxH		* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	ix_h(a3,d1.w),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main
ADC_A_IdxL:
	btst.l	#8,d6
	beq	ADD_A_IdxL		* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* ＮＣをクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	ix_l(a3,d1.w),d0
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADC_A			* オーバーフロー？
	bcc	NC_ADC_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

SUB_IdxH:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	ix_h(a3,d1.w),HC2(a3)	* 引く数を HC2に
	sub.b	ix_h(a3,d1.w),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main
SUB_IdxL:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	ix_l(a3,d1.w),HC2(a3)	* 引く数を HC2に
	sub.b	ix_l(a3,d1.w),d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SBC_A_IdxH:
	btst.l	#8,d6
	beq	SUB_IdxH		* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	ix_h(a3,d1.w),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main
SBC_A_IdxL:
	btst.l	#8,d6
	beq	SUB_IdxL		* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	clr.w	d0			* X ビットをセット
	subq.w	#1,d0
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	ix_l(a3,d1.w),d0
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main

AND_IdxH:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	ix_h(a3,d1.w),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	
AND_IdxL:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	and.b	ix_l(a3,d1.w),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_IdxH:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	ix_h(a3,d1.w),d0	* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	
XOR_IdxL:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.b	ix_l(a3,d1.w),d0	* eor <ea>,Dn という命令はないので。
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_IdxH:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	ix_h(a3,d1.w),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	
OR_IdxL:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	or.b	ix_l(a3,d1.w),d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

CP_IdxH:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	ix_h(a3,d1.w),HC2(a3)	* 引く数を HC2に
	move.b	d4,d2
	sub.b	ix_h(a3,d1.w),d2
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main
CP_IdxL:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	ix_l(a3,d1.w),HC2(a3)	* 引く数を HC2に
	move.b	d4,d2
	sub.b	ix_l(a3,d1.w),d2
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d1,d6
	bra	main

INC_IdxH:
	andi.w	#%11110101_11111111,d4	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	ix_h(a3,d1.w),d0
	addq.b	#1,d0
	bVS	@f
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,ix_h(a3,d1.w)
	move.b	#1,HC2(a3)
	bra	main
INC_IdxL:
	andi.w	#%11110101_11111111,d4	* Ｎ,HC modeをクリア
	clr.b	PV(a3)		* PVをセット	
	move.b	ix_l(a3,d1.w),d0
	addq.b	#1,d0
	bVS	@f
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,ix_l(a3,d1.w)
	move.b	#1,HC2(a3)
	bra	main

DEC_IdxH:
	ori.w	#%00001010_00000000,d4	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	ix_h(a3,d1.w),d0
	subq.b	#1,d0
	bVS	@f
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,ix_h(a3,d1.w)
	clr.b	HC2(a3)
	bra	main
DEC_IdxL:
	ori.w	#%00001010_00000000,d4	* Ｎ,HC modeをセット
	clr.b	PV(a3)		* PVをセット	
	move.b	ix_l(a3,d1.w),d0
	subq.b	#1,d0
	bVS	@f
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,ix_l(a3,d1.w)
	clr.b	HC2(a3)
	bra	main



ADD_A_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	move.b	d0,HC2(a3)		* 足す数を HC2に
	add.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	move.b	d4,d5
	bra	main

ADC_A_lIdx_dl:
	btst.l	#8,d6
	beq	ADD_A_lIdx_dl		* Cy が０の時 ADD と同じ
	andi.w	#%11111100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	ori.w	#%00001000_11111111,d6	* HC モードをセット
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	clr.b	d6			* X ビットをセット
	subq.b	#1,d6
	move.b	d0,HC2(a3)		* 足す数を HC2に
	addx.b	d0,d4
	bvs	V_ADD_A			* オーバーフロー？
	bcc	NC_ADD_A1
	ori.w	#%00000001_00000000,d6	* Ｃをセット
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット		
	move.b	d4,d5			* 結果を HC1にセット
	bra	main

SUB_lIdx_dl:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	sub.b	d0,d4
	bvs	V_SUB_A			* オーバーフロー？
	bcs	C_SUB_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

SBC_A_lIdx_dl:
	btst.l	#8,d6
	beq	SUB_lHLl		* Cy が０の時 SUB と同じ
	ori.w	#%00001011_00000000,d6	* Ｎ,Ｃ, HC mode をセット
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	clr.b	d6			* X ビットをセット
	subq.b	#1,d6
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	subx.b	d0,d4
	bvs	V_SBC_A			* オーバーフロー？
	bcc	NC_SBC_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6			* 結果を SZ にセット
	bra	main

AND_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	clr.b	d5			* HC を 1に
	move.b	#1,HC2(a3)
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	and.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

XOR_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	eor.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

OR_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC を 0に。( HC1 = HC2 の時, HCは０)
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	or.b	d0,d4
	move.b	d4,PV(a3)		* PV をセット
	move.b	d4,d6			* SZ をセット
	bra	main	

CP_lIdx_dl:
	andi.w	#%11110110_11111111,d6	* Ｃ,HC mode をクリア
	ori.w	#%00000010_00000000,d6	* Ｎをセット
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem
	move.b	d4,d5			* 引かれる数を HC1に
	move.b	d0,HC2(a3)		* 引く数を HC2に
	move.b	d4,d1
	sub.b	d0,d1
	bvs	V_CP_A			* オーバーフロー？
	bcs	C_CP_A1
	move.b	#1,PV(a3)		* PVをクリア
	move.b	d4,d6
	bra	main

INC_lIdx_dl:
	andi.w	#%11110101_11111111,d4	* Ｎ,HC modeをクリア
	clr.b	PV(a3)			* PVをセット	
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.w	d0,-(sp)
	bsr	read_mem
	addq.b	#1,d0
	bVS	@f			* オーバーフロー？
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,l(a3)
	move.b	#1,HC2(a3)
	bra	main

DEC_lIdx_dl:
	andi.w	#%11110101_11111111,d4	* Ｎ,HC modeをクリア
	clr.b	PV(a3)			* PVをセット	
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.w	d0,-(sp)
	bsr	read_mem
	subq.b	#1,d0
	bVS	@f			* オーバーフロー？
	move.b	#1,PV(a3)		* PVをクリア
@@:	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	move.b	d0,d6
	move.b	d0,d5
	move.b	d0,l(a3)
	move.b	#1,HC2(a3)
	bra	main


ADD_Idx_BC:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	bc(a3),d0
	add.w	d0,ix(a3,d1.w)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main

ADD_Idx_DE:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	de(a3),d0
	add.w	d0,ix(a3,d1.w)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main

ADD_Idx_SP:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	sp_(a3),d0
	add.w	d0,ix(a3,d1.w)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main

ADD_Idx_Idx:
	andi.w	#%11111100_11111111,d6	* ＣｙとＮをクリア
	move.w	ix(a3,d1.w),d0
	add.w	d0,ix(a3,d1.w)
	bcc	main
	ori.w	#%00000001_11111111,d6	* Ｃｙをセット
	bra	main


*	------ ＬＤ Ｉｄｘ ------
LD_Idx_nn:
	move.b	0(a4,d7.w),ix_l(a3,d1.w)	* nn の下位８ビットを読む 
	move.b	1(a4,d7.w),ix_h(a3,d1.w)	* nn の上位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	beq	main
	move.w	d7,d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bra	main
@@:	bsr	PC_page_CHG		* d7 = 1 の時
	move.b	(a4),ix_h(a3,d1.w)	* nn の上位８ビットを読む
	bra	main

LD_Idx_lnnl:
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	bsr	read_mem_16
	move.w	d0,ix(a3,d1.w)
	bra	main
@@:	tst.w	d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	read_mem_16
	move.w	d0,ix(a3,d1.w)
	bra	main
@@:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	read_mem_16
	move.w	d0,ix(a3,d1.w)
	bra	main

LD_lnnl_Idx:
	move.w	ix(a3,d1.w),d1
	move.b	1(a4,d7.w),-(sp)	* nn の上位８ビットを読む 
	move.w	(sp)+,d0
	move.b	0(a4,d7.w),d0		* nn の下位８ビットを読む 
	addq.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	bsr	write_mem_16
	bra	main
@@:	tst.w	d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	write_mem_16
	bra	main
@@:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	write_mem_16
	bra	main

LD_SP_Idx:
	move.w	ix(a3,d1.w),sp_(a3)
	bra	main


*	------ ＩＮＣ ------
INC_Idx:				* フラグは不変
	addq.w	#1,ix(a3,d1.w)
	bra	main
DEC_Idx:
	subq.w	#1,ix(a3,d1.w)
	bra	main

*	------ ＬＤ ？,（Ｉｄｘ＋ｄ） ------
LD_A_lIdx_dl:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	bra	main

LD_B_lIdx_dl:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,b(a3)
	bra	main

LD_C_lIdx_dl:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,c(a3)
	bra	main

LD_D_lIdx_dl:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d(a3)
	bra	main

LD_E_lIdx_dl:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,e(a3)
	bra	main

LD_H_lIdx_dl:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,h(a3)
	bra	main

LD_L_lIdx_dl:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	read_mem		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,l(a3)
	bra	main


*	------ ＬＤ （Ｉｄｘ＋ｄ）,？ ------
LD_lIdx_dl_A:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	d4,d1
	bsr	write_mem
	bra	main

LD_lIdx_dl_B:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	b(a3),d1
	bsr	write_mem
	bra	main

LD_lIdx_dl_C:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	c(a3),d1
	bsr	write_mem
	bra	main

LD_lIdx_dl_D:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	d(a3),d1
	bsr	write_mem
	bra	main

LD_lIdx_dl_E:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	e(a3),d1
	bsr	write_mem
	bra	main

LD_lIdx_dl_H:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	h(a3),d1
	bsr	write_mem
	bra	main

LD_lIdx_dl_L:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	add.w	#1,d7
	bclr.l	#14,d7
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	l(a3),d1
	bsr	write_mem
	bra	main

LD_lIdx_dl_n:
	move.w	ix(a3,d1.w),d0
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0
	move.b	1(a4,d7.w),d1		* n を読む
	add.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	bsr	write_mem
	bra	main
@@:	tst.w	d7			* 命令がページ境界をまたぐ時
	bne	@f
	bsr	PC_page_CHG		* d7 = 0 の時
	bsr	write_mem
	bra	main
@@:	move.b	d0,d2			* d7 = 1 の時
	bsr	PC_page_CHG
	move.b	(a4),-(sp)		* nn の上位８ビットを読む
	move.w	(sp)+,d0
	move.b	d2,d0
	bsr	write_mem
	bra	main


*	------ ＰＵＳＨ Ｉｄｘ
PUSH_Idx:
	subq.w	#2,sp_(a3)
	move.w	sp_(a3),d0
	move.w	ix(a3,d1.w),d1
	bsr	write_mem_16
	bra	main

POP_Idx:
	move.w	sp_(a3),d0
	bsr	read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,ix(a3,d1.w)
	bra	main


*	------ ＪＰ (Ｉｄｘ) ------
JP_lIdxl:
	move.w	ix(a3,d1.w),d7
	bsr	PC_page_set
	bra	main


*	------ ＥＸ ------
EX_lSPl_Idx:
	move.w	sp_(a3),d0
	bsr	read_mem_16
	move.w	ix(a3,d1.w),d2
	move.w	d0,ix(a3,d1.w)
	move.w	d2,d1
	move.w	sp_(a3),d0
	bsr	write_mem_16
	bra	main

*	------ Ｓｙｓｔｅｍ Ｅｎｄ ------
system_end:
	bra	end


**********************************************************************
*
*	ＤＤ，ＦＤ ＣＢライン命令
*
**********************************************************************
DD_FD_CB:
	move.b	0(a4,d7.w),d1		* d を加える
	ext.w	d1
	add.w	d1,d0			* d0 = Idx + d
	add.w	#2,d7
	bclr.l	#14,d7
	bne	@f
	move.b	-1(a4,d7.w),d2
	bra	1f
@@:	tst.b	d7			* 命令がページ境界をまたぐとき
	bne	@f
	move.b	-1(a4,d7.w),d2		* d7 = 0 のとき
	bsr	PC_page_CHG
	bra	1f
@@:	bsr	PC_page_CHG		* d7 = 1 のとき
	move.b	(a4),d2			* -1(a4,d7.w) = (a4)

1:	subq.b	#6,d2
	andi.w	#$fff8,d2
	lsr.w	#2,d2			* d2 = (第二オペランド - 6) / 8 * 2
	move.w	DD_FD_CB_JPT(pc,d2.w),d1
	jmp	DD_FD_CB_JPT(pc,d1.w)

DD_FD_CB_JPT:
	.dc.w	RLC_lIdx_dl-DD_FD_CB_JPT		* 06
	.dc.w	RRC_lIdx_dl-DD_FD_CB_JPT		* 0e
	.dc.w	RL_lIdx_dl-DD_FD_CB_JPT			* 16
	.dc.w	RR_lIdx_dl-DD_FD_CB_JPT			* 1e
	.dc.w	SLA_lIdx_dl-DD_FD_CB_JPT		* 26
	.dc.w	SRA_lIdx_dl-DD_FD_CB_JPT		* 2e
	.dc.w	SLA_lIdx_dl-DD_FD_CB_JPT		* 36 SLL
	.dc.w	SRL_lIdx_dl-DD_FD_CB_JPT		* 3e

	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 46
	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 4e
	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 56
	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 5e
	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 66
	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 6e
	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 76
	.dc.w	BIT_lIdx_dl-DD_FD_CB_JPT		* 7e

	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT		* 86
	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT
	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT
	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT
	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT
	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT
	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT
	.dc.w	RES_lIdx_dl-DD_FD_CB_JPT		* bf

	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT		* c6
	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT
	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT
	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT
	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT
	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT
	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT
	.dc.w	SET_lIdx_dl-DD_FD_CB_JPT		* fe

none_DD_FD_CB:					* おかしな命令を実行しました
	bra	end


SET_lIdx_dl:
	andi.w	#%00000000_00000111,d2		* BIT_n_? の n を d2にロード
	move.w	d0,-(sp)			* Idx + d をプッシュ
	bsr	read_mem
	bset.l	d2,d0				* (Idx + d)の nビット目をセット
	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem		
	bra	main

RES_lIdx_dl:
	andi.w	#%00000000_00000111,d2		* BIT_n_? の n を d2にロード
	move.w	d0,-(sp)			* Idx + d をプッシュ
	bsr	read_mem
	bclr.l	d2,d0				* (Idx + d)の nビット目をクリア
	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem		
	bra	main

BIT_lIdx_dl:
	andi.w	#%11110101_00000000,d6		* N, HC modeを０に。 ＳＺを０に
	clr.b	d5				* HC を１に
	move.b	#1,HC2(a3)
	andi.w	#%00000000_00000111,d2		* BIT_n_? の n を d2にロード
	bsr	read_mem
	btst.l	d2,d0				* (Idx + d)の nビット目をテスト
	beq	main
	move.b	#1,d6
	bra	main

RLC_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	d0,-(sp)		* Idx + d をプッシュ
	bsr	read_mem
	rol.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RRC_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ HC modeをクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	d0,-(sp)		* Idx + d をプッシュ
	bsr	read_mem
	ror.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* キャリーフラグをセット
@@:	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	move.b	d0,d6			* ＳＺをセット
	move.b	d0,PV(a3)		* ＰＶをセット
	bra	main

RL_lIdx_dl:
	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SLA_lIdx_dl		* CY が０の時 RLは SLAと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	d0,-(sp)		* Idx + d をプッシュ
	bsr	read_mem
	lsl.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	bra	main


RR_lIdx_dl:
	btst.l	#8,d6			* ＣＹの状態をチェック
	beq	SRL_lIdx_dl		* CY が０の時 RRは SRLと同じ動作をする
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	d0,-(sp)		* Idx + d をプッシュ
	bsr	read_mem
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	ori.w	#%00000000_00000001,d0	* 最下位ビットをセット
	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	bra	main

SLA_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	d0,-(sp)		* Idx + d をプッシュ
	bsr	read_mem
	lsl.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	bra	main

SRA_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	d0,-(sp)		* Idx + d をプッシュ
	bsr	read_mem
	asr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	bra	main

SRL_lIdx_dl:
	andi.w	#%11110100_11111111,d6	* Ｎ,Ｃ,HC mode をクリア
	move.b	d5,HC2(a3)		* HC をクリア
	move.w	d0,-(sp)		* Idx + d をプッシュ
	bsr	read_mem
	lsr.b	#1,d0
	bcc	@f
	ori.w	#%00000001_00000000,d6	* ＣＹをセット
@@:	move.b	d0,d6
	move.b	d0,PV(a3)
	move.b	d0,d1
	move.w	(sp)+,d0
	bsr	write_mem
	bra	main


*******************    ここまで   *******************************************

*****************************************************
*
*	８ビットメモリ読み込みサブルーチン
*
*	a0.l		ベースアドレス(68000)
*	d0.w		アドレス  (R800)	
* 返り値
*	d0.b	 	メモリから読み込んだ値を入れる
*
*	d0 以外破壊してはならない
*
*******************************************************
rd8_nothing:
	move.b	#$ff,d0
	rts

rd8_normal:
	move.b	0(a0,d0.w),d0
	rts

rd8_MEGA_ROM_8:			* まだやってない

rd8_MEGA_ROM_16:		* まだやってない

rd8_MEGA_ROM_SCC:		* まだやってない

rd8_MEGA_ROM_PANA:		* まだやってない

rd8_SOUND:

rd8_PAC:				* pac のレジスタは読み込み出来ない
	cmpi.w	#$4d69,PAC_reg_0	* $5ffe に 4d, $5fff に 69 が書き込まれている
	bne	rd8_nothing		* 時は Ｓ-ＲＡＭモード
	move.b	d1,0(a0,d0.w)
	rts


*****************************************************
*
*	８ビットメモリ書き込みルーチン
*
*	a0.l	ベースアドレス(68000)
*	d0.w	アドレス  (R800)	
*	d1.b	書き込む値
*
*******************************************************
wt8_nothing:

wt8_ROM:
	rts

wt8_RAM:
	move.b	d1,0(a0,d0.w)
	rts

wt8_MEGA_ROM_8:		* まだやってない

wt8_MEGA_ROM_16:		* まだやってない

wt8_MEGA_ROM_SCC:		* まだやってない

wt8_MEGA_ROM_PANA:		* まだやってない

wt8_SOUND:		* まだやってない

wt8_PAC:
	cmpi.w	#$1ffe,d0
	beq	set_reg_0
	cmpi.w	#$1fff,d0
	beq	set_reg_1
	cmpi.w	#$4d69,PAC_reg_0	* $5ffe に 4d, $5fff に 69 が書き込まれている
	bne	wt8_nothing		* 時は Ｓ-ＲＡＭモード
	move.b	d1,0(a0,d0.w)
	rts
set_reg_0:
	move.b	d1,PAC_reg_0
	rts
set_reg_1:
	move.b	d1,PAC_reg_1
	rts	

wt8_DOS_ROM:
	cmpi.w	#$3ff0,d0
	bne	wt8_nothing
					* ＤＯＳのページ切り替え（ローカルバンク）
		* まだやってない
	

*****************************************************
*
*	１６ビットメモリ読み込みサブルーチン
*
*	a0.l		ベースアドレス(68000)
*	d0.w		アドレス  (R800)	
* 返り値
*	d0.w	 	メモリから読み込んだ値を入れる
*
*	d0 以外破壊してはならない
*
*******************************************************
rd16_nothing:
	move.w	#$ff,d0
	rts

rd16_normal:
	move.b	1(a0,d0.w),-(sp)
	move.w	(sp)+,d0
	move.b	0(a0,d0.w),d0
	rts

rd16_MEGA_ROM_8:			* まだやってない

rd16_MEGA_ROM_16:		* まだやってない

rd16_MEGA_ROM_SCC:		* まだやってない

rd16_MEGA_ROM_PANA:		* まだやってない

rd16_SOUND:

rd16_PAC:				* pac のレジスタは読み込み出来ない
	cmpi.w	#$4d69,PAC_reg_0	* $5ffe に 4d, $5fff に 69 が書き込まれている
	bne	rd16_nothing		* 時は Ｓ-ＲＡＭモード
	move.b	1(a0,d0.w),-(sp)
	move.w	(sp)+,d0
	move.b	0(a0,d0.w),d0
	rts


*****************************************************
*
*	１６ビットメモリ書き込みルーチン
*
*	a0.l	ベースアドレス(68000)
*	d0.w	アドレス  (R800)	
*	d1.w	書き込む値
*
*******************************************************
wt16_nothing:

wt16_ROM:
	rts

wt16_RAM:
	move.b	d1,0(a0,d0.w)
	move.w	d1,-(sp)
	move.b	(sp)+,1(a0,d0.w)
	rts

wt16_MEGA_ROM_8:		* まだやってない

wt16_MEGA_ROM_16:		* まだやってない

wt16_MEGA_ROM_SCC:		* まだやってない

wt16_MEGA_ROM_PANA:		* まだやってない

wt16_SOUND:		* まだやってない

wt16_DOS_ROM:		* まだやってない

wt16_PAC:
	rts

*****************************************************
*
*		Ｉ/Ｏ関係のルーチン
*
*****************************************************

*	------ ＩＮ ------
IN_A_n:	move.b	0(a4,d7.w),d0		* n を読む
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	bsr	input
	move.b	d0,d4
	bra	main

IN_A_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d4
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

IN_B_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,b(a3)
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

IN_C_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,c(a3)
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

IN_D_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d(a3)
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

IN_E_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,e(a3)
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

IN_H_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,h(a3)
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

IN_L_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,l(a3)
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

IN_F_c:	andi.w	#%11111101_11111111,d6	* N をクリア
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d6			* SZ をセット
	move.b	d0,PV(a3)		* PV をセット
	bra	main

*	------ ＩＮＩ ------
INI:	ori.w	#%00000010_00000000,d6	* Nをセット
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	addq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	move.b	b(a3),d6		* Z を設定
	bra	main

*	------ ＩＮＤ ------
IND:	ori.w	#%00000010_00000000,d6	* Nをセット
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	subq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	move.b	b(a3),d6		* Z を設定
	bra	main

*	------ ＩＮＩＲ ------
INIR:	ori.w	#%00000010_00000000,d6	* Nをセット
@@:	move.b	c(a3),d0
	bsr	input
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	addq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@b
	clr.b	d6			* Z をセット
	bra	main

*	------ ＩＮＤＲ ------
INDR:	ori.w	#%00000010_00000000,d6	* Nをセット
@@:	move.b	c(a3),d0
	bsr	input
	move.b	d0,d1
	move.w	hl(a3),d0
	bsr	write_mem
	subq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@b
	clr.b	d6			* Z をセット
	bra	main


	
*	------ ＯＵＴ ------
OUT_n_A:
	move.b	0(a4,d7.w),d0		* n を読む
	addq.w	#1,d7			* PC += 1
	bclr.l	#14,d7			* PC がページ境界をまたいだか？
	beq	@f
	bsr	PC_page_CHG
@@:	move.b	d4,d1
	bsr	output
	bra	main

OUT_c_A:
	move.b	c(a3),d0
	move.b	d4,d1
	bsr	output
	bra	main

OUT_c_B:
	move.b	c(a3),d0
	move.b	b(a3),d1
	bsr	output
	bra	main

OUT_c_C:
	move.b	c(a3),d0
	move.b	d0,d1
	bsr	output
	bra	main

OUT_c_D:
	move.b	c(a3),d0
	move.b	c(a3),d1
	bsr	output
	bra	main

OUT_c_E:
	move.b	c(a3),d0
	move.b	e(a3),d1
	bsr	output
	bra	main

OUT_c_H:
	move.b	c(a3),d0
	move.b	h(a3),d1
	bsr	output
	bra	main

OUT_c_L:
	move.b	c(a3),d0
	move.b	l(a3),d1
	bsr	output
	bra	main

*	------ ＯＵＴＩ ------
OUTI:	ori.w	#%00000010_00000000,d6	* Nをセット
	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d0,d1			* 書き込む値
	move.b	c(a3),d0		* 書き込むポート
	bsr	output
	addq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	move.b	b(a3),d6		* Z を設定
	bra	main

*	------ ＯＵＴＤ ------
OUTD:	ori.w	#%00000010_00000000,d6	* Nをセット
	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d0,d1			* 書き込む値
	move.b	c(a3),d0		* 書き込むポート
	bsr	output
	subq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	move.b	b(a3),d6		* Z を設定
	bra	main

*	------ ＯＴＩＲ ------
OTIR:	ori.w	#%00000010_00000000,d6	* Nをセット
@@:	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d0,d1			* 書き込む値
	move.b	c(a3),d0		* 書き込むポート
	bsr	output
	addq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@b
	clr.b	d6			* Z をセット
	bra	main

*	------ ＯＴＤＲ ------
OTDR:	ori.w	#%00000010_00000000,d6	* Nをセット
@@:	move.w	hl(a3),d0
	bsr	read_mem
	move.b	d0,d1			* 書き込む値
	move.b	c(a3),d0		* 書き込むポート
	bsr	output
	subq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@b
	clr.b	d6			* Z をセット
	bra	main


*****************************************************************
*
*	ポートからの読み込み
*
*  (引数)
*	.d0.b	ポート番号
*  (帰り値)
*	.d0.b	読み込んだ値
*
*	d1 破壊
*
*****************************************************************	
input:
	clr.w	d1
	move.b	d0,d1
	move.b	I_O_table(pc,d1.w),d1
	lsl.w	#2,d1				* d1 = d1 *4
	movea.l	input_table(pc,d1.w),a0
	jmp	(a0)				* rts を省略するためジャンプにしてある

no_port_IN:
	move.b	#$ff,d0
	rts


input_table:
	.dc.l	no_port_IN
	.dc.l	rd_VDP_0
	.dc.l	rd_VDP_1
	.dc.l	rd_VDP_2
	.dc.l	rd_VDP_3


*****************************************************************
*
*	ポートへの書き込み
*
*  (引数)
*	.d0.b	ポート番号
*	.d1.b	書き込む値
*
*	d1,d2,d3 破壊
*
*****************************************************************	
output:
	clr.w	d2
	move.b	d0,d2
	move.b	I_O_table(pc,d2.w),d2
	lsl.w	#2,d2				* d2 = d2 *4
	movea.l	output_table(pc,d2.w),a0
	jmp	(a0)				* rts を省略するためジャンプにしてある

no_port_OUT:
	rts


output_table:
	.dc.l	no_port_OUT
	.dc.l	wt_VDP_0
	.dc.l	wt_VDP_1
	.dc.l	wt_VDP_2
	.dc.l	wt_VDP_3


		
I_O_table:
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 0
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 1
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 2
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 3
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 4
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 5
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 6
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 7
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 8
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* 9
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* a
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* b
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* c
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* d
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* e
	.dc.b	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	* f


*************** ワークエリア ******************

	.data

PC_page:
	.dc.w	0	* 現在ＰＣが存在するページ

base:			* a3 の指すアドレス
registers:
	.dc.b	0	* a
	.dc.b	0	* f
	.dc.b	0	* b
	.dc.b	0	* c
	.dc.b	0	* d
	.dc.b	0	* e
	.dc.b	0	* h
	.dc.b	0	* l

	.dc.b	0	* ix_h
	.dc.b	0	* ix_l
	.dc.b	0	* iy_h
	.dc.b	0	* iy_l

	.dc.b	0	* s
	.dc.b	0	* p

pair_registers:		* 裏レジスタの保存場所
	.dc.b	0	* a'
	.dc.b	0	* f'
	.dc.b	0	* b'
	.dc.b	0	* c'
	.dc.b	0	* d'
	.dc.b	0	* e'
	.dc.b	0	* h'
	.dc.b	0	* l'


r_:	.dc.b	0	* Ｒレジスタ
i_:	.dc.b	0	* Ｉレジスタ

			* HC1はレジスタ d5 にある
HC2_:			* ＨＣフラグは、HC1 ≧ HC2 + HC mode (d6のビット11)なら０ 
			* HC1 ＜ HC2 なら１とする。
	.dc.b	0	* ただし、HC1 HC2 は下位４ビットのみ有効。不等式は8ビットで演算

PV_:			* ＰＶフラグはＰＶの値のうち１であるビットが偶数個
	.dc.b	0	* なら１、奇数なら０とする。

*	ＡＦ’用のフラグ保存場所
HC1_d_:
	.dc.b	0
HC2_d_:
	.dc.b	0
PV_d_:
	.dc.b	0
SZ_d_:
	.dc.b	0

	.even

*	割り込み状態の設定	
interrupt_status:
	.dc.b	0		* 00000000
				* |      +-- 0 割り込み無し
				* |      +-- 1 割り込みあり
				* |
				* +--------- 0 ＥＩ
				* +--------- 1 ＤＩ
	.even

interrupt_mode
	.dc.w	0		* インタラプトモード 0, 1, 2
special:
	.dc.w	0		* ０・・の時何もなし
				* １・・ＥＩをかける
				* ２・・ＥＩがかかった
				* ３・・割り込みがかかった

*	スロットに関する情報
slot_0_ex:			* slot 0 は拡張されているか？ 0・・No  1・・Yes
	.dc.w	0
slot_1_ex:
	.dc.w	0
slot_2_ex:
	.dc.w	0
slot_3_ex:
	.dc.w	0

exslot_reg_0:			* slot 0 の拡張スロット選択レジスタ
	.dc.b	0
exslot_reg_1:
	.dc.b	0
exslot_reg_2:
	.dc.b	0
exslot_reg_3:
	.dc.b	0

slot_reg:
	.dc.b	0		* スロット選択レジスタ(I/O 0xA8)の値

	.even

page0:				* 現在 page 0 に選択されているページのアドレス
	.dc.l	0		* 通常は下の slot_x_x_pagex の値がそのままコピ
page1:				* ーされるがメモリマッパーやメガロムの時には、
	.dc.l	0		* 選択されているセグメントのアドレスが入る。
page2:
	.dc.l	0
page3:
	.dc.l	0


********************* まだちゃんとやってない（別紙参照） *********************
*		 読み込みルーチン
rd8_sub_add_0:			* ｎｏｔｈｉｎｇ		
	.dc.l	rd8_nothing
rd8_sub_add_1:			* マッパーＲＡＭ		
	.dc.l	rd8_normal
rd8_sub_add_2:			* ノーマルＲＯＭ
	.dc.l	rd8_normal
rd8_sub_add_3:			* メガＲＯＭ ( 8k)
	.dc.l	rd8_MEGA_ROM_8
rd8_sub_add_4:			* メガＲＯＭ (16k)
	.dc.l	rd8_MEGA_ROM_16
rd8_sub_add_5:			* コナミＳＣＣ付きメガロム
	.dc.l	rd8_MEGA_ROM_SCC
rd8_sub_add_6:			* コナミサウンドカートリッジ
	.dc.l	rd8_SOUND
rd8_sub_add_7:			* パナソニックメガロム ( A1-GT等の slot3-3)
	.dc.l	rd8_MEGA_ROM_PANA
rd8_sub_add_8:			* ＤＯＳ-ＲＯＭ (turbo R)
	.dc.l	rd8_normal
rd8_sub_add_9:			* ＰＡＣ
	.dc.l	rd8_PAC

rd8_sub_add_p0:			* 現在 page x に選択されているスロットから読み込みを
	.dc.l	0		* 行う際の読み込みルーチンのアドレス。
rd8_sub_add_p1:
	.dc.l	0
rd8_sub_add_p2:
	.dc.l	0
rd8_sub_add_p3:
	.dc.l	0

*		 書き込みルーチン
wt8_sub_add_0:			* ｎｏｔｈｉｎｇ		
	.dc.l	wt8_nothing
wt8_sub_add_1:			* マッパーＲＡＭ		
	.dc.l	wt8_RAM
wt8_sub_add_2:			* ノーマルＲＯＭ
	.dc.l	wt8_ROM
wt8_sub_add_3:			* メガＲＯＭ ( 8k)
	.dc.l	wt8_MEGA_ROM_8
wt8_sub_add_4:			* メガＲＯＭ (16k)
	.dc.l	wt8_MEGA_ROM_16
wt8_sub_add_5:			* コナミＳＣＣ付きメガロム
	.dc.l	wt8_MEGA_ROM_SCC
wt8_sub_add_6:			* コナミサウンドカートリッジ
	.dc.l	wt8_SOUND
wt8_sub_add_7:			* パナソニックメガロム ( A1-GT等の slot3-3)
	.dc.l	wt8_MEGA_ROM_PANA
wt8_sub_add_8:			* ＤＯＳ-ＲＯＭ (turbo R)
	.dc.l	wt8_DOS_ROM
wt8_sub_add_9:			* ＰＡＣ
	.dc.l	wt8_PAC

base2:

wt8_sub_add_p0:			* 現在 page x に選択されているスロットに書き込みを
	.dc.l	0		* 行う際の書き込みルーチンのアドレス。
wt8_sub_add_p1:
	.dc.l	0
wt8_sub_add_p2:
	.dc.l	0
wt8_sub_add_p3:
	.dc.l	0

*		 読み込みルーチン
rd16_sub_add_0:			* ｎｏｔｈｉｎｇ		
	.dc.l	rd16_nothing
rd16_sub_add_1:			* マッパーＲＡＭ		
	.dc.l	rd16_normal
rd16_sub_add_2:			* ノーマルＲＯＭ
	.dc.l	rd16_normal
rd16_sub_add_3:			* メガＲＯＭ ( 8k)
	.dc.l	rd16_MEGA_ROM_8
rd16_sub_add_4:			* メガＲＯＭ (16k)
	.dc.l	rd16_MEGA_ROM_16
rd16_sub_add_5:			* コナミＳＣＣ付きメガロム
	.dc.l	rd16_MEGA_ROM_SCC
rd16_sub_add_6:			* コナミサウンドカートリッジ
	.dc.l	rd16_SOUND
rd16_sub_add_7:			* パナソニックメガロム ( A1-GT等の slot3-3)
	.dc.l	rd16_MEGA_ROM_PANA
rd16_sub_add_8:			* ＤＯＳ-ＲＯＭ (turbo R)
	.dc.l	rd16_normal
rd16_sub_add_9:			* ＰＡＣ
	.dc.l	rd16_PAC


rd16_sub_add_p0:		* 現在 page x に選択されているスロットから読み込みを
	.dc.l	0		* 行う際の読み込みルーチンのアドレス。
rd16_sub_add_p1:
	.dc.l	0
rd16_sub_add_p2:
	.dc.l	0
rd16_sub_add_p3:
	.dc.l	0

*		 書き込みルーチン
wt16_sub_add_0:			* ｎｏｔｈｉｎｇ		
	.dc.l	wt16_nothing
wt16_sub_add_1:			* マッパーＲＡＭ		
	.dc.l	wt16_RAM
wt16_sub_add_2:			* ノーマルＲＯＭ
	.dc.l	wt16_ROM
wt16_sub_add_3:			* メガＲＯＭ ( 8k)
	.dc.l	wt16_MEGA_ROM_8
wt16_sub_add_4:			* メガＲＯＭ (16k)
	.dc.l	wt16_MEGA_ROM_16
wt16_sub_add_5:			* コナミＳＣＣ付きメガロム
	.dc.l	wt16_MEGA_ROM_SCC
wt16_sub_add_6:			* コナミサウンドカートリッジ
	.dc.l	wt16_SOUND
wt16_sub_add_7:			* パナソニックメガロム ( A1-GT等の slot3-3)
	.dc.l	wt16_MEGA_ROM_PANA
wt16_sub_add_8:			* ＤＯＳ-ＲＯＭ (turbo R)
	.dc.l	wt16_DOS_ROM
wt16_sub_add_9:			* ＰＡＣ
	.dc.l	wt16_PAC

wt16_sub_add_p0:			* 現在 page x に選択されているスロットに書き込みを
	.dc.l	0		* 行う際の書き込みルーチンのアドレス。
wt16_sub_add_p1:
	.dc.l	0
wt16_sub_add_p2:
	.dc.l	0
wt16_sub_add_p3:
	.dc.l	0

*	このアドレスはヘッダ等を含まない部分を指す。よって、ヘッダは
*	(アドレス) - 8 のアドレスから存在する。
slot_0_0:
	.dc.l	0		* slot 0-0 page0 が存在するアドレス
	.dc.l	0		* slot 0-0 page1 が存在するアドレス
	.dc.l	0		* slot 0-0 page2 が存在するアドレス
	.dc.l	0		* slot 0-0 page3 が存在するアドレス
slot_0_1:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_0_2:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_0_3:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0

slot_1_0:
	.dc.l	0		* slot 1-0 page0 が存在するアドレス
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_1_1:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_1_2:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_1_3:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0

slot_2_0:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_2_1:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_2_2:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_2_3:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0

slot_3_0:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_3_1:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_3_2:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0
slot_3_3:
	.dc.l	0
	.dc.l	0
	.dc.l	0
	.dc.l	0

*	ＰＡＣのバンクセレクトレジスタ
PAC_reg_0:			* PAC のバンク切り替え用レジスタ
	.dc.b	0		* $5ffE 番地に対応
PAC_reg_1:
	.dc.b	0		* $5fff 番地に対応

CPU_mode:
	.dc.w	0		* CPU の状態	０・・ＨＡＬＴ状態

	.end
