*
*	Ｍｓｘ Ｓｉｍｕｌａｔｅｒ
*
*		[[[ ＶＤＰ Ｓｉｍｕｌａｔｅｒ ]]]		
*
*				1995.9.24		by Kuni.
*

	.include	iocscall.mac
	.include	doscall.mac

	.xref	_write_sprite_pattern
	.xref	_write_sprite_attribute
	.xref	_write_sprite_color
	.xref	HEX

	.xref	cpu_emu_yield
	.xref	cpu_yield
	.xref	sub_yield
	.xref	emu_yield
	.xref	host_line

	.xref	emu_counter
	.xref	emu_counter_latch
	.xref	int_block_count

	.xref	ms_vdp_set_mode
	.xref	ms_vdp_update_visibility

	;.xdef	ms_vdp
	; functions
	.xdef	ms_vdp_init_mac
	.xdef	ms_vdp_deinit_mac

	.xdef	set_TEXT1_mac
	.xdef	set_TEXT2_mac
	.xdef	set_MULTICOLOR_mac
	.xdef	set_GRAPHIC1_mac
	.xdef	set_GRAPHIC2_mac
	.xdef	set_GRAPHIC4_mac
	.xdef	set_GRAPHIC5_mac
	.xdef	set_GRAPHIC6_mac
	.xdef	set_GRAPHIC7_mac

	.xdef	w_GRAPHIC1_mac
	.xdef	w_GRAPHIC2_mac
	.xdef	w_GRAPHIC3_mac
	.xdef	w_GRAPHIC4_mac
	.xdef	w_GRAPHIC5_mac
	.xdef	w_GRAPHIC6_mac
	.xdef	w_GRAPHIC7_mac

	.xdef	w_p_name_tx1_mac
	.xdef	w_p_gene_tx1_mac
	.xdef	w_p_name_tx2_mac
	.xdef	w_p_gene_tx2_mac

	.xdef	read_vdp_0
	.xdef	read_vdp_1
	.xdef	read_vdp_2
	.xdef	read_vdp_3
	.xdef	write_vdp_0
	.xdef	write_vdp_1
	.xdef	write_vdp_2
	.xdef	write_vdp_3

	.xref	ms_vdp_int
	.xdef	ms_vsync_interrupt_tick
	.xdef	ms_vdp_vsync_rate
	.xdef	ms_vdp_rewrite_flag_tbl

	.xdef	PSET_G4
	.xdef	PSET_G5
	.xdef	LINE_G5
	.xdef	LMMC_G5


V_MFP_GPIP_6	equ	$000138		* 水平割り込みのベクタアドレス
V_MFP_GPIP_7	equ	$00013C		* H-SYNC割り込み(全ラスタ割り込み)

gram		equ	$c00000

CRTR_00		equ	$e80000		* ＣＲＴＣレジスタ０
CRTR_01		equ	$e80002
CRTR_02		equ	$e80004
CRTR_03		equ	$e80006
CRTR_04		equ	$e80008
CRTR_05		equ	$e8000a
CRTR_06		equ	$e8000c
CRTR_07		equ	$e8000e
CRTR_08		equ	$e80010

CRTR_09		equ	$e80012		* ＣＲＴＣレジスタ９ (ラスタ割り込みをかけるラスタ番号)

CRTR_10		equ	$e80014		* ＣＲＴＣレジスタ10 (テキストスクロールX)
CRTR_11		equ	$e80016		* ＣＲＴＣレジスタ11 (テキストスクロールY)
CRTR_12		equ	$e80018		* ＣＲＴＣレジスタ12 GR0 のスクロールX
CRTR_13		equ	$e8001A		* ＣＲＴＣレジスタ13 GR0 のスクロールY
CRTR_14		equ	$e8001C		* ＣＲＴＣレジスタ14 GR1 のスクロールX
CRTR_15		equ	$e8001E		* ＣＲＴＣレジスタ15 GR1 のスクロールY
CRTR_16		equ	$e80020		* ＣＲＴＣレジスタ16 GR2 のスクロールX
CRTR_17		equ	$e80022		* ＣＲＴＣレジスタ17 GR2 のスクロールY
CRTR_18		equ	$e80024		* ＣＲＴＣレジスタ18 GR3 のスクロールX
CRTR_19		equ	$e80026		* ＣＲＴＣレジスタ19 GR3 のスクロールY

CRTR_20		equ	$e80028
CRTR_21		equ	$e8002a
CRTR_23		equ	$e8002e
pla0		equ	$e00000

g_palette	equ	$e82000		* グラフィックパレット
t_palette	equ	$e82200		* テキストパレット	

VCRR_00		equ	$e82400		* ビデオコントロールレジスタ０
VCRR_01		equ	$e82500		* ビデオコントロールレジスタ１
VCRR_02		equ	$e82600		* ビデオコントロールレジスタ２

GPIP		equ	$e88001
IERA		equ	$e88007		* 割り込み許可レジスタA。Bit7がGPIP7(HSYNC)
IMRA		equ	$e88013		* 割り込みマスクレジスタA。Bit7がGPIP7(HSYNC)

X68_SSR		equ	$eb0000		* スプライトスクロールレジスタ

SPCON_HTOTAL	equ	$eb080a		* スプライトコントローラ 画面モードレジスタ H-TOTAL
SPCON_HDISP	equ	$eb080c		* スプライトコントローラ 画面モードレジスタ H-DISP
SPCON_VDISP	equ	$eb080e		* スプライトコントローラ 画面モードレジスタ V-DISP
SPCON_RES	equ	$eb0810		* スプライトコントローラ 画面モードレジスタ V-Res, H-Res


offset_ms_vdp_init			equ	0*4
offset_ms_vdp_read_vram			equ	1*4
offset_ms_vdp_write_vram		equ	2*4
offset_ms_vdp_update_palette		equ	3*4
offset_ms_vdp_update_pnametbl_baddr	equ	4*4
offset_ms_vdp_update_colortbl_baddr	equ	5*4
offset_ms_vdp_update_pgentbl_baddr	equ	6*4
offset_ms_vdp_update_sprattrtbl_baddr	equ	7*4
offset_ms_vdp_update_sprpgentbl_baddr 	equ	8*4
offset_ms_vdp_update_r7_color		equ	9*4
offset_ms_vdp_get_mode_name		equ	10*4
offset_ms_vdp_vdp_command_exec		equ	11*4
offset_ms_vdp_vdp_command_read		equ	12*4
offset_ms_vdp_vdp_command_write		equ	13*4
offset_ms_vdp_update_resolution		equ	14*4
offset_ms_vdp_vsync_draw		equ	15*4
offset_ms_vdp_sprite_mode		equ	16*4
offset_ms_vdp_crt_width			equ	17*4
offset_ms_vdp_dots_per_byte		equ	18*4
offset_ms_vdp_bits_per_dot		equ	19*4

; typedef struct ms_vdp {
; 	uint8_t	r00;	// Mode register 0
; 	uint8_t	r01;	// Mode register 1
; 	uint8_t	_r02;	// R02の生の値。実際のアクセスでは pnametbl_baddr を使う
; 	uint8_t _r03;	// R03の生の値。実際のアクセスでは R10 と結合した colortbl_baddr を使う
; 	uint8_t _r04;	// R04の生の値。実際のアクセスでは pgentbl_baddr を使う
; 	uint8_t _r05;	// R05の生の値。実際のアクセスでは R11 と結合した sprattrtbl_baddr を使う
; 	uint8_t _r06;	// R06の生の値。実際のアクセスでは sprpgentbl_baddr を使う
; 	uint8_t _r07;	// R09の生の値。実際のアクセスでは text_color / back_color を使う
; 	uint8_t r08;	// Mode register 2
; 	uint8_t r09;	// Mode register 3
; 	uint8_t _r10;	// R10の生の値。実際のアクセスでは R03 と結合した colortbl_baddr を使う
; 	uint8_t _r11;	// R11の生の値。実際のアクセスでは R05 と結合した sprattrtbl_baddr を使う
; 	uint8_t r12;
; 	uint8_t r13;
; 	uint8_t r14;
; 	uint8_t r15;
; 	uint8_t r16;
; 	uint8_t r17;
; 	uint8_t r18;
; 	uint8_t r19;
; 	uint8_t r20;
; 	uint8_t r21;
; 	uint8_t r22;
; 	uint8_t r23;
; 	uint8_t r24;
; 	uint8_t r25;
; 	uint8_t r26;
; 	uint8_t r27;
; 	uint8_t r28;
; 	uint8_t r29;
; 	uint8_t r30;
; 	uint8_t r31;
; 	uint16_t sx;	// 32,33 (並びが逆になるので注意)
; 	uint16_t sy;	// 34,35
; 	uint16_t dx;	// 36,37
; 	uint16_t dy;	// 38,39
; 	uint16_t nx;	// 40,41
; 	uint16_t ny;	// 42,43
; 	uint8_t clr;	// 44
; 	uint8_t arg;	// 45
; 	uint8_t r46;

; 	uint8_t dummy1;	// 47

; 	// Status Registers
; 	uint8_t s00;	// offset = +48
; 	uint8_t s01;
; 	uint8_t s02;
; 	uint8_t s03;
; 	uint8_t s04;
; 	uint8_t s05;
; 	uint8_t s06;
; 	uint8_t s07;
; 	uint8_t s08;
; 	uint8_t s09;	// offset = +57

; 	// Palette Registers
; 	uint16_t palette[16];	// offset = +58

; 	// Special Control Registers
; 	// 	特殊コントロールレジスタ
; 	//  R_00:	.dc.b	0		* [ 0 ][ DG][IE2][IE1][ M5][ M4][ M3][ 0 ]
; 	//	R_01:	.dc.b	0		* [ 0 ][ BL][IE0][ M1][ M2][ 0 ][ SI][MAG]
; 	uint8_t crt_mode;		// R_0,R_1の[ M5]〜[ M0]
; 	uint8_t sprite_size;	// R_1の[ SI]
; 	uint8_t sprite_zoom;	// R_1の[MAG]
; 	uint8_t dummy2;

; 	// base address registers
; 	uint32_t pnametbl_baddr;		// R02: Pattern name table base address
; 	uint32_t colortbl_baddr;		// R03: Color table base address
; 	uint32_t pgentbl_baddr;		// R04: Pattern generator table base address
; 	uint32_t sprattrtbl_baddr;		// R05: Sprite attribute table bse address
; 	uint32_t sprpgentbl_baddr;	// R06: Sprite pattern generator table base address
; 	uint16_t text_color;			// R07: Text color
; ; 	uint16_t back_color;			// R07: Back color

; 	//
; 	uint32_t vram_addr;
; 	uint32_t gram_addr;

; 	//
; 	uint16_t display_mode;
; 	ms_vdp_mode_t *ms_vdp_current_mode;

; 	//
; 	uint16_t tx_active;
; 	uint16_t gr_active;

; 	// X68000側に確保したVRAMの先頭アドレス
; 	uint8_t* vram;

; 	// X68000のPCGに転送するためのバッファ領域
; 	unsigned int* x68_pcg_buffer;
; 	int last_visible_sprite_planes;
; 	int last_visible_sprite_size;
; } ms_vdp_t;

offset_ms_vdp_r00		equ	0
offset_ms_vdp_r01		equ	1
offset_ms_vdp_r02_		equ	2
offset_ms_vdp_r03_		equ	3
offset_ms_vdp_r04_		equ	4
offset_ms_vdp_r05_		equ	5
offset_ms_vdp_r06_		equ	6
offset_ms_vdp_r07_		equ	7
offset_ms_vdp_r08		equ	8
offset_ms_vdp_r09		equ	9
offset_ms_vdp_r10_		equ	10
offset_ms_vdp_r11_		equ	11
offset_ms_vdp_r12		equ	12
offset_ms_vdp_r13		equ	13
offset_ms_vdp_r14		equ	14
offset_ms_vdp_r15		equ	15
offset_ms_vdp_r16		equ	16
offset_ms_vdp_r17		equ	17
offset_ms_vdp_r18		equ	18
offset_ms_vdp_r19		equ	19
offset_ms_vdp_r20		equ	20
offset_ms_vdp_r21		equ	21
offset_ms_vdp_r22		equ	22
offset_ms_vdp_r23		equ	23
offset_ms_vdp_r24		equ	24
offset_ms_vdp_r25		equ	25
offset_ms_vdp_r26		equ	26
offset_ms_vdp_r27		equ	27
offset_ms_vdp_r28		equ	28
offset_ms_vdp_r29		equ	29
offset_ms_vdp_r30		equ	30
offset_ms_vdp_r31		equ	31
offset_ms_vdp_sx		equ	32
offset_ms_vdp_sy		equ	34
offset_ms_vdp_dx		equ	36
offset_ms_vdp_dy		equ	38
offset_ms_vdp_nx		equ	40
offset_ms_vdp_ny		equ	42
offset_ms_vdp_clr		equ	44
offset_ms_vdp_arg		equ	45
offset_ms_vdp_r46		equ	46
offset_ms_vdp_s00		equ	48
offset_ms_vdp_s01		equ	49
offset_ms_vdp_s02		equ	50
offset_ms_vdp_s03		equ	51
offset_ms_vdp_s04		equ	52
offset_ms_vdp_s05		equ	53
offset_ms_vdp_s06		equ	54
offset_ms_vdp_s07		equ	55
offset_ms_vdp_s08		equ	56
offset_ms_vdp_s09		equ	57
offset_ms_vdp_palette		equ	58
offset_ms_vdp_alt_color_zero	equ	60

offset_ms_vdp_crt_mode		equ	92
offset_ms_vdp_sprite_size	equ	93
offset_ms_vdp_sprite_zoom	equ	94
offset_ms_vdp_dummy2		equ	95
offset_ms_vdp_pnametbl_baddr	equ	96
offset_ms_vdp_colortbl_baddr	equ	100
offset_ms_vdp_pgentbl_baddr	equ	104
offset_ms_vdp_sprattrtbl_baddr	equ	108
offset_ms_vdp_sprcolrtbl_baddr	equ	112
offset_ms_vdp_sprpgentbl_baddr 	equ	116
offset_ms_vdp_text_color	equ	120
offset_ms_vdp_back_color	equ	122
offset_ms_vdp_vram_addr		equ	124
offset_ms_vdp_gram_addr		equ	128
offset_ms_vdp_disablehsyncint	equ	132
offset_ms_vdp_dummy4		equ	133
offset_ms_vdp_current_mode	equ	134
offset_ms_vdp_tx_active		equ	138
offset_ms_vdp_gr_active		equ	140
offset_ms_vdp_gr_active_interlace equ	142
offset_ms_vdp_vram		equ	144
offset_ms_vdp_x68_pcg_buffer	equ	148
offset_ms_vdp_last_visible_sprite_planes	equ	152
offset_ms_vdp_last_visible_sprite_size		equ	156
offset_ms_vdp_sprite_refresh_flag	equ	160

SPRITE_REFRESH_FLAG_COORD	equ	$01
SPRITE_REFRESH_FLAG_ATTR	equ	$02
SPRITE_REFRESH_FLAG_CC		equ	$04
SPRITE_REFRESH_FLAG_PGEN	equ	$08

*
*	ＭＳＸの画面モードと６８の画面モードの対応
*
*	ＭＳＸ			６８
*	screen0	(TEXT1,TEXT2)	16色	512*512
*	screen1	(GRAPHIC1)	16色	512*512
*	screen2	(GRAPHIC2)	16色	512*512
*	screen3	(MULTICOLOR)	16色	512*512
*	screen4	(GRAPHIC3)	16色	512*512
*	screen5	(GRAPHIC4)	16色	512*512
*	screen6	(GRAPHIC5)	16色	512*512
*	screen7	(GRAPHIC6)	16色	512*512
*	screen8	(GRAPHIC7)	256色	512*512
*	screen10		65536色	512*512
*	screen11		65536色	512*512
*	screen12		65536色	512*512
*
*
	.68030

	.text
	.even


***************************************************************
*
*	ＶＤＰ設定ルーチン
*
*	int ms_vdp_init_mac(ms_vdp_t *vdp);
*
*	成功時は1を返す
*
***************************************************************
ms_vdp_init_mac:
	link	a6,#0
	movem.l	d3-d7/a0-a5,-(sp)

	; 引数で vdpのシングルトンインスタンスのポインタを受けとっているので、
	; それを ms_vdp_shared に覚えておく
	;
	; 構造的には複数インスタンスが作れるようなインターフェースにしているが、
	; 本VDP実装はX68000のグラフィックを占有するため、実質的には1つしか作れない
	; ただ、Kepler X上のVDPとの差し替えができるようにするなどの将来的な拡張のために、
	; APIはかならず引数に vdpインスタンスを受け取るようにしている
	move.l	8(a6),ms_vdp_shared
	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得

	* プライオリティの設定
	* b15:14 (NONE)
	* b13:12 スプライト優先順位
	* b11:10 テキスト優先順位
	* b09:08 グラフィック優先順位
	* b07:06 ┗グラフィックページ3の優先順位
	* b05:04 ┗グラフィックページ2の優先順位
	* b03:02 ┗グラフィックページ1の優先順位
	* b01:00 ┗グラフィックページ0の優先順位
	move.w	#%00_01_00_10__11_10_01_00,VCRR_01

	move.w	#1,offset_ms_vdp_tx_active(a5)
	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.w	#0,$E82222

	; 割り込み設定
	move.w	sr,d0
	move.w	d0,-(sp)
	or.w	#%00000111_00000000,d0	* 一時的に割り込み禁止
	move.w	d0,sr
@@:
	move.w	ms_vdp_vsync_rate,d1
	and.w	#$0_ff,d1			* 垂直帰線期間で、指定回数ごとに割り込み
	lea.l	vsync_interrupt,a1
	IOCS	__VDISPST
	move.l	d0,d0
	beq	@f
	pea	errms_timer_A_in_use
	DOS	__PRINT
	lea.l	4(sp),sp	
	movea.l	#0,a1	
	IOCS	__VDISPST
	bra	@b
@@:
	; ラスター割り込みを設定
	; X68000のラスタ割り込みには、MFPのGPIP6と7の2つの方法がある
	;  * GPIP6 : CRTC R#9 に設定したラスタ番号で割り込みをかける
	;  * GPIP7 : すべてのラスタ(H-SYNC)で割り込みをかける
	; IOCSの CRTCRASは前者のGPIP6を使った方法。
	; GPIP7の方が自由度は高いが負荷も高いので、今回はGPIP6を使う
	; これを使い、VDPのHSYNC割り込みへの対応を行う予定。
@@:	move.w	#128,d1		* 仮
	lea	raster_interrupt,a1
	IOCS	__CRTCRAS
	move.l	d0,d0
	beq	@f
	pea	errms_raster_in_use
	DOS	__PRINT
	movea.l	#0,a1	
	IOCS	__CRTCRAS
	bra	@b
@@:
	; HSYNC割り込みを設定(テスト)
	; GPIP7のHSYNC割り込みを設定し、以下の目的に使用する
	; ●目的1: VSYNC直後の画面リフレッシュ
	; MSX側がVSYNC割り込みでスプライトの書き換えを行った後、X68000側のスプライトに
	; その変更を反映したい。元々はVSYNC割り込みでMSX側に割り込みをかけた後、 hostdelayで
	; 指定された命令が実行された後にホスト側の処理(スプライトのアップデートなど)を行っていたが、
	; その方法だと、タイミングが制御しづらい
	; そこで、HSYNC割り込みでラスタ番号をカウントし、hostdelayではなく、特定の走査線番号で
	; ホスト側の処理を呼び出せるようにしたい
	; --hostdelayを廃止し、--hostlineに変更
	;	
	; ●目的2: HSYNCが2倍発生してしまう問題への対処
	; MSX側は192 or 212ラインしかないが、X68000側はたとえ256ドットモードにしたとしても
	; 31kHzモードだと、その倍のHSYNCが発生している
	; 通常は問題が起きないが VDP S#2 の b5で 水平帰線期間(0:帰線期間,1:表示期間)を計測
	; されてしまうと、実機の2倍のHSYNCが見えてしまう。
	; よくある処理としては、ラスタ割り込みを1ライン手前で発生させ、割り込み中に VDP #2を
	; ポーリングして、帰線期間に入ったら実際の処理を行うという手法がある。
	; MSXのラスタ割り込みはX68000側のCRTCRASで行なっているので、その後にポーリングされると
	; 中間のラインで処理が行われることになる。走査線番号が偶数の時だけ拾えるようにすれば
	; よいのだが、X68000には現在の走査線番号を取得するレジスタがないので、HSYNC割り込みを使って
	; カウンタで数える必要がある
	andi.b	#%01111111,IERA		* GPIP7のHSYNC割り込みを禁止
	ori.b	#%10000000,IMRA		* GPIP7のHSYNC割り込みマスクを剥がす（1=マスクしない）
	move.l	V_MFP_GPIP_7,hsync_vec_original	* 元のベクタを保存
	move.l	#hsync_interrupt,V_MFP_GPIP_7	* HSYNC割り込みベクタを設定
	ori.b	#%10000000,IERA		* GPIP7のHSYNC割り込みを許可

	; 
	move.w	(sp)+,sr			* 割り込み復帰

	movem.l	(sp)+,d3-d7/a0-a5
	unlk	a6

	moveq.l	#1,d0

	rts

RASTERDEBUG	.equ	0		* 1: ラスタ割り込みのデバッグを有効にする

vsync_interrupt:
	movem.l	d0/a0/a5,-(sp)
	addq.w	#1,ms_vsync_interrupt_tick

	; HSYNCカウンタを0に戻す
	move.w	#0,hsync_counter

	; VSYNC割り込みをスキップする/しないに関わらず、cpu_yieldは 1/60秒ごとにセットする (ウェイトの計算などで実時間を知る必要があるため)
	move.b	#$01,cpu_yield			* cpu_yield

	; emu_counter の増加量が int_block_count に達していなかったら割り込みを一回スキップ(実験)
	move.l	emu_counter,d0
	sub.l	emu_counter_latch2,d0
	cmp.l	int_block_count,d0
	bgt	@f
	bra	9f

@@:
	move.l	emu_counter,emu_counter_latch2
	;	VDPの割り込み処理
	movea.l	ms_vdp_shared,a5
	btst.b	#5,offset_ms_vdp_r01(a5)	* VDP IE0 (R#1のbit5) をみて、VSYNC割り込みが許可されているかを調べる
	beq	@f
	bset.b	#7,offset_ms_vdp_s00(a5)	* VDP S#0の bit7に、VSYNC割り込み発生フラグを立てる。これとS#1の HSYNC割り込みがZ80のINT端子の状態を表している。
	bset.b	#0,ms_vdp_int			* VSYNC割り込み要求フラグを立てる

@@:	.if 	RASTERDEBUG=1
	; どこでラスタ割り込みがかかっているかを確認するためにテキストパレットの色を変える(ここで戻す)
	move.w	#%11111_11111_11111_1,t_palette+$3*2
	;move.w	#%11111_00000_11111_1,raster_debug
	.endif

9:	movem.l	(sp)+,d0/a0/a5
	rte

raster_interrupt:
	movem.l	d0/a0/a5,-(sp)
	movea.l	ms_vdp_shared,a5
	cmp.b	#0,offset_ms_vdp_disablehsyncint(a5)
	bne	@f				* HSYNC割り込みが禁止されている場合は何もしない
	btst.b	#4,offset_ms_vdp_r00(a5)	* VDP IE1 (R#0のbit4) をみて、HSYNC割り込みが許可されているかを調べる
	beq	@f
	; 走査線割り込みをかける
	bset.b	#0,offset_ms_vdp_s01(a5)	* VDP S#1の bit0に、HSYNC割り込み発生フラグを立てる。これとS#0の VSYNC割り込みがZ80のINT端子の状態を表している。
	bset.b	#1,ms_vdp_int			* HSYNC割り込み要求フラグを立てる
	move.b	#$01,sub_yield			* sub_yield 

	; どこでラスタ割り込みがかかっているかを確認するためにテキストパレットの色を変える
	.if 	RASTERDEBUG=1
	move.w	raster_debug,d0
	move.w	d0,t_palette+$3*2
	eor.w	#%11111_11111_11111_0,d0
	move.w	d0,raster_debug
	.endif

@@:	movem.l	(sp)+,d0/a0/a5
	rte

raster_debug:
	.dc.w	%11111_00000_11111_1

hsync_interrupt:
	move.l	d0,-(sp)
	;
	move.w	hsync_counter,d0
	add.w	#1,d0
	move.w	d0,hsync_counter
	cmp.w	host_line,d0
	bne	@f
	; ホスト(X68000)側の処理を行うためのフラグ、emu_yieldをセット
	move.w	#$1,emu_yield

	;
@@:	move.l	(sp)+,d0	
	rte

	.data
emu_counter_latch2:
	.dc.l	0

hsync_vec_original:
	.dc.l	0
hsync_counter:
	.dc.w	0

	.text
;
; ＶＤＰの終了処理
;
ms_vdp_deinit_mac:
	move.w	sr,d0
	move.w	d0,-(sp)		* sr を保存
	or.w	#%00000111_00000000,d0	* 一時的に割り込み禁止
	move.w	d0,sr

	; HSYNC割り込みを戻す
	andi.b	#%01111111,IERA		* GPIP7のHSYNC割り込みを禁止
	andi.b	#%01111111,IMRA		* GPIP7のHSYNC割り込みマスク（0=マスク）
	move.l	hsync_vec_original,V_MFP_GPIP_7	* 元のベクタに戻す

	; ラスタ割り込みを戻す
	clr.l	a1			* ラスタ割り込みの禁止
	IOCS	__CRTCRAS

	; HSYNC割り込みを戻す
	clr.l	a1			* 垂直同期割り込みを禁止
	IOCS	__VDISPST

	move.w	(sp)+,sr		* sr を復元
	rts

ms_vdp_update_visibility_mac:
	movem.l	d0-d7/a0-a5,-(sp)
	move.l	ms_vdp_shared,-(sp)	* 構造体のアドレスを引数に
	bsr	ms_vdp_update_visibility
	lea	4(sp),sp
	movem.l	(sp)+,d0-d7/a0-a5
	rts

	.data
	.even

ms_vdp_shared:
	.dc.l	0

ms_vdp_vsync_rate:
	.dc.w	1
ms_vsync_interrupt_tick:
	.dc.w	0
errms_timer_A_in_use:
	.dc.b	'タイマＡは使用中です',0,0
errms_raster_in_use:
	.dc.b	'ラスタ割り込みは使用中です',0,0

	.text

*
* バックドロップ用のＢＧを設定
*
enable_backdrop:
	lea.l	$EB8000,a0

	move.l	#$11111111,d1			* パターンの定義
	move.w	#32-1,d0
@@:	move.l	d1,(a0)+
	dbra	d0,@b

	lea.l	$EBC000,a0			* ＢＧの定義
	move.w	#%00000001_00000000,d1
	move.w	#4096-1,d0
@@:	move.w	d1,(a0)+
	dbra	d0,@b

*	ori.w	#%0000001_000_001_001,$EB0808			* BG ON
	ori.w	#%0000001_000_000_000,$EB0808			* BG OFF
	rts

***************************************************************
*
*	ＶＤＰポートからの読み込みルーチン群
*
*    (返り値）
*	d0.b ・・・ 読み込んだ値
*
***************************************************************
read_vdp_0:				* ＶＲＡＭの読み込み
	; 画面モードごとのVRAM読み込み処理を呼び出す
	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	a5,-(sp)		* 構造体のアドレスを引数1に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_read_vram(a0),a0
	jsr	(a0)
	lea.l	4(sp),sp
	rts

read_vdp_1:					* ステータスレジスタの読みだし
	movea.l	ms_vdp_shared,a5
	move.b	offset_ms_vdp_r15(a5),d0	* ステータスレジスタ番号の読みだし
	andi.w	#%00001111,d0
	add.w	d0,d0
	add.w	d0,d0
	lea	r_SReg_jpt,a0 
	move.l	(a0,d0.w),a0
	jmp	(a0)

	.data
r_SReg_jpt:
	.dc.l	r_SReg_0
	.dc.l	r_SReg_1
	.dc.l	r_SReg_2
	.dc.l	r_SReg_3
	.dc.l	r_SReg_4
	.dc.l	r_SReg_5
	.dc.l	r_SReg_6
	.dc.l	r_SReg_7
	.dc.l	r_SReg_8
	.dc.l	r_SReg_9
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f

	.text

r_SReg_0:
	move.b	offset_ms_vdp_s00(a5),d0
	bclr.b	#7,offset_ms_vdp_s00(a5)	* S#0の bit 7(VSYNC割り込み)は読み出すとリセットされる
	bclr.b	#0,ms_vdp_int			* VSYNC割り込み要求クリア
	rts

r_SReg_1:
	move.b	offset_ms_vdp_s01(a5),d0
	bclr.b	#0,offset_ms_vdp_s01(a5)	* S#1の bit 0(HSYNC割り込み)は読み出すとリセットされる
	bclr.b	#1,ms_vdp_int			* HSYNC割り込み要求クリア
	rts

r_SReg_2:
	move.b	offset_ms_vdp_s02(a5),d0
	move.b	GPIP,d1			* いったんレジスタに読む
	; VDP S#2 b6:垂直帰線期間(0:帰線期間,1:表示期間) の設定
	btst.l	#4,d1			* GPIP b4:垂直帰線期間かどうか (0:垂直帰線期間 1:垂直帰線期間外(表示期間))
	beq	_rs2_vsync
_rs2_vdisp:
	ori.b	#%01000000,d0
	; 表示期間の時は、水平帰線期間かどうかも設定
	btst.l	#7,d1			* GPIP b7:水平帰線期間かどうか (0:水平同期期間外(表示期間) 1:水平同期期間)
	bne	1f
	ori.b	#%00100000,d0		* VDP S#2 b5:水平帰線期間(0:帰線期間,1:表示期間)
	bra	@f
1:	andi.b	#%11011111,d0		* VDP S#2 b5:水平帰線期間(0:帰線期間,1:表示期間)
	bra	@f
_rs2_vsync:
	andi.b	#%10111111,d0
	ori.b	#%00100000,d0		* VDP S#2 b5:水平帰線期間(0:帰線期間,1:表示期間)

@@:	move.b	d0,offset_ms_vdp_s02(a5) * 一応書き戻し
	rts

r_SReg_3:
	move.b	offset_ms_vdp_s03(a5),d0
	rts
r_SReg_4:
	move.b	offset_ms_vdp_s04(a5),d0
	rts
r_SReg_5:
	move.b	offset_ms_vdp_s05(a5),d0
	rts
r_SReg_6:
	move.b	offset_ms_vdp_s06(a5),d0
	rts
r_SReg_7:
	; 画面モードに応じてVDPコマンドのREADを実行
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_vdp_command_read(a0),a0
	jsr	(a0)
	lea.l	4(sp),sp
	; R#7を読み出すと、S#2のbit7 (TRビット)　がクリアされる
	bclr.b	#7,offset_ms_vdp_s02(a5)
	rts
r_SReg_8:
	move.b	offset_ms_vdp_s08(a5),d0
	rts
r_SReg_9:
	move.b	offset_ms_vdp_s09(a5),d0
	rts
r_SReg_f:
	move.b	#$ff,d0
	rts

read_vdp_2:				* 書き込み専用ポート（読み込むと$ffが返るらしい）
read_vdp_3:
	moveq.l	#$ff,d0
	rts


***************************************************************
*
*	ＶＤＰポートへの書き込みルーチン群
*
*    (引数）
*	d1.b ・・・ 書き込む値
*
***************************************************************
write_vdp_0:				* VRAM への書き込み
	; 画面モードごとのVRAM書き込み処理を呼び出す
	andi.l	#$000000ff,d1
	move.l	d1,-(sp)		* 書き込む値を引数2に
	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	a5,-(sp)		* 構造体のアドレスを引数1に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_write_vram(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts


write_vdp_1:
	bchg.b	#0,w_ContReg_mode	* １バイト目か２バイト目か？
	bne	@f
	move.b	d1,first_bite_1		* １バイト目
	rts
@@:
	movea.l	ms_vdp_shared,a5
	move.b	d1,d0
	bmi	set_CReg_Direct		* コントロールレジスタの直接指定モード

	move.l	offset_ms_vdp_vram_addr(a5),d1		* ＶＲＡＭアドレス設定
	andi.w	#%11000000_00000000,d1
	andi.w	#%00000000_00111111,d0
	lsl.w	#8,d0
	move.b	first_bite_1,d0
	or.w	d0,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	movea.l	set_gram_add_rot,a0
	jmp	(a0)

write_vdp_2:				* パレットレジスタへの書き込み
	bchg.b	#0,w_PalReg_mode	* １バイト目か２バイト目か？
	bne	@f
	move.b	d1,first_bite_2		* １バイト目
	rts
@@:
	movea.l	ms_vdp_shared,a5
	andi.w	#%00000111,d1
	add.w	d1,d1
	lea.l	b3_b5_table,a0
	move.w	(a0,d1.w),d1
	lsl.w	#8,d1
	lsl.w	#3,d1			* d1 = %GGGGG000_00000000
	move.b	first_bite_2,d0
	move.b	d0,d2
	andi.w	#%00000000_01110000,d0
	lsr.w	#4,d0			* d0 = %00000000_00000RRR
	add.w	d0,d0
	move.w	(a0,d0.w),d0
	lsl.w	#6,d0			* d0 = %00000RRR_RR000000
	or.w	d0,d1			* d1 = %GGGGGRRR_RR000000
	andi.w	#%00000000_00000111,d2
	add.w	d2,d2
	move.w	(a0,d2.w),d2
	add.w	d2,d2			* d2 = %00000000_00BBBBB0
	or.w	d2,d1			* d1 = %GGGGGRRR_RRBBBBB0
	addq.w	#1,d1			* d1 = %GGGGGRRR_RRBBBBB1

	move.b	offset_ms_vdp_r16(a5),d0			* 書き込むパレット番号の読みだし
	addq.b	#1,offset_ms_vdp_r16(a5)			* R#16はインクリメント
	andi.b	#%00001111,offset_ms_vdp_r16(a5)
	andi.w	#$000f,d0
	add.w	d0,d0
	lea.l	offset_ms_vdp_palette(a5),a0			* X68000の16bitカラー形式に変換した値をP_0?P_15に書き込む
	move.w	d1,0(a0,d0.w)

	; 画面モードに応じてパレットをX68000側の画面に設定
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_palette(a0),a0
	jsr	(a0)
	lea.l	4(sp),sp
	rts

b3_b5_table:				* ３ビットのデータから５ビットのデータを得る
	.dc.w	0			* 0
	.dc.w	4
	.dc.w	9
	.dc.w	13			* 3
	.dc.w	18			* 4
	.dc.w	22
	.dc.w	27
	.dc.w	31			* 7


***************************************************************
*
*	コントロールレジスタ間接書き込みルーチン
*
***************************************************************
write_vdp_3:
	movea.l	ms_vdp_shared,a5
	move.b	offset_ms_vdp_r17(a5),d0
	andi.w	#%00000000_10111111,d0
	bclr.l	#7,d0
	beq	incmode
	cmp.b	#17,d0			* R#17 は間接指定では変更出来ない
	bne	@f
	rts
@@:	move.w	d0,d2
	add.w	d2,d2
	add.w	d2,d2
	lea	w_CReg_jpt,a0
	move.l	(a0,d2.w),a0
	jmp	(a0)


incmode:
	addq.b	#1,offset_ms_vdp_r17(a5)
	cmp.b	#17,d0			* R#17 は間接指定では変更出来ない
	bne	@f
	rts
@@:	move.w	d0,d2
	add.w	d2,d2
	add.w	d2,d2
	lea	w_CReg_jpt,a0
	move.l	(a0,d2.w),a0
	jmp	(a0)
	

***************************************************************
*
*	コントロールレジスタ直接書き込みルーチン
*
***************************************************************
set_CReg_Direct:
	move.b	first_bite_1,d1
	andi.w	#%00000000_00111111,d0
	move.w	d0,d2
	add.w	d2,d2
	add.w	d2,d2
	lea	w_CReg_jpt,a0
	move.l	(a0,d2.w),a0
	jmp	(a0)


* 	サブルーチンへのコールテーブル
*	.d0.w	レジスタ番号		* <-- ワードであることに注意
*	.d1.b	書き込む値
	.data

w_CReg_jpt:
	.dc.l	w_R0			* R#0
	.dc.l	w_R1
	.dc.l	w_R2
	.dc.l	w_R3
	.dc.l	w_R4
	.dc.l	w_R5			* スプライトアトリビュートテーブル(下位)
	.dc.l	w_R6			* スプライトパターンジェネレータテーブル
	.dc.l	w_R7
	.dc.l	w_R8
	.dc.l	w_R9
	.dc.l	w_R10			* R#10
	.dc.l	w_R11			* スプライトアトリビュートテーブル(上位)
	.dc.l	normal
	.dc.l	normal
	.dc.l	w_R14
	.dc.l	w_R15
	.dc.l	w_R16
	.dc.l	w_R17
	.dc.l	w_R18
	.dc.l	w_R19
	.dc.l	normal			* R#20
	.dc.l	normal
	.dc.l	normal
	.dc.l	w_R23
	.dc.l	normal
	.dc.l	normal
	.dc.l	normal
	.dc.l	normal			* R#27
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister		* R$30
	.dc.l	noregister
	.dc.l	SX_l			* R#32
	.dc.l	SX_h
	.dc.l	SY_l
	.dc.l	SY_h
	.dc.l	DX_l
	.dc.l	DX_h
	.dc.l	DY_l
	.dc.l	DY_h
	.dc.l	NX_l			* R#40
	.dc.l	NX_h
	.dc.l	NY_l
	.dc.l	NY_h
MC_add:	.dc.l	w_CLR			* R#44 Color register : CPU-VRAM間データ転送レジスタ
	.dc.l	w_ARG
	.dc.l	w_R46			* R#46
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister		* 63

	.text

noregister:
	move.w	d0,d2
	lsr.w	#4,d0
	move.b	@f(pc,d0.w),number_creg+0
	andi.w	#$0f,d2
	move.b	@f(pc,d2.w),number_creg+1

	pea.l	errms_creg
	DOS	__PRINT
	lea.l	4(sp),sp
	rts

@@:	.dc.b	'0123456789ABCDEF'

	.data
errms_creg:
	.dc.b	'おかしなVDPコントロールレジスタに書き込みました。0x'
number_creg:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00


	.even

	.text
normal:
	lea.l	offset_ms_vdp_r00(a5),a0
	move.b	d1,0(a0,d0.w)
	rts

*crtcras_:
*	.dc.l	crtcras

; R#0	VDP Mode Register 0
; 	[ 0 ][ DG][IE2][IE1][ M5][ M4][ M3][ 0 ]
;	DG  : カラーバスを入力モードにしてデータをＶＲＡＭへ取り込む
;	IE2 : ライトペン割り込み
;		０＝禁止
;		１＝許可
;	IE1 : 水平帰線(HSYNC)割り込み
;		０＝禁止
;		１＝許可
;	M5-M1 : 画面モード(後述: set_CRT参照)
w_R0:	move.b	d1,offset_ms_vdp_r00(a5)

	btst.l	#4,d1			* VDP IE1 (R#0のbit4) をみて、HSYNC割り込みが許可されているかを調べる
	bne	@f
	bclr.b	#1,ms_vdp_int		* IE1が0の時はHSYNC割り込み要求フラグをクリア

@@:	bsr	set_CRT			* 画面の切り替え
	rts

; R#1	VDP Mode Register 1
;	[ 0 ][ BL][IE0][ M1][ M2][ 0 ][ SI][MAG]	
; 	BL  : 画面表示状態
;		０＝非表示
;		１＝表示
;	IE0 : 垂直帰線(VSYNC)割り込み
;		０＝禁止
;		１＝許可
;	SI  : スプライトサイズ
; 		０＝８×８
; 		１＝１６×１６
;	MAG : スプライトの拡大
; 		０＝拡大しない
;		１＝拡大する
;	M5-M1 : 画面モード(後述: set_CRT参照)
;
w_R1:	move.b	offset_ms_vdp_r01(a5),d2
	move.b	d1,offset_ms_vdp_r01(a5)

	btst.l	#5,d1			* VDP IE0 (R#1のbit5) をみて、VSYNC割り込みが許可されているかを調べる
	bne	@f
	bclr.b	#0,ms_vdp_int		* IE0が0の時はVSYNC割り込み要求フラグをクリア

@@:	; スプライトサイズ変更の反映
	move.b	offset_ms_vdp_r01(a5),d1
	eor.b	d1,d2
	andi.b	#%00000011,d2
	beq	@f
	* スプライトサイズの変更があった場合、スプライトの再描画を行う
	move.w	#SPRITE_REFRESH_FLAG_PGEN,offset_ms_vdp_sprite_refresh_flag(a5)
	move.b	d1,d0			* スプライトのサイズ, 0の時 8x8, 1の時 16x16
	andi.b	#%00000010,d0
	lsr.b	#1,d0
	move.b	d0,offset_ms_vdp_sprite_size(a5)

@@:	; 画面の表示非表示を反映
	bsr	ms_vdp_update_visibility_mac
	; 画面モードの変更に追従
	bsr	set_CRT

	rts

*
*	システムにパターンネームテーブルが変更されたことを伝える
*
w_R2:	move.b	d1,offset_ms_vdp_r02_(a5)

	andi.l	#%00000000_01111111,d1
	swap	d1
	lsr.l	#6,d1

update_pnametbl_baddr:
	; 画面モードに応じてパターンネームテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_pnametbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts


*
*	システムにカラーテーブルが変更されたことを伝える
*
w_R3:	move.b	d1,offset_ms_vdp_r03_(a5)

	move.l	offset_ms_vdp_colortbl_baddr(a5),d0			* d0 = AAAAAAAA_AA000000
	lsr.w	#6,d0			* d0 = 000000AA_AAAAAAAA
	move.b	d1,d0			* d0 = 000000AA_BBBBBBBB
	lsl.w	#6,d0			* d0 = AABBBBBB_BB000000
	bsr	update_colortbl_baddr
	rts

w_R10:	move.b	d1,offset_ms_vdp_r10_(a5)
	bsr	update_colortbl_baddr
	rts

update_colortbl_baddr:
	; 画面モードに応じてカラーテーブルの更新処理を呼び出す
	move.l	d0,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_colortbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts
	
*
*	システムにパターンジェネレータテーブルが変更されたことを伝える必用がある
*
w_R4:	move.b	d1,offset_ms_vdp_r04_(a5)

	; 画面モードに応じてパターンジェネレータテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_pgentbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts

*
*	R5 はスプライトアトリビュートテーブルの下位バイト
*	システムにスプライトアトリビュートテーブルが変更されたことを伝える必用がある
*
w_R5:	move.b	d1,offset_ms_vdp_r05_(a5)
	bsr	update_spriteattrtbl_baddr
	rts


w_R11:	move.b	d1,offset_ms_vdp_r11_(a5)
	bsr	update_spriteattrtbl_baddr
	rts

update_spriteattrtbl_baddr:
	; 画面モードに応じてスプライトアトリビュートテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_sprattrtbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts
*
*	スプライトパターンジェネレータテーブルの設定
*	システムにスプライトパターンジェネレータテーブルが変更されたことを伝える必用がある
*
w_R6:	move.b	d1,offset_ms_vdp_r06_(a5)

	; 画面モードに応じてスプライトアトリビュートテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_sprpgentbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts

*
*	画面の周辺色の更新
*
w_R7:	move.b	d1,offset_ms_vdp_r07_(a5)

	; 画面モードに応じて周辺色のの更新処理を呼び出す
	move.l	d1,-(sp)		* 値を引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_r7_color(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts

; R#8	VDP Mode Register 2
; 	[ MS][ LP][ TP][ CB][ VR][  0][SPD][ BW]
;	MS  : マウスモード(MSXでは未使用)
;	LP  : ライトペン割り込み (V9958には存在しない)
;	TP  : 透明色の扱い
;		0=色コード0が透明として扱われる
;		1=色コード0がパレットレジスタで指定された色として扱われる
;	CB  : カラーバスの選択
;		0=output(デフォルト)
;		1=input
;	VR  : VRAMの組み合わせ
;	SPD : スプライトの非表示
;		0=スプライト表示
;		1=スプライト非表示
;	BW  : 白黒モード
;		0=カラーモード(デフォルト)
;		1=白黒モード
w_R8:	move.b	d1,offset_ms_vdp_r08(a5)
	rts

; R#9	VDP Mode Register 3
;	[ LN][ 0 ][ S1][ S0][ IL][ EO][ NT][ DC]
;	LN  : ライン数の指定
;		0=192ライン
;		1=212ライン
;	S1S0: スーパーインポーズ関連の設定(未実装)
;	IL  : インターレースモード
;		0=非インターレース
;		1=インターレース
;	EO  : 画面の偶数奇数自動交互表示
;		0=交互表示しない
;		1=交互表示する
;	NT  : NTSC / PAL の選択
;		0=NTSC
;		1=PAL
;	DC  : ドットクロックの入出力方向
;		0=出力
;		1=入力
w_R9:	move.b	d1,offset_ms_vdp_r09(a5)

	; 画面モードに応じて解像度設定の更新処理を呼び出す
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_resolution(a0),a0
	jsr	(a0)
	lea.l	4(sp),sp
	rts

w_R14:	andi.l	#%00000000_00000111,d1	* d1.l = 00000000_00000000_00000AAA
	swap	d1			* d1.l = 00000AAA_00000000000000000
	lsr.l	#2,d1			* d1.l = 0000000A_AA000000_00000000 
	move.l	offset_ms_vdp_vram_addr(a5),d0
	andi.w	#%00111111_11111111,d0
	or.w	d0,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	movea.l	set_gram_add_rot,a0
	jmp	(a0)

w_R15:	move.b	d1,offset_ms_vdp_r15(a5)
	rts
w_R16:	move.b	d1,offset_ms_vdp_r16(a5)
	rts
w_R17:	move.b	d1,offset_ms_vdp_r17(a5)
	rts

; R#18 は set adjust
w_R18:
	move.b	offset_ms_vdp_r18(a5),d0	* 現在の値を保持
	move.b	d1,offset_ms_vdp_r18(a5)
	; 水平方向だけ仮対応
	; R18の下位4ビットが水平方向のAdjust値。4ビットの符号あり整数で -8 〜 +7 の範囲の値を取る。
	; -8(0x8)の時、画面は右に8ドットずれる
	;  0(0x0)の時は、画面は中央に表示される
	; +7(0x7)の時は、画面は左に7ドットずれる
	; 一方、X68000のCRTR #12 は水平スクロール量で
	; -8(0xfff8)の時、画面は右に8ドットずれる
	;  0(0x0000)の時は、画面は中央に表示される
	; +7(0x0007)の時は、画面は左に7ドットずれる
	;となるので、符号拡張してCRTR #12に書き込めばよい
	andi.w	#$000f,d1
	btst.l	#3,d1
	beq	@f		* 正の数
	or.w	#$fff0,d1	* 負の数を符号拡張
@@:	lea.l	CRTR_12,a0
	move.w	d1,(a0)
	move.w	d1,4(a0)
	move.w	d1,8(a0)
	move.w	d1,12(a0)
	; MS.Xでは、set adjustをグラフィック面のX方向のスクロール(CRTR_12)で実現しているが
	; MSXの set adjustは、画面の起点そのものを動かすものなので、グラフィック面だけでなく
	; スプライトも移動してしまう
	; そのため、set adjustの変更があったら、スプライトX座標も調整する必要がある
	; 次回のリフレッシュを待っていると間に合わないので、この場で全スプライトのX座標を
	; 強制的に書き換える
	; 以前の値が0(中央)で、今回が1(左に1ドットスクロール)の場合、全スプライトを左に移動する、
	; つまりスプライトのX座標を1減らす必要がある。ということは (前回)-(今回)を dとして
	; 全てのスプライトにdを足せばよいことになる
	;move.w	#SPRITE_REFRESH_FLAG_COORD,offset_ms_vdp_sprite_refresh_flag(a5)
	andi.w	#$000f,d0	* X方向の値の取り出し(4bit符号付き整数)
	sub.w	d1,d0		* d0 = (前回)-(今回) = d
	andi.w	#$000f,d0
	btst.l	#3,d0
	beq	@f		* 正の数
	or.w	#$fff0,d0	* 負の数を符号拡張
@@:
	lea.l	X68_SSR,a0
	move.w	#128-1,d1
@@:	add.w	d0,(a0)
	lea.l	8(a0),a0
	dbra	d1,@b

	rts

; R#19 はラスタ割り込み番号の指定
w_R19:	move.b	d1,offset_ms_vdp_r19(a5)
	bsr	update_raster_interrupt_line
	rts

update_raster_interrupt_line:
	; CRTC R09 のラスタ割り込み番号を更新
	; R#23 による縦スクロールの影響を受けるので、補正する必要がある
	; 例えば、スクロールオフセットが10のとき走査線割り込み番号が100だと、X68000側の90ライン目で割り込みをかける必要がある
	move.b	offset_ms_vdp_r19(a5),d1
	sub.b	offset_ms_vdp_r23(a5),d1
	andi.w	#$00ff,d1
	; ラスタ番号が画面内に表示される範囲かどうか調べる
	btst.b	#7,offset_ms_vdp_r09(a5)	* R#9の bit7 が画面のライン数
	beq	1f
	; 212ラインの時
	cmpi.w	#212,d0
	bra	2f
1:	; 192ラインの時
	cmpi.w	#192,d0
2:	bge	@f
	; 画面内なので割り込みをかける
	add.w	d1,d1
	addi.w	#39,d1	; 暫定
	move.w	d1,CRTR_09
	rts
@@:	; 画面外なので割り込みをかけない
	move.w	#$1ff,CRTR_09
	rts	

; R#23 は縦スクロール
w_R23:					
	move.b	d1,offset_ms_vdp_r23(a5)
	bsr	ms_vdp_update_visibility_mac
	bsr	update_raster_interrupt_line
	rts

SX_l:	move.b	d1,offset_ms_vdp_sx+1(a5)
	rts
SX_h:	andi.b	#%00000001,d1		* 余計な部分を削除
	move.b	d1,offset_ms_vdp_sx+0(a5)
	rts
SY_l:	move.b	d1,offset_ms_vdp_sy+1(a5)
	rts
SY_h:	move.b	d1,offset_ms_vdp_sy+0(a5)
	rts
DX_l:	move.b	d1,offset_ms_vdp_dx+1(a5)
	rts
DX_h:	move.b	d1,offset_ms_vdp_dx+0(a5)
	rts
DY_l:	move.b	d1,offset_ms_vdp_dy+1(a5)
	rts
DY_h:	move.b	d1,offset_ms_vdp_dy+0(a5)
	rts
NX_l:	move.b	d1,offset_ms_vdp_nx+1(a5)
	rts
NX_h:	move.b	d1,offset_ms_vdp_nx+0(a5)
	rts
NY_l:	move.b	d1,offset_ms_vdp_ny+1(a5)
	rts
NY_h:	move.b	d1,offset_ms_vdp_ny+0(a5)
	rts

w_CLR:	move.b	d1,offset_ms_vdp_clr(a5)
	; 画面モードに応じてVDPコマンドのWRITEを実行
	clr.l	d0
	move.b	d1,d0
	move.l	d0,-(sp)			* 引数に値をセット
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_vdp_command_write(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts

w_ARG:	move.b	d1,offset_ms_vdp_arg(a5)
	rts

w_R46:
	; 画面モードに応じてVDPコマンドの実行処理を呼び出す
	move.l	d1,-(sp)		* 引数にコマンド番号をセット
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_vdp_command_exec(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts


***************************************************************
*
*	R#0とR#2に従い画面モードを切り替えます
*
*		     | M5 | M4 | M3 | M2 | M1 |
*	|SCREEN 0(40)|  0 |  0 |  0 |  0 |  1 |		0x01	TEXT1
*	|SCREEN 0(80)|  0 |  1 |  0 |  0 |  1 |		0x09	TEXT2
*	|SCREEN 1    |  0 |  0 |  0 |  0 |  0 |		0x00
*	|SCREEN 2    |  0 |  0 |  1 |  0 |  0 |		0x04
*	|SCREEN 3    |  0 |  0 |  0 |  1 |  0 |		0x02	MULTICOLOR
*	|SCREEN 4    |  0 |  1 |  0 |  0 |  0 |		0x08
*	|SCREEN 5    |  0 |  1 |  1 |  0 |  0 |		0x0c
*	|SCREEN 6    |  1 |  0 |  0 |  0 |  0 |		0x10
*	|SCREEN 7    |  1 |  0 |  1 |  0 |  0 |		0x14
*	|SCREEN 8    |  1 |  1 |  1 |  0 |  0 |		0x1c
*
***************************************************************
set_CRT:
	; R#0	VDP Mode Register 0
	; 	[ 0 ][ DG][IE2][IE1][ M5][ M4][ M3][ 0 ]
	; R#1	VDP Mode Register 1
	;	[ 0 ][ BL][IE0][ M1][ M2][ 0 ][ SI][MAG]
	clr.w	d0
	move.b	offset_ms_vdp_r00(a5),d0
	; M5,M4,M3を bit4,3,2の位置に
	andi.w	#%00000000_00001110,d0
	lsl.w	#1,d0
	; M1をbit0に
	move.b	offset_ms_vdp_r01(a5),d1
	andi.w	#%00000000_00010000,d1
	lsr.w	#4,d1
	or.w	d1,d0
	; M2をbit1に
	move.b	offset_ms_vdp_r01(a5),d1
	andi.w	#%00000000_00001000,d1
	lsr.w	#2,d1
	or.w	d1,d0

	cmp.b	offset_ms_vdp_crt_mode(a5),d0		* 前と変わってなければ何もしない
	bne	@f
	rts
@@:	move.b	d0,offset_ms_vdp_crt_mode(a5)		* ＣＲＴＭＯＤＥレジスターの更新
	ext.l	d0
	move.l	d0,-(sp)
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	bsr	ms_vdp_set_mode
	lea	8(sp),sp
	rts

set_TEXT1_mac:
	move.l	#s_TEXT1,set_gram_add_rot

	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	movea.l	set_gram_add_rot,a0
	jsr	(a0)

	rts

set_TEXT2_mac:
	move.l	#s_TEXT2,set_gram_add_rot

	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	movea.l	set_gram_add_rot,a0
	jsr	(a0)

	rts

set_MULTICOLOR_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%11111000_11111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%11111111_11111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$11111111,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.l	#s_MULTICOLOR,set_gram_add_rot

	rts


set_GRAPHIC1_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%11111000_11111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%11111111_11111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.l	#s_GRAPHIC1,set_gram_add_rot

	rts

set_GRAPHIC2_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%11111000_11111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%11111111_11111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.l	#s_GRAPHIC2,set_gram_add_rot

	rts

set_GRAPHIC4_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%11111000_11111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%11111111_11111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	add.l	d1,d1
	swap	d1
	andi.w	#%00000000_00000011,d1		* d1 = アクティブページナンバー

	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.l	#s_GRAPHIC4,set_gram_add_rot

	rts

set_GRAPHIC5_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%11111000_11111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%11111111_11111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	add.l	d1,d1
	swap	d1
	andi.w	#%00000000_00000011,d1		* d1 = アクティブページナンバー
	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.l	#s_GRAPHIC5,set_gram_add_rot

	rts

set_GRAPHIC6_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%11111000_11111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%11111111_11111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	swap	d1
	andi.w	#%00000000_00000001,d1		* d1 = アクティブページナンバー
	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.l	#s_GRAPHIC6,set_gram_add_rot

	rts

set_GRAPHIC7_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%11111000_11111111,d0		* 256色モードに
	ori.w	#%00000001_00000000,d0
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%11111111_11111000,d0		* 256色モードに
	ori.w	#%00000000_00000001,d0
	move.w	d0,VCRR_00

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	swap	d1
	andi.w	#%00000000_00000001,d1	* d1 = アクティブページナンバー
	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	ms_vdp_update_visibility_mac

	move.l	#s_GRAPHIC7,set_gram_add_rot

	rts


***************************************************************
*
*	ＧＲＡＭアドレス設定サブルーチン群
*
*	d1.l	・・・ 対応するVRAMアドレス
*
***************************************************************
s_TEXT1:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00000011_11111111,d1		* 上位ワードも０にしたいから.lにしてある
	move.l	d1,d0
	divu.w	#40,d1
	move.w	d1,d0				* d0.l ・・商	y
	lsl.w	#8,d0				* d0.l = d0 * 256	(wordでＯＫ)
	lsl.l	#6,d0				* d0.l = d0 * 64 = y * 1024*16
	swap	d1				* d1.w ・・余り	x
	lsl.w	#3,d1
	move.w	d1,d2				* d2.w = x * 8
	add.w	d1,d1				* d1.w = x * 16
	add.w	d1,d2				* d2.w = x * 24

	add.w	d2,d0				* d0.l = アドレス (word 演算でＯＫ）
	add.l	#$c00000+32,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_TEXT2:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00001111_11111111,d1		* 上位ワードも０にしたいから.lにしてある
	move.l	d1,d0
	divu.w	#80,d1
	move.w	d1,d0				* d0.l ・・商	y
	lsl.w	#8,d0				* d0.l = d0 * 256	(wordでＯＫ)
	lsl.l	#6,d0				* d0.l = d0 * 64 = y * 1024*16
	swap	d1				* d1.w ・・余り	x
	lsl.w	#2,d1
	move.w	d1,d2				* d2.w = x * 4
	add.w	d1,d1				* d1.w = x * 8
	add.w	d1,d2				* d2.w = x * 12

	add.w	d2,d0				* d0.l = アドレス (word 演算でＯＫ）
	add.l	#$c00000+32,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_MULTICOLOR:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	rts

s_GRAPHIC1:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00000011_11111111,d1		* VRAMアドレスの下位10ビットを取得
	; VRAMアドレスを32で割ればライン番号になる
	; それを1024*8倍すると、GRAMのアドレスになる
	; なので、VRAMアドレスを256倍して、下位13ビットをクリアするとGRAMの画面左端アドレスになる
	move.l	d1,d0				* 32で割って1024*8倍 = 256倍
	lsl.l	#8,d0				* d0.w = y * 256
	and.l	#$fffe000,d0			* 下位13ビットをクリア
	; VRAMアドレスを32で割った余りがキャラクタのX座標になる
	; それを8*2倍すると、GRAMのアドレスになる
	andi.w	#%00000000_00011111,d1		* d1.l ・・余り	x
	lsl.w	#4,d1				* d1.l = x * 16
	; 合計するとGRAMアドレスが得られる
	add.l	d1,d0				* d0.l = アドレス
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_GRAPHIC2:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00000011_11111111,d1		* VRAMアドレスの下位10ビットを取得
	; VRAMアドレスを32で割ればライン番号になる
	; それを1024*8倍すると、GRAMのアドレスになる
	; なので、VRAMアドレスを256倍して、下位13ビットをクリアするとGRAMの画面左端アドレスになる
	move.l	d1,d0				* 32で割って1024*8倍 = 256倍
	lsl.l	#8,d0				* d0.w = y * 256
	and.l	#$fffe000,d0			* 下位13ビットをクリア
	; VRAMアドレスを32で割った余りがキャラクタのX座標になる
	; それを8*2倍すると、GRAMのアドレスになる
	andi.w	#%00000000_00011111,d1		* d1.l ・・余り	x
	lsl.w	#4,d1				* d1.l = x * 16
	; 合計するとGRAMアドレスが得られる
	add.l	d1,d0				* d0.l = アドレス
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_GRAPHIC4:					* SCREEN 5 は,16色256*256モードを使う
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	; d1 = VRAMアドレス
	lsl.l	#2,d1				* VRAMの1アドレスは2ピクセル → GRAMの4バイト	
	move.l	d1,d0
	andi.w	#%00000000_00000001_11111100,d1	* d1: X方向のアドレスオフセット
	lsl.l	#1,d0				* X68000の実画面は横512ピクセルなので、Y方向は1024バイト単位
	move.l	d0,d2
	andi.l	#%00000011_11111100_00000000,d0	* d0: Y方向のアドレスオフセット
	lsl.l	#1,d2				* X68000の実画面は縦512ピクセルなので、ページを跨ぐと、1024 * 512 バイト単位
	andi.l	#%00011000_00000000_00000000,d2	* d2: ページのアドレスオフセット
	or.w	d1,d0
	or.l	d2,d0
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts


s_GRAPHIC5:					* SCREEN 6 は,16色512*512モードを使う
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	; d1 = VRAMアドレス
	lsl.l	#3,d1				* 1バイトが4ピクセル → GRAMの8バイト
	move.l	d1,d0
	andi.w	#%00000000_00000011_11111111,d1
	add.l	d0,d0				* 縦方向は一ラインおきになる
	andi.l	#%00011111_11111000_00000000,d0
	or.w	d1,d0
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

*
*	ＳＣＲＥＥＮ７ (512x424)
*
s_GRAPHIC6:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	; d1 = VRAMアドレス
	lsl.l	#2,d1				* 1バイトが2ピクセル → GRAMの4バイト
	move.l	d1,d0
	andi.w	#%00000000_00000011_11111111,d1
	add.l	d0,d0				* 縦方向は一ラインおきになる
	andi.l	#%00001111_11111000_00000000,d0
	or.w	d1,d0
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

*
*	ＳＣＲＥＥＮ８ (256x212)
*
s_GRAPHIC7:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	; d1 = VRAMアドレス
	lsl.l	#1,d1				* 1バイトが1ピクセル → GRAMの2バイト
	move.l	d1,d0
	andi.w	#%00000000_00000001_11111110,d1 * X: 実画面は512で1024バイトあるが、左半分しか使っていないので512バイト
	add.l	d0,d0
	move.l	d0,d2
	andi.l	#%00000011_11111100_00000000,d0 * Y: 右半分を使っていないので1ビットずらす
	lsl.l	#1,d2				* X68000の実画面は縦512ピクセルなので、ページを跨ぐと、1024 * 512 バイト単位
	andi.l	#%00001000_00000000_00000000,d2	* d2: ページのアドレスオフセット
	or.w	d1,d0
	or.l	d2,d0
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_SCREEN10:
s_SCREEN12:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	rts

***************************************************************
*
*	ＶＲＡＭ読み込みルーチン
*
*	d0.b に読みこんだ値を入れて rts
*
***************************************************************

; 以前は、GRAPHIC4以降はX68000のGRAMそのものをVRAMと見なすようにしていたが、
; 今は VRAM用のメモリを別途確保しているので、それを直接読めば良くなった

***************************************************************
*
*	ＶＲＡＭ書き込みルーチン
*
*	d1.b に書き込む値を入れてコール
*
***************************************************************

* デバッグように描画量を削減するためのフラグ
HALFDRAW	.equ	0		* 1:半分のみ描画 0:全て描画
DRAWWIDTH_TX	.equ	6/(HALFDRAW+1)	* １ラインの描画回数
DRAWWIDTH_GR	.equ	8/(HALFDRAW+1)	* １ラインの描画回数
DIFFDRAW	.equ	1		* 1:変更があった時のみ描画 0:全て描画

; w_TEXT1_mac:
; 	move.l	4(sp),d1
; 	movea.l	VideoRAM,a0
; 	move.l	vram_add,d0			* D0 ・・書き込むアドレス
; 	move.b	d1,0(a0,d0.l)			* VRAM へ書き込み
; 	andi.w	#%11111100_00000000,d0		* 下位１０ビットをクリア
; 	cmp.l	R_2_pnametbl_baddr,d0
; 	bne	@f
; 	move.l	d0,-(sp)
; 	move.w	d1,-(sp)
; 	bsr	w_p_name_tx1_mac		* パターンネームテーブルへの書き込み
; 	move.w	(sp)+,d1
; 	move.l	(sp)+,d0
; @@:	andi.w	#%11111000_00000000,d0
; 	cmp.l	R_4_patgentbl_baddr,d0
; 	bne	@f
; 	bsr	w_p_gene_tx1_mac		* パターンジェネレータテーブルへの書き込み
; @@:	move.l	vram_add,d0
; 	move.w	d0,d2
; 	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
; 	andi.w	#%00111111_11111111,d2
; 	andi.w	#%11000000_00000000,d0
; 	or.w	d2,d0
; 	move.l	d0,vram_add
; 	rts

w_p_gene_tx1_mac:
*
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
*
*	rewrite_f_0	.dc.l	0
*	rewrite_f_1	.dc.l	0
*	rewrite_f_2	.dc.l	0
*	rewrite_f_3	.dc.l	0
*	rewrite_f_4	.dc.l	0
*	rewrite_f_5	.dc.l	0
*	rewrite_f_6	.dc.l	0
*	rewrite_f_7	.dc.l	0
*	
	move.w	#0,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	add.w	d1,d1
	add.w	d1,d1
	move.l	0(a0,d1.w),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w)		* rewrite_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*
w_p_name_tx1_mac:
	move.l	4(sp),d1
	move.l	d4,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	movea.l	offset_ms_vdp_gram_addr(a5),a1		* a1.l ・・・ 表示するＧＲＡＭアドレス
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	lea.l	0(a0,d0.l),a0		* a0 = 実パターンジェネレータテーブルアドレス

	clr.w	d0
	move.b	d1,d0
	add.w	d0,d0
	add.w	d0,d0
	add.w	d0,d0
	lea.l	0(a0,d0.w),a0		* a0 = 表示するフォントのアドレス

	move.w	offset_ms_vdp_text_color(a5),d2		* ２ドット同時書き込みするため
	swap	d2
	move.w	offset_ms_vdp_text_color(a5),d2
	move.w	offset_ms_vdp_back_color(a5),d3
	swap	d3
	move.w	offset_ms_vdp_back_color(a5),d3

	moveq.l	#4-1,d0			* ループカウンタ
loop1_put_char:
	move.w	(a0)+,d1		* d1 = フォントデータ


	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*4,a1	* １ライン下げる
	lsl.w	#2,d1

	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*4,a1	* １ライン下げる

	dbra	d0,loop1_put_char

	suba.l	#1024*16-24,a1		* gram_add の更新
	move.l	a1,d0
	andi.w	#$03ff,d0		* 改行したかのチェック
	cmpi.w	#$03e0,d0
	bne	@f
	adda.l	#1024*15+64,a1
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)
	move.l	(sp)+,d4
	rts

; w_TEXT2_mac:
; 	move.l	4(sp),d1
; 	movea.l	VideoRAM,a0
; 	move.l	vram_add,d0			* D0 ・・書き込むアドレス
; 	move.b	d1,0(a0,d0.l)			* VRAM へ書き込み
; 	andi.w	#%11111000_00000000,d0
; 	cmp.l	R_4_patgentbl_baddr,d0
; 	bne	@f
; 	move.l	d0,-(sp)
; 	move.w	d1,-(sp)
; 	bsr	w_p_gene_tx2			* パターンジェネレータテーブルへの書き込み
; 	move.w	(sp)+,d1
; 	move.l	(sp)+,d0
; @@:	andi.w	#%11110000_00000000,d0		* 下位１２ビットをクリア
; 	move.l	R_2_pnametbl_baddr,d0
; 	bne	@f
; 	bsr	w_p_name_tx2			* パターンネームテーブルへの書き込み
; @@:	move.l	vram_add,d0
; 	move.w	d0,d2
; 	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
; 	andi.w	#%00111111_11111111,d2
; 	andi.w	#%11000000_00000000,d0
; 	or.w	d2,d0
; 	move.l	d0,vram_add
; 	rts

w_p_gene_tx2_mac:
*
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
*
	move.w	#1,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	add.w	d1,d1
	add.w	d1,d1
	move.l	0(a0,d1.w),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w)		* rewrite_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*
w_p_name_tx2_mac:
	move.l	4(sp),d1
	move.l	d4,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	movea.l	offset_ms_vdp_gram_addr(a5),a1		* a1.l ・・・ 表示するＧＲＡＭアドレス
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	lea.l	0(a0,d0.l),a0		* a0 = 実パターンジェネレータテーブルアドレス

	clr.w	d0
	move.b	d1,d0
	add.w	d0,d0
	add.w	d0,d0
	add.w	d0,d0
	lea.l	0(a0,d0.w),a0		* a0 = 表示するフォントのアドレス

	move.w	offset_ms_vdp_text_color(a5),d2
	move.w	offset_ms_vdp_back_color(a5),d3

	moveq.l	#4-1,d0			* ループカウンタ
1:
	move.w	(a0)+,d1		* d1 = フォントデータ(2ライン分一度に読む)


	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ(偶数行目)
2:
	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	3f			* 最上位ビットが１でなければ次へ	
*	move.w	d2,1024(a1)		* 前景色を表示
	move.w	d2,(a1)+
	dbra	d4,2b
	bra	@f
3:
*	move.w	d3,1024(a1)		* 背景色を表示
	move.w	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*2,a1	* １ライン下げる
	lsl.w	#2,d1

	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ(奇数行目)
2:
	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	3f			* 最上位ビットが１でなければ次へ	
*	move.w	d2,1024(a1)		* 前景色を表示
	move.w	d2,(a1)+
	dbra	d4,2b
	bra	@f
3:
*	move.w	d3,1024(a1)		* 背景色を表示
	move.w	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*2,a1	* １ライン下げる

	dbra	d0,1b

	suba.l	#1024*16-12,a1		* gram_add の更新
	move.l	a1,d0
	andi.w	#$03ff,d0		* 改行したかのチェック
	cmpi.w	#$03e0,d0		* (16ドットオフセット+6ドットx80文字) * 2バイト = 992 = 0x03e0
	bne	@f
	adda.l	#1024*15+64,a1
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)
	move.l	(sp)+,d4
	rts

w_GRAPHIC1_mac:
	link	a6,#-4
	movem.l	d1-d3/a0-a5,-(sp)

	move.l	8(a6),d1
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むVRAMアドレス
	.if DIFFDRAW=1 ;差分描画の実験
	move.b	0(a0,d0.l),d2
	sub.b	d1,d2
	move.b	d2,-2(a6)			* 差分フラグをセット
	.endif
	move.b	(a0,d0.l),-4(a6)		* 以前の値を保存
	move.b	d1,(a0,d0.l)			* VRAM へ書き込み

; colortbl_baddrと一致していたらカラーテーブルへの書き込み
@@:	andi.w	#%11111111_11000000,d0		* 下位6ビットをクリア
	move.l	offset_ms_vdp_colortbl_baddr(a5),d2
	andi.w	#%11111111_11000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_color_GR1			* カラーテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprattrtbl_baddrと一致していたらスプライトアトリビュートテーブルへの書き込み
@@:	andi.w	#%11111111_10000000,d0		* 下位7ビットをクリア
	move.l	offset_ms_vdp_sprattrtbl_baddr(a5),d2
	andi.w	#%11111111_10000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_attr			* スプライトアトリビュートテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; offset_ms_vdp_pnametbl_baddr(a5)と一致していたらパターンネームテーブルへの書き込み
@@:	andi.w	#%11111100_00000000,d0		* 下位10ビットをクリア
	move.l	offset_ms_vdp_pnametbl_baddr(a5),d2
	andi.w	#%11111100_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分描画の実験
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	@f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_p_name_GR1			* パターンネームテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprpatgentbl_baddrと一致していたらスプライトパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_sprpgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f
	movem.l	d0-d1,-(sp)
	bsr	w_SP_p_gene			* スプライトパターンジェネレータテーブルへの書き込み
	movem.l	(sp)+,d0-d1

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

	* pgentbl_baddr と一致していたらパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分描画の実験
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	@f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_p_gene_GR1			* パターンジェネレータテーブルへの書き込み

@@:	* VRAM書き込みアドレスをインクリメント
9:	move.l	offset_ms_vdp_vram_addr(a5),d0
	move.w	d0,d2
	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
	andi.w	#%00111111_11111111,d2
	andi.w	#%11000000_00000000,d0
	or.w	d2,d0
	move.l	d0,offset_ms_vdp_vram_addr(a5)

	movem.l	(sp)+,d1-d3/a0-a5
	unlk	a6
	rts

w_color_GR1:
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
	move.w	#3,rewrite_screen	* セットした画面モードを入れる

	lea.l	rewrite_f_0,a1
	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000000_00111111,d1
	cmpi.w	#%00000000_00100000,d1	* カラーテーブルの長さは0x001fまでなので、0x0020以上は無視
	bcc	@f
	andi.w	#%00000000_00011111,d1	* d1 ・・ 書き替えたキャラクター番号/8 = 0〜31
	move.w	d1,d2
	andi.w	#%00000000_00011100,d1
	andi.w	#%00000000_00000011,d2
	beq	1f
	cmpi.w	#2,d2
	beq	3f
	bmi	2f
	ori.l	#$ff000000,0(a1,d1.w)
	rts	
1:	ori.l	#$000000ff,0(a1,d1.w)
	rts	
2:	ori.l	#$0000ff00,0(a1,d1.w)
	rts	
3:	ori.l	#$00ff0000,0(a1,d1.w)
@@:	rts	


w_p_gene_GR1:
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
	move.w	#3,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	move.l	0(a0,d1.w*4),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w*4)		* rewrite_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	a0.l ・・・ VRAMのあるアドレス(X68000上)
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*	a1 ・・・・ 次に表示するＧＲＡＭアドレス
*
w_p_name_GR1:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	d4,-(sp)

	.if DIFFDRAW=1 ;差分描画の実験
	move.l	d1,-(sp)
	move.l	offset_ms_vdp_vram_addr(a5),d1
	bsr	s_GRAPHIC1
	move.l	(sp)+,d1
	.endif

	movea.l	offset_ms_vdp_gram_addr(a5),a1		* a1.l ・・・ 表示するＧＲＡＭアドレス

	move.l	offset_ms_vdp_colortbl_baddr(a5),d0	* d0 = カラーテーブルベースアドレス
	andi.w	#%11111111_11000000,d0		* 下位6ビットをクリア
	lea.l	0(a0,d0.l),a2			* a2 = 実カラーテーブルベースアドレス
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	lea.l	0(a0,d0.l),a0			* a0 = 実パターンジェネレータテーブルアドレス

	clr.w	d0
	move.b	d1,d0
	lsl.w	#3,d0
	lea.l	0(a0,d0.w),a0		* a0 = 表示するパターンのアドレス

	lsr.w	#6,d0			* GRAPHIC1は8種類ごとに同じ色 (上で3ビットシフトしているので6ビット動かす)
	clr.w	d3
	move.b	0(a2,d0.w),d3		* d3: 背景色
	move.w	d3,d2			* d2: 前景色
	lsr.w	#4,d2
	andi.w	#%00001111,d3

	moveq.l	#8-1,d0			* Y方向ループカウンタ(8ライン)
3:	move.b	(a0)+,d1		* d1 = フォントデータ

	moveq.l	#DRAWWIDTH_GR-1,d4	*  X方向ループカウンタ(8ドット)
2:	lsl.b	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
	move.w	d2,(a1)+		* 前景色を表示
	bra	@f
1:	move.w	d3,(a1)+		* 背景色を表示
@@:	dbra	d4,2b

	; 次のラインへ
	adda.l	#1024-(DRAWWIDTH_GR*2),a1	* １ライン下げる
	dbra	d0,3b

	; 一つ右の文字へ
	suba.l	#1024*8-(DRAWWIDTH_GR*2),a1	* gram_add が次の文字の位置を指すように更新
	move.l	a1,d0
	andi.w	#$01ff,d0		* 改行したかどうかのチェック
	bne	@f
	adda.l	#1024*8-256*2,a1	* 右端まで達した場合は、実画面512のx=256の位置にいるので、7.5行下げる
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)
	move.l	(sp)+,d4
	rts


w_GRAPHIC2_mac:
	link	a6,#-4
	movem.l	d1-d3/a0-a5,-(sp)

	move.l	8(a6),d1
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0			* D0 ・・書き込むアドレス
	.if DIFFDRAW=1 ;差分描画の実験
	move.b	0(a0,d0.l),d2
	sub.b	d1,d2
	move.b	d2,-2(a6)			* 差分フラグをセット
	.endif
	move.b	(a0,d0.l),-4(a6)		* 以前の値を保存
	move.b	d1,(a0,d0.l)			* VRAM へ書き込み

; sprattrtbl_baddrと一致していたらスプライトアトリビュートテーブルへの書き込み
	andi.w	#%11111111_10000000,d0		* 下位7ビットをクリア
	move.l	offset_ms_vdp_sprattrtbl_baddr(a5),d2
	andi.w	#%11111111_10000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_attr			* スプライトアトリビュートテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; offset_ms_vdp_pnametbl_baddr(a5)と一致していたらパターンネームテーブルへの書き込み
@@:	andi.w	#%11111100_00000000,d0		* 下位10ビットをクリア
	move.l	offset_ms_vdp_pnametbl_baddr(a5),d2
	andi.w	#%11111100_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_p_name_GR2			* パターンネームテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprpatgentbl_baddrと一致していたらスプライトパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_sprpgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_p_gene			* スプライトパターンジェネレータテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; pgentbl_baddr と一致していたらパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11100000_00000000,d0		* 下位13ビットをクリア
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d2
	andi.w	#%11100000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_p_gene_GR2			* パターンジェネレータテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; colortbl_baddrと一致していたらカラーテーブルへの書き込み
@@:	move.l	offset_ms_vdp_colortbl_baddr(a5),d2
	andi.w	#%11100000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_color_GR2			* カラーテーブルへの書き込み

@@:	* VRAM書き込みアドレスをインクリメント
9:	move.l	offset_ms_vdp_vram_addr(a5),d0
	move.w	d0,d2
	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
	andi.w	#%00111111_11111111,d2
	andi.w	#%11000000_00000000,d0
	or.w	d2,d0
	move.l	d0,offset_ms_vdp_vram_addr(a5)

	movem.l	(sp)+,d1-d3/a0-a5
	unlk	a6
	rts

* スプライトアトリビュートテーブルへの書き込み
* d0.b ・・・ 以前の値
* d1.b ・・・ 書き込まれた値
w_SP_attr:
	movem.l	d0-d2,-(sp)
	and.l	#$ff,d0
	and.l	#$ff,d1
	move.l	d0,-(sp)			* 第4引数 以前の値
	move.l	d1,-(sp)			* 第3引数 書き込まれた値
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d0
	sub.l	offset_ms_vdp_sprattrtbl_baddr(a5),d0
	move.l	d0,-(sp)			* 第2引数 オフセット
	move.l	ms_vdp_shared,-(sp)		* 第1引数 構造体のアドレス
	jsr	_write_sprite_attribute
	lea.l	16(sp),sp
	movem.l	(sp)+,d0-d2
	rts

* スプライトカラーテーブルへの書き込み
* d0.b ・・・ 以前の値
* d1.b ・・・ 書き込まれた値
w_SP_color:
	movem.l	d0-d2,-(sp)
	and.l	#$ff,d0
	and.l	#$ff,d1
	move.l	d0,-(sp)			* 第4引数 以前の値
	move.l	d1,-(sp)			* 第3引数 書き込まれた値
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d0
	sub.l	offset_ms_vdp_sprcolrtbl_baddr(a5),d0
	move.l	d0,-(sp)			* 第2引数 オフセット
	move.l	ms_vdp_shared,-(sp)		* 第1引数 構造体のアドレス
	jsr	_write_sprite_color
	lea.l	16(sp),sp
	movem.l	(sp)+,d0-d2
	rts

* スプライトパターンジェネレータテーブルへの書き込み
* d0.b ・・・ 以前の値
* d1.b ・・・ 書き込まれた値
w_SP_p_gene:
	movem.l	d0-d2,-(sp)
	and.l	#$ff,d0
	and.l	#$ff,d1
	move.l	d0,-(sp)			* 第4引数 以前の値
	move.l	d1,-(sp)			* 第3引数 書き込まれた値
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d0
	sub.l	offset_ms_vdp_sprpgentbl_baddr(a5),d0			* オフセット
	move.l	d0,-(sp)			* 第2引数 オフセット
	move.l	ms_vdp_shared,-(sp)		* 第1引数 構造体のアドレス
	jsr	_write_sprite_pattern
	lea.l	16(sp),sp
	movem.l	(sp)+,d0-d2
	rts


w_color_GR2:
	move.w	#4,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00011111_11111111,d1
	cmpi.w	#%00011000_00000000,d1	* カラーテーブルの長さは0x17ffまでなので、0x1800以上は無視 TODO: 192ラインの場合の話なので、212ラインの時は要検討
	bcc	@f
	andi.w	#%00000111_11111111,d1
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５ TODO: ブロック番号を潰しているのでブロックも考慮するようにしたい
	move.w	d1,d2
	andi.l	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	move.l	(a0,d1.w*4),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,(a0,d1.w*4)		* rewrite_f_n へ書き込み
@@:	rts	

w_p_gene_GR2:
	move.w	#4,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.l	#%00011111_11111111,d1	
	cmpi.w	#%00011000_00000000,d1	* パターンジェネレータテーブルの長さは0x17ffまでなので、0x1800以上は無視 TODO: 192ラインの場合の話なので、212ラインの時は要検討
	bcc	@f
	andi.w	#%00000111_11111111,d1
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５ TODO: ブロック番号を潰しているのでブロックも考慮するようにしたい
	move.w	d1,d2
	andi.l	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	move.l	0(a0,d1.w*4),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w*4)		* rewrite_f_n へ書き込み
@@:	rts	

*
*	文字キャラクタ表示
*
*	a0.l ・・・ VRAMのあるアドレス(X68000上)
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*	a1 ・・・・ 次に表示するＧＲＡＭアドレス
*
w_p_name_GR2:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	d4,-(sp)

	.if DIFFDRAW=1 ;差分描画の実験
	move.l	d1,-(sp)
	move.l	offset_ms_vdp_vram_addr(a5),d1
	bsr	s_GRAPHIC2
	move.l	(sp)+,d1
	.endif

	movea.l	offset_ms_vdp_gram_addr(a5),a1	* a1.l ・・・ 表示するＧＲＡＭアドレス

	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むアドレス
	andi.l	#%00000011_00000000,d0		* d0.l ・・書き込むブロック × 0x100
	lsl.l	#3,d0				* d0.l ・・書き込むブロック × 0x800

	move.l	offset_ms_vdp_colortbl_baddr(a5),d3	* d3 = カラーテーブルベースアドレス
	andi.w	#%11100000_00000000,d3
	clr.l	d2
	move.b	d1,d2
	lsl.w	#3,d2			* キャラクタ番号*8
	add.l	d0,d2			* d2 = ブロック番号*0x800 + キャラクタ番号*8
	add.l	d2,d3
	lea.l	0(a0,d3.l),a2		* a2 = 表示するキャラのカラーテーブルアドレス

	move.l	offset_ms_vdp_pgentbl_baddr(a5),d3	* d3 = パターンジェネレータテーブルアドレス
	andi.w	#%11100000_00000000,d3
	add.l	d2,d3
	lea.l	0(a0,d3.l),a0		* a0 = 表示するフォントのアドレス

	moveq.l	#8-1,d0			* Y方向ループカウンタ(8ライン)
3:	move.b	(a0)+,d1		* d1 = フォントデータ
	move.b	(a2)+,d2		* カラーテーブルから色を取得 d2: 前景色 d3: 背景色
	move.w	d2,d3
	lsr.w	#4,d2			* 前景色
	bne	@f
	move.w	#0,d2
@@:	andi.w	#%00001111,d3		* 背景色
	bne	@f
	;move.w	offset_ms_vdp_back_color(a5),d3
	move.w	#0,d3
@@:
	moveq.l	#DRAWWIDTH_GR-1,d4	* X方向ループカウンタ(8ドット)
2:	lsl.b	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
	move.w	d2,(a1)+		* 前景色を表示
	bra	@f
1:	move.w	d3,(a1)+		* 背景色を表示
@@:	dbra	d4,2b

	; 次のラインへ
	adda.l	#1024-(DRAWWIDTH_GR*2),a1
	dbra	d0,3b

	; 一つ右の文字へ
	suba.l	#1024*8-(DRAWWIDTH_GR*2),a1	* gram_add の更新
	move.l	a1,d0
	andi.w	#$01ff,d0		* 改行したかのチェック
	bne	@f
	adda.l	#1024*8-256*2,a1	* 右端まで達した場合は、実画面512のx=256の位置にいるので、7.5行下げる
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)

	move.l	(sp)+,d4
	rts

w_GRAPHIC3_mac:
	bra	w_GRAPHIC2_mac


w_GRAPHIC4_mac:
	link	a6,#-4
	movem.l	d1-d3/a0-a5,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	; GRAMアドレス再計算 （デバッグ用）
	move.l	offset_ms_vdp_vram_addr(a5),d1
	bsr	s_GRAPHIC4

	move.l	8(a6),d1			* d1 : 引数(書き込む値)を取得

	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むアドレス
	.if DIFFDRAW=1 ;差分描画の実験
	move.b	(a0,d0.l),d2
	sub.b	d1,d2
	move.b	d2,-2(a6)			* 差分フラグをセット
	.endif
	move.b	(a0,d0.l),-4(a6)		* 以前の値を保存
	move.b	d1,(a0,d0.l)			* VRAM へ書き込み

; GRAM書き換え
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	@f
	.endif
	move.b	d1,d2
	lsr.w	#4,d2
	move.w	d2,(a0)				* 上位4ビット
	move.w	d2,1024*256(a0)			* 円筒スクロール対応
	move.w	d1,2(a0)			* 下位4ビット
	move.w	d1,1024*256+2(a0)		* 円筒スクロール対応

@@:	lea	4(a0),a0			* GRAMアドレスインクリメント
	move.l	a0,-(sp)

; sprattrtbl_baddrと一致していたらスプライトアトリビュートテーブルへの書き込み
	andi.w	#%11111111_10000000,d0		* 下位7ビットをクリア
	move.l	offset_ms_vdp_sprattrtbl_baddr(a5),d2
	andi.w	#%11111111_10000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_attr			* スプライトアトリビュートテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprcolrtbl_baddrと一致していたらスプライトカラーテーブルへの書き込み
@@:	andi.w	#%11111110_00000000,d0		* 下位9ビットをクリア
	move.l	offset_ms_vdp_sprcolrtbl_baddr(a5),d2
	andi.w	#%11111110_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_color			* スプライトカラーテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprpatgentbl_baddrと一致していたらスプライトパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_sprpgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_p_gene			* スプライトパターンジェネレータテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

@@:	* VRAM書き込みアドレスをインクリメント
9:	move.l	(sp)+,a0

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_01111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	512*2-256*2(a0),a0		* 次のラインへ
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)

	movem.l	(sp)+,d1-d3/a0-a5
	unlk	a6
	rts

w_GRAPHIC5_mac:
	link	a6,#-4
	movem.l	d1-d3/a0-a5,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	; GRAMアドレス再計算 （デバッグ用）
	move.l	offset_ms_vdp_vram_addr(a5),d1
	bsr	s_GRAPHIC5

	move.l	8(a6),d1			* d1 : 引数(書き込む値)を取得

	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むアドレス
	.if DIFFDRAW=1 ;差分描画の実験
	move.b	(a0,d0.l),d2
	sub.b	d1,d2
	move.b	d2,-2(a6)			* 差分フラグをセット
	.endif
	move.b	(a0,d0.l),-4(a6)		* 以前の値を保存
	move.b	d1,(a0,d0.l)			* VRAM へ書き込み

; GRAM書き換え
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	@f
	.endif

	move.b	d1,d2
	andi.w	#%11000000,d2
	lsr.w	#6,d2
	move.w	d2,(a0)

	move.b	d1,d2
	andi.w	#%00110000,d2
	lsr.w	#4,d2
	move.w	d2,2(a0)

	move.b	d1,d2
	andi.w	#%00001100,d2
	lsr.w	#2,d2
	move.w	d2,4(a0)

	move.b	d1,d2
	andi.w	#%00000011,d2
	move.w	d2,6(a0)

@@:	lea	8(a0),a0			* GRAMアドレスインクリメント
	move.l	a0,-(sp)

; sprattrtbl_baddrと一致していたらスプライトアトリビュートテーブルへの書き込み
	andi.w	#%11111111_10000000,d0		* 下位7ビットをクリア
	move.l	offset_ms_vdp_sprattrtbl_baddr(a5),d2
	andi.w	#%11111111_10000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_attr			* スプライトアトリビュートテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprcolrtbl_baddrと一致していたらスプライトカラーテーブルへの書き込み
@@:	andi.w	#%11111110_00000000,d0		* 下位9ビットをクリア
	move.l	offset_ms_vdp_sprcolrtbl_baddr(a5),d2
	andi.w	#%11111110_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_color			* スプライトカラーテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprpatgentbl_baddrと一致していたらスプライトパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_sprpgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_p_gene			* スプライトパターンジェネレータテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

@@:	* VRAM書き込みアドレスをインクリメント
9:	move.l	(sp)+,a0

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_01111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)

	movem.l	(sp)+,d1-d3/a0-a5
	unlk	a6
	rts

w_GRAPHIC6_mac:
	link	a6,#-4
	movem.l	d1-d3/a0-a5,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	; GRAMアドレス再計算 （デバッグ用）
	move.l	offset_ms_vdp_vram_addr(a5),d1
	bsr	s_GRAPHIC6

	move.l	8(a6),d1			* d1 : 引数(書き込む値)を取得

	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むアドレス
	.if DIFFDRAW=1 ;差分描画の実験
	move.b	(a0,d0.l),d2
	sub.b	d1,d2
	move.b	d2,-2(a6)			* 差分フラグをセット
	.endif
	move.b	(a0,d0.l),-4(a6)		* 以前の値を保存
	move.b	d1,(a0,d0.l)			* VRAM へ書き込み

; GRAM書き換え
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	@f
	.endif

	move.b	d1,d2
	lsr.w	#4,d2
	move.w	d2,0(a0)			* 上位4ビット(左側ピクセル)の書き込み
	move.w	d1,2(a0)			* 下位4ビット(右側ピクセル)の書き込み

@@:	lea	4(a0),a0			* GRAMアドレスインクリメント
	move.l	a0,-(sp)

; sprattrtbl_baddrと一致していたらスプライトアトリビュートテーブルへの書き込み
	andi.w	#%11111111_10000000,d0		* 下位7ビットをクリア
	move.l	offset_ms_vdp_sprattrtbl_baddr(a5),d2
	andi.w	#%11111111_10000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_attr			* スプライトアトリビュートテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprcolrtbl_baddrと一致していたらスプライトカラーテーブルへの書き込み
@@:	andi.w	#%11111110_00000000,d0		* 下位9ビットをクリア
	move.l	offset_ms_vdp_sprcolrtbl_baddr(a5),d2
	andi.w	#%11111110_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_color			* スプライトカラーテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprpatgentbl_baddrと一致していたらスプライトパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_sprpgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_p_gene			* スプライトパターンジェネレータテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

@@:	* VRAM書き込みアドレスをインクリメント
9:	move.l	(sp)+,a0

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_11111111,d1	* ライン境界をまたいだか (GRAPHIC6は1ライン256バイト)
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)

	movem.l	(sp)+,d1-d3/a0-a5
	unlk	a6
	rts
	
w_GRAPHIC7_mac:
	link	a6,#-4
	movem.l	d1-d3/a0-a5,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	; GRAMアドレス再計算 （デバッグ用）
	move.l	offset_ms_vdp_vram_addr(a5),d1
	bsr	s_GRAPHIC7

	move.l	8(a6),d1			* d1 : 引数(書き込む値)を取得

	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むアドレス
	.if DIFFDRAW=1 ;差分描画の実験
	move.b	(a0,d0.l),d2
	sub.b	d1,d2
	move.b	d2,-2(a6)			* 差分フラグをセット
	.endif
	move.b	(a0,d0.l),-4(a6)		* 以前の値を保存
	move.b	d1,(a0,d0.l)			* VRAM へ書き込み

; GRAM書き換え
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	@f
	.endif
	move.w	d1,0(a0)
	move.w	d1,1024*256(a0)			* 円筒スクロール対応

@@:	lea	2(a0),a0			* GRAMアドレスインクリメント
	move.l	a0,-(sp)

; sprattrtbl_baddrと一致していたらスプライトアトリビュートテーブルへの書き込み
	andi.w	#%11111111_10000000,d0		* 下位7ビットをクリア
	move.l	offset_ms_vdp_sprattrtbl_baddr(a5),d2
	andi.w	#%11111111_10000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_attr			* スプライトアトリビュートテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprcolrtbl_baddrと一致していたらスプライトカラーテーブルへの書き込み
@@:	andi.w	#%11111110_00000000,d0		* 下位9ビットをクリア
	move.l	offset_ms_vdp_sprcolrtbl_baddr(a5),d2
	andi.w	#%11111110_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_color			* スプライトカラーテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

; sprpatgentbl_baddrと一致していたらスプライトパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_sprpgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f

	.if DIFFDRAW=1 ;差分がある時のみ書き込み
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	9f
	.endif

	move.b	-4(a6),d0			* 以前の値を取得
	bsr	w_SP_p_gene			* スプライトパターンジェネレータテーブルへの書き込み

	bra	9f	; テーブルが重なっている場合もありうるので本当はスキップしてはいけないのだが……

@@:	* VRAM書き込みアドレスをインクリメント
9:	move.l	(sp)+,a0

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_11111111,d1	* ライン境界をまたいだか (GRAPHIC7は1ライン256バイト)
	bne	@f
	lea.l	512*2-256*2(a0),a0		* 次のラインへ
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)

	movem.l	(sp)+,d1-d3/a0-a5
	unlk	a6
	rts
	

*
* VDP コマンド
*

*
*	Ｐｓｅｔ
*
PSET_G4:
	bsr	get_D_gram_add_G4
	move.b	offset_ms_vdp_clr(a5),d0
	andi.w	#%00000011,d0
	move.w	d0,(a0)

	rts

PSET_G5:
	bsr	get_D_gram_add_G5
	move.b	offset_ms_vdp_clr(a5),d0
	andi.w	#%00000011,d0
	move.w	d0,(a0)

	rts

*
*	Ｌｉｎｅ	適当バージョン
*
LINE_G5:
	movem.l	d4-d6,-(sp)

	andi.w	#%00000000_00001111,d1

	bsr	get_D_gram_add_G5	* 始点のＧＲＡＭアドレス（DX,DYから求める）

	move.b	offset_ms_vdp_arg(a5),d1
	bclr.l	#0,d1			* MAJ のテスト
	bne	9f			* 長辺がＹ方向の時

	move.w	offset_ms_vdp_ny(a5),d5
*	subq.w	#1,d5			* d5 = Ｙ方向の長さ
	
	move.w	offset_ms_vdp_nx(a5),d2		* d2 = 長辺ドット数
*	subq.w	#1,d2			* d2 = Ｘ方向の長さ

	bclr.l	#2,d1			* DIX を調べる
	bne	1f
	move.l	#2,d0
	bra	@f
1:	move.l	#-2,d0
@@:	bclr.l	#3,d1			* DIY を調べる
	bne	1f
	move.l	#1024*2,d1
	add.w	d5,offset_ms_vdp_dy(a5)
	bra	@f
1:	move.l	#-1024*2,d1
	sub.w	d5,offset_ms_vdp_dy(a5)
@@:
	move.b	offset_ms_vdp_clr(a5),d6		* color
	andi.w	#%00000011,d6

	move.w	d2,d4
	neg.w	d4			* d4 = 誤差情報初期値

	move.w	d2,d3			* d3 = ループカウンタ
	add.w	d2,d2			* d2 = 誤差情報修正値
1:
	move.w	d6,(a0)
*	move.w	d6,1024(a0)
	adda.l	d0,a0

	add.w	d5,d4
	bmi	@f
	sub.w	d2,d4	
	adda.l	d1,a0
@@:	dbra	d3,1b

	movem.l	(sp)+,d4-d6

	rts

9:
	movem.l	(sp)+,d4-d6
	rts

*
*	ＬＭＭＣ
*
LMMC_G5:
	movem.l	d4-d6,-(sp)

	andi.w	#%00000000_00001111,d1	* d1 = ロジカルオペレーション

	ori.b	#%00000001,offset_ms_vdp_s02(a5)		* CE を０ に

	bsr	get_D_gram_add_G5	* 始点のＧＲＡＭアドレス（DX,DYから求める）
	movea.l	d0,a0

	move.w	offset_ms_vdp_ny(a5),d5
	move.w	offset_ms_vdp_nx(a5),d2
	
	move.b	offset_ms_vdp_arg(a5),d1
	bclr.l	#2,d1			* DIX を調べる
	bne	1f
	move.l	#2,d0
	bra	@f
1:	move.l	#-2,d0
@@:	andi.b	#%00001000,d1		* DIY を調べる
	bne	1f
	move.l	#1024*2,d1
	move.w	offset_ms_vdp_dy(a5),d6
	add.w	d5,d6
	move.w	d6,NEXT_DY		* コマンド終了時のDYを設定
	bra	@f
1:	move.l	#-1024*2,d1
	move.w	offset_ms_vdp_dy(a5),d6
	add.w	d5,d6
	move.w	d6,NEXT_DY		* コマンド終了時のDYを設定
@@:
	move.b	offset_ms_vdp_clr(a5),d6		* color
	andi.w	#%00000011,d6

	move.l	a0,g_add_2

	move.w	d6,(a0)

	adda.l	d0,a0
	subq.w	#1,d2			* loop_x -= 1
	bne	@f
	add.l	d1,g_add_2
	move.l	g_add_2,a0
	move.w	offset_ms_vdp_nx(a5),d2		* loop_x 再設定
	subq.w	#1,d5
	bne	@f

	andi.b	#%11111110,offset_ms_vdp_s02(a5)		* コマンド終了
	move.w	NEXT_DY,offset_ms_vdp_dy(a5)
	move.l	#w_CLR,MC_add

	movem.l	(sp)+,d4-d6

	rts

@@:	move.w	d5,loop_y
	move.w	d2,loop_x
	move.l	a0,g_add
	move.l	d0,add_x
	move.l	d1,add_y

	move.l	#DO_LMMC_G5,MC_add

	movem.l	(sp)+,d4-d6

	rts

DO_LMMC_G5:
	andi.w	#%00000011,d1
	move.l	g_add,a0

	move.w	d1,(a0)

	adda.l	add_x,a0
	subq.w	#1,loop_x		* loop_x -= 1
	bne	@f
	move.l	add_y,d1
	add.l	d1,g_add_2
	move.l	g_add_2,a0
	move.w	offset_ms_vdp_nx(a5),loop_x		* loop_x 再設定
	subq.w	#1,loop_y
	bne	@f

	andi.b	#%11111110,offset_ms_vdp_s02(a5)		* コマンド終了
	move.w	NEXT_DY,offset_ms_vdp_dy(a5)
	move.l	#w_CLR,MC_add
	rts

@@:	move.l	a0,g_add
	rts
	

	.data

loop_x:	.dc.w	0
loop_y:	.dc.w	0
g_add:	.dc.l	0
g_add_2:
	.dc.l	0			* Ｙ方向のループの時に使う


add_x:	.dc.l	0			* アドレスのＸ方向増分
add_y:	.dc.l	0			* アドレスのＹ方向増分

NEXT_DY:
	.dc.w	0

	.text

***************************************************************
*
*	サブルーチン
*
***************************************************************
*
*	ＳＸ，ＳＹからＧＲＡＭアドレスを求める
*
*	(返り値)
*		a0.l	求めたアドレス
*
get_S_gram_add_G5:
	move.w	offset_ms_vdp_sy(a5),d0
	andi.l	#%00000011_11111111,d0
	add.w	#$00c0*32,d0		* gram base add
	swap	d0
	lsr.l	#5,d0			* d0.l = $c00000 + SY * 2048
	add.w	offset_ms_vdp_sx(a5),d0		* ワードでＯＫ
	add.w	offset_ms_vdp_sx(a5),d0		* d0.1 = $c00000 + SY * 2048 + SX * 2
	movea.l	d0,a0
	rts

*
*	ＤＸ，ＤＹからＧＲＡＭアドレスを求める
*
*	(返り値)
*		a0.l	求めたアドレス
*
get_D_gram_add_G4:
	move.w	offset_ms_vdp_dy(a5),d0
	andi.l	#%00000011_11111111,d0
	add.w	#$00c0*32,d0		* gram base add
	swap	d0
	lsr.l	#5,d0			* d0.l = $c00000 + DY * 2048
	movea.l	d0,a0
	move.w	offset_ms_vdp_dx(a5),d0		* ワードでＯＫ
	add.w	d0,d0
	add.w	d0,d0
	adda.w	d0,a0			* a0.l = $c00000 + DY * 2048 + DX * 4
	rts

get_D_gram_add_G5:
	move.w	offset_ms_vdp_dy(a5),d0
	andi.l	#%00000011_11111111,d0
	add.w	#$00c0*32,d0		* gram base add
	swap	d0
	lsr.l	#5,d0			* d0.l = $c00000 + DY * 2048
	add.w	offset_ms_vdp_dx(a5),d0		* ワードでＯＫ
	add.w	offset_ms_vdp_dx(a5),d0		* d0.l = $c00000 + DY * 2048 + DX * 2
	movea.l	d0,a0
	rts

***************************************************************
*
*	線分描画（整数化Bresenham＋両端描画）
*
*
***************************************************************

	.data

	.offset	0	*glineの引数構造
*
*X0:	.ds.w	1	*始点座標
*Y0:	.ds.w	1	*
*X1:	.ds.w	1	*終点座標
*Y1:	.ds.w	1	*
*COL:	.ds.w	1	*描画色
*
	.text
	.even
*
_xorline:
ARGPTR	=	4+8*4+6*4
	movem.l	d0-d7/a0-a5,-(sp)

*	bsr	set_apage

	movea.l	ARGPTR(sp),a5	*a5 = 引数列
	movem.w	(a5)+,d0-d3	*d0〜d3に座標を取り出す

 	cmp.w	d2,d0		*x0≦x1を保証する
	ble	gline0		*
	exg.l	d0,d2		*
	exg.l	d1,d3		*

gline0:	move.w	d1,d6		*始点/終点のG-RAMアドレスを求める
	move.w	d3,d7		*
	ext.l	d6		*
	ext.l	d7		*
				*
*	moveq.l	#GSFTCTR,d4	*
	asl.l	d4,d6		*
	asl.l	d4,d7		*
	add.w	d0,d6		*
	add.w	d0,d6		*
	add.w	d2,d7		*
	add.w	d2,d7		*
				*
*	movea.l	gbase,a0	*
	movea.l	a0,a2		*
	add.l	d6,a0		*a0 = 始点のG-RAMアドレス
	add.l	d7,a2		*a2 = 終点のG-RAMアドレス

*	move.w	#GNBYTE,d5	*d5 = 横1ライン分のバイト数
	sub.w	d1,d3		*d3 = y1-y0
	beq	hor_line	*y0＝y1なら水平線
	bpl	gline1
	neg.w	d3
	neg.w	d5
gline1:	sub.w	d0,d2		*d2 = x1-x0 ( >=0 )
	beq	ver_line	*x0＝x1なら垂直線
*この時点で
*	d2 = dx = abs(x1-x0) ( > 0 )
*	d3 = dy = abs(y1-y0) ( > 0 )
*	d5 = sy = sgn(y1-y0) ( -1 or 1 )
*	（ただしd5はGNBYTE倍済み）

	move.w	(a5),d0		*d0 = 描画色

	cmp.w	d3,d2		*dy＞dxならば
	bcs	yline		*　yについてループ
	beq	xyline		*dy＝dxならば45度の線

			*dx≧dyのとき
xline:	move.w	d2,d1		*d1 = dx
	neg.w	d1		*d1 = e = -dx
	move.w	d2,d6		*d6 = n = dx
	add.w	d2,d2		*d2 = 2*dx
	add.w	d3,d3		*d3 = 2*dy
	subq.w	#1,d6		*dbraの動作を計算に入れて
	lsr.w	#1,d6		*　ループカウンタを半減
	scs.b	d4		*奇数ピクセルのとき非0
	addq.l	#2,a2		*プリデクリメントする分補正
				*do {
xline0:	eor.w	d0,(a0)+	*  pset(x++,y)
	eor.w	d0,-(a2)	*  pset(--x',y')
	add.w	d3,d1		*  e += 2*dy
	bmi	xline1		*  if (e >= 0) {
	adda.w	d5,a0		*    y += sy
	suba.w	d5,a2		*    y'-= sy
	sub.w	d2,d1		*    e -= 2*dx
				*  }
xline1:	dbra	d6,xline0	*} while (--n >= 0)

	tst.b	d4		*奇数ピクセル？
	beq	done		*　そうじゃない
	bra	odd		*中央のピクセルを点灯

			*dx＜dyのとき
yline:	move.w	d3,d1		*d1 = dy
	neg.w	d1		*d1 = e = -dy
	move.w	d3,d6		*d6 = n = dy
	add.w	d2,d2		*d2 = 2*dx
	add.w	d3,d3		*d3 = 2*dy
	subq.w	#1,d6		*dbraのことを計算に入れて
	lsr.w	#1,d6		*　ループカウンタを半減
	scs.b	d4		*奇数ピクセルのとき非0
	move.w	d5,d7		*d7 = d5 + 2
	addq.w	#2,d7		*
				*do {
yline0:	add.w	d2,d1		*  e += 2*dx
	bpl	yline1		*  if (e < 0) {
	eor.w	d0,(a0)		*    pset(x,y)
	adda.w	d5,a0		*    y += sy
	eor.w	d0,(a2)		*    pset(x',y')
	suba.w	d5,a2		*    y'-= sy
				*  }
	dbra	d6,yline0
	bra	done0
				*  else {
yline1:	eor.w	d0,(a0)+	*    pset(x++,y)
	adda.w	d5,a0		*    y += sy
	eor.w	d0,(a2)		*    pset(x',y')
	suba.w	d7,a2		*    x'--, y'-= sy
	sub.w	d3,d1		*    e -= 2*dy
				*  }
	dbra	d6,yline0	*} while (--n >= 0)

done0:	tst.b	d4		*奇数ピクセル？
	beq	done		*　そうじゃない
odd:	eor.w	d0,(a0)		*中央のピクセルを点灯

done:	movem.l	(sp)+,d0-d7/a0-a5
	rts
*
hor_line:		*水平線分
	sub.w	d0,d2		*d2 = dx = x1-x0
	move.w	(a5),d0		*d0 = 描画色
hloop:	eor.w	d0,(a0)+	*pset(x++,y)
	dbra	d2,hloop
	bra	done

xyline:			*45度の線分
	addq.w	#2,d5		*d5 = 2±GNBYTE
ver_line:		*垂直線分
	move.w	(a5),d0		*d0 = 描画色
vloop:	eor.w	d0,(a0)		*pset(x,y)
	adda.w	d5,a0		*y += sx
	dbra	d3,vloop	*dy+1回繰り返す
	bra	done

**************************************************************
*
*		ワークエリア
*
**************************************************************

	.data
	.even

set_gram_add_rot:
	.dc.l	s_TEXT1

w_ContReg_mode:				* ポート＃１は２バイトひとかたまりでアクセス
	.dc.w	0			* するので、１バイト目か２バイト目かの区別を
					* するためのもの
					* ０・・１バイト目
					* １・・２バイト目
first_bite_1:				* １バイト目にどんな値が書き込まれたのかが
	.dc.b	0			* 入っている

w_PalReg_mode:
	.dc.b	0
first_bite_2:
	.dc.b	0

	.even

rewrite_screen:
		.dc.w	$ffff		* 下の rewrite_f をどの画面モードがセットしたか
					* が入る。垂直帰線期間の時に現在の画面モードと比
					* 較して、違う時にはrewrite_fをすべてクリアして
					* 何もしない。
					*  $ffff が入っている時は何も変更されていないこ
					* とを示す。

*	ＳＣＲＥＥＮ０，２，４で使う
ms_vdp_rewrite_flag_tbl:
		.dc.l	rewrite_f_0

rewrite_f_0:	.dc.l	0
rewrite_f_1:	.dc.l	0
rewrite_f_2:	.dc.l	0
rewrite_f_3:	.dc.l	0
rewrite_f_4:	.dc.l	0
rewrite_f_5:	.dc.l	0
rewrite_f_6:	.dc.l	0
rewrite_f_7:	.dc.l	0


; *	------ ＶＤＰ Ｒｅｇｉｓｔｅｒｓ ------
; ms_vdp:				* 構造体の先頭アドレス
; *	コントロールレジスタ
; Control_registers:
; R_00:	.dc.b	0		* Mode register 0

; VDP_R_01:
; R_01:	.dc.b	0		* Mode register 1
; R_02:	.dc.b	0
; R_03:	.dc.b	0
; R_04:	.dc.b	0
; R_05:	.dc.b	0
; R_06:	.dc.b	0		* Sprite
; R_07:	.dc.b	0
; R_08:	.dc.b	0		* Mode register 2
; R_09:	.dc.b	0		* Mode register 3
; R_10:	.dc.b	0		* >> R#3
; R_11:	.dc.b	0		* >> R#5
; R_12:	.dc.b	0		* TEXT color / Back color register (ブリンクで使用）
; R_13:	.dc.b	0
; R_14:	.dc.b	0		* >> vram_add
; R_15:	.dc.b	0
; R_16:	.dc.b	0		* Color Palette Address pointer
; R_17:	.dc.b	0		* Control Register pointer
; R_18:	.dc.b	0
; R_19:	.dc.b	0
; R_20:	.dc.b	0
; R_21:	.dc.b	0
; R_22:	.dc.b	0
; R_23:	.dc.b	0
; R_24:	.dc.b	0
; R_25:	.dc.b	0
; R_26:	.dc.b	0
; R_27:	.dc.b	0
; 	.dc.b	0		* dummy
; 	.dc.b	0		* dummy
; 	.dc.b	0		* dummy
; 	.dc.b	0		* dummy
; SX:	.dc.w	0		* 32,33 並びが逆になるので注意
; SY:	.dc.w	0		* 34,35
; DX:	.dc.w	0		* 36,37
; DY:	.dc.w	0		* 38,39
; NX:	.dc.w	0		* 40,41
; NY:	.dc.w	0		* 42,43
; CLR:	.dc.b	0
; ARG:	.dc.b	0
; R_46:	.dc.b	0

; 	.dc.b	0		* dummy

; *	ステータスレジスタ
; VDP_S_00:
; S_0:	.dc.b	0
; S_1:	.dc.b	%00000100		* V9958 のＩＤ
; S_2:	.dc.b	%10001100		* TR は常に１
; S_3:	.dc.b	0
; S_4:	.dc.b	%11111110
; S_5:	.dc.b	0
; S_6:	.dc.b	%11111100
; S_7:	.dc.b	0
; S_8:	.dc.b	0
; S_9:	.dc.b	%11111100

; 	.even

; *	パレットレジスタ
; *		%GGGG_GRRR_RRBB_B001
; *P_0:	.dc.w	%0000_0000_0000_0000
; *P_1:	.dc.w	%0000_0000_0000_0000
; *P_2:	.dc.w	%0000_0000_0000_0000
; *P_3:	.dc.w	%0000_0000_0000_0000
; *P_4:	.dc.w	%0000_0000_0000_0000
; *P_5:	.dc.w	%0000_0000_0000_0000
; *P_6:	.dc.w	%0000_0000_0000_0000
; *P_7:	.dc.w	%0000_0000_0000_0000
; *P_8:	.dc.w	%0000_0000_0000_0000
; *P_9:	.dc.w	%0000_0000_0000_0000
; *P_10:	.dc.w	%0000_0000_0000_0000
; *P_11:	.dc.w	%0000_0000_0000_0000
; *P_12:	.dc.w	%0000_0000_0000_0000
; *P_13:	.dc.w	%0000_0000_0000_0000
; *P_14:	.dc.w	%0000_0000_0000_0000
; *P_15:	.dc.w	%0000_0000_0000_0000

; P_0:	.dc.w	%0000_0000_0000_0000
; P_1:	.dc.w	%0000_0000_0000_0000
; P_2:	.dc.w	%1101_1001_0000_1001
; P_3:	.dc.w	%1111_1011_0101_1011
; P_4:	.dc.w	%0010_0001_0011_1111
; P_5:	.dc.w	%0110_1010_0111_1111
; P_6:	.dc.w	%0010_0101_1000_1001
; P_7:	.dc.w	%1101_1010_0111_1111
; P_8:	.dc.w	%0010_0111_1100_1001
; P_9:	.dc.w	%0110_1111_1101_1011
; P_10:	.dc.w	%1101_1110_1100_1001
; P_11:	.dc.w	%1101_1110_1110_0101
; P_12:	.dc.w	%1001_0001_0000_1001
; P_13:	.dc.w	%0100_1110_1110_1101
; P_14:	.dc.w	%1011_0101_1010_1101
; P_15:	.dc.w	%1111_1111_1111_1111

; *	.dc.w	%00000			* 0
; *	.dc.w	%00100
; *	.dc.w	%01001
; *	.dc.w	%01101			* 3
; *	.dc.w	%10010			* 4
; *	.dc.w	%10110
; *	.dc.w	%11011
; *	.dc.w	%11111			* 7

; *	特殊コントロールレジスタ
; * R_00:	.dc.b	0		* [ 0 ][ DG][IE2][IE1][ M5][ M4][ M3][ 0 ]
; * R_01:	.dc.b	0		* [ 0 ][ BL][IE0][ M1][ M2][ 0 ][ SI][MAG]	

; CRT_mode:			* R_0,R_1の[ M5]〜[ M0]
; 	.dc.b	0		* M5〜M0 がそれぞれビット５〜０に入っている
; _sprite_size:			* R_1の[ SI]
; 	.dc.b	0		* スプライトのサイズ ０・・８×８  １・・１６×１６
; sprite_zoom:			* R_1の[MAG]
; 	.dc.b	0		* スプライトの拡大   ０・・なし    １・・あり

; 	.even

; R_2_pnametbl_baddr:
; 	.dc.l	0		* Pattern name table base address
; R_3_colortbl_baddr:
; 	.dc.l	0		* Color table base address
; R_4_patgentbl_baddr:
; 	.dc.l	$0800		* Pattern generator table base address
; R_5_sprattrtbl_baddr:
; 	.dc.l	0		* Sprite attribute table bse address
; R_6_sprpatgentbl_baddr:
; 	.dc.l	0		* Sprite pattern generator table base address
; ;R_7:				  Text color / Back drop color register
; text_color:			* 文字の色
; 	.dc.w	0
; back_color:			* 背景の色
; 	.dc.w	0


; *	ＶＲＡＭアクセスアドレス
; vram_add:			* 
; 	.dc.l	0
; gram_add:
; 	.dc.l	$C00000		* gramのvram_addに対応するアドレス
; 				* 

; *	現在の画面モード
; display_mode:
; 	.dc.w	0		* 0 ・・・ TEXT1
; 				* 1 ・・・ TEXT2
; 				* 2 ・・・ multi color
; 				* 3 ・・・ GRAPHIC1
; 				* 4 ・・・ GRAPHIC2
; 				* 5 ・・・ GRAPHIC3
; 				* 6 ・・・ GRAPHIC4
; 				* 7 ・・・ GRAPHIC5
; 				* 8 ・・・ GRAPHIC6
; 				* 9 ・・・ GRAPHIC7
; 				*10 ・・・ SCREEN10
; 				*11 ・・・ SCREEN12
; *
; *	画面モード
; *	MMMMM
; *	54321
; *
; *	00000		GRAPHIC1
; *	00001		TEXT1
; *	00010		multicolor
; *	00100		GRAPHIC2
; *	01000		GRAPHIC3
; *	01001		TEXT2
; *	01100		GRAPHIC4
; *	10000		GRAPHIC5
; *	10100		GRAPHIC6
; *	11100		GRAPHIC7

; ; テキスト画面の表示 ON/OF (0:OFF 1:ON)
; tx_active:
; 	.dc.w	1
; ; MSXの画面の表示状態を勘案し、X68000の表示するグラフィックページ番号(0:OFF, 0x1-0xf:対応するページのビットを1にする)
; gr_active:
; 	.dc.w	1

; ; X68000側に確保したVRAMの先頭アドレス
; VideoRAM:
; 	.dc.l	0		* ＶＲＡＭのアドレス


; *gbase:	.dc.l	GPAGE0		* ラインルーチン内等で使用

; cliprect:
; 	.dc.w	0		*クリッピング領域
; 	.dc.w	0		*
; *	.dc.w	GNPIXEL-1	*
; *	.dc.w	GNPIXEL-1	*
; ucliprect:
; 	.dc.w	$8000		*クリッピング領域
; 	.dc.w	$8000		*（$8000のゲタ履き）
; *	.dc.w	$8000+GNPIXEL-1	*
; *	.dc.w	$8000+GNPIXEL-1	*


; fillptr:
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	255		* color

; pointptr:
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	0		* return color code

	.even

filebuf:
	.ds.b	53 

errmes_file:
	.dc.b	"ファイルエラーです",$0d,$0a,$00
errmes_memory:
	.dc.b	"メモリが確保できません",$0d,$0a,$00

mes_screen:
	.dc.b	'ＳＣＲＥＥＮを'
num:	.dc.b	'1'
	.dc.b	'にしました。',0xd,0xa,0


number:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00

mes_w_GR1:
	.dc.b	'SCREEN1に書き込みました。',0x0d,0x0a,0x00

	.even

	.end

