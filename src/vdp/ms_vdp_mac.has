*
*	Ｍｓｘ Ｓｉｍｕｌａｔｅｒ
*
*		[[[ ＶＤＰ Ｓｉｍｕｌａｔｅｒ ]]]		
*
*				1995.9.24		by Kuni.
*

	.include	iocscall.mac
	.include	doscall.mac

	.xref	ms_vdp_shared
	.xref	_write_sprite_pattern
	.xref	_write_sprite_attribute
	.xref	_update_sprite_visibility
	.xref	HEX

	.xref	cpu_emu_yield
	.xref	cpu_yield
	.xref	emu_yield
	.xref	host_delay

	.xref	ms_vdp_set_mode

	;.xdef	ms_vdp
	; functions
	.xdef	ms_vdp_init_mac
	.xdef	ms_vdp_deinit_mac

	.xdef	set_TEXT1_mac
	.xdef	set_TEXT2_mac
	.xdef	set_MULTICOLOR_mac
	.xdef	set_GRAPHIC1_mac
	.xdef	set_GRAPHIC2_mac
	.xdef	set_GRAPHIC3_mac
	.xdef	set_GRAPHIC4_mac
	.xdef	set_GRAPHIC5_mac
	.xdef	set_GRAPHIC6_mac
	.xdef	set_GRAPHIC7_mac

	.xdef	w_GRAPHIC1_mac
	.xdef	w_GRAPHIC2_mac
	.xdef	w_GRAPHIC3_mac
	.xdef	w_GRAPHIC4_mac
	.xdef	w_GRAPHIC5_mac
	.xdef	w_GRAPHIC6_mac
	.xdef	w_GRAPHIC7_mac

	.xdef	r_GRAPHIC4_mac
	.xdef	r_GRAPHIC5_mac
	.xdef	r_GRAPHIC6_mac
	.xdef	r_GRAPHIC7_mac

	.xdef	w_p_name_tx1_mac
	.xdef	w_p_gene_tx1_mac
	.xdef	w_p_name_tx2_mac
	.xdef	w_p_gene_tx2_mac

	.xdef	read_vdp_0
	.xdef	read_vdp_1
	.xdef	read_vdp_2
	.xdef	read_vdp_3
	.xdef	write_vdp_0
	.xdef	write_vdp_1
	.xdef	write_vdp_2
	.xdef	write_vdp_3

	.xref	ms_vdp_int
	.xdef	ms_vdp_interrupt_tick
	.xdef	ms_vdp_vsync_rate
	.xdef	ms_vdp_rewrite_flag_tbl

	.xdef	PSET_G4
	.xdef	PSET_G5
	.xdef	LINE_G5
	.xdef	LMMC_G5

	;.xdef	VDP_R_01

	;.xdef	_sprite_size
	;.xdef	tx_active
	;.xdef	gr_active
	.xdef	update_VCRR_02

MFP_GPIP_6	equ	$000138		* 水平割り込みのベクタアドレス

gram		equ	$c00000

CRTR_00		equ	$e80000		* ＣＲＴＣレジスタ０
CRTR_01		equ	$e80002
CRTR_02		equ	$e80004
CRTR_03		equ	$e80006
CRTR_04		equ	$e80008
CRTR_05		equ	$e8000a
CRTR_06		equ	$e8000c
CRTR_07		equ	$e8000e
CRTR_08		equ	$e80010

CRTR_09		equ	$e80012		* ＣＲＴＣレジスタ９

CRTR_10		equ	$e80014		* ＣＲＴＣレジスタ10 (テキストスクロールX)
CRTR_11		equ	$e80016		* ＣＲＴＣレジスタ11 (テキストスクロールY)
CRTR_12		equ	$e80018		* ＣＲＴＣレジスタ12
CRTR_13		equ	$e8001A		* ＣＲＴＣレジスタ13
CRTR_14		equ	$e8001C		* ＣＲＴＣレジスタ14
CRTR_15		equ	$e8001E		* ＣＲＴＣレジスタ15

CRTR_20		equ	$e80028
CRTR_21		equ	$e8002a
CRTR_23		equ	$e8002e
pla0		equ	$e00000

g_palette	equ	$e82000		* グラフィックパレット
t_palette	equ	$e82200		* テキストパレット	

VCRR_00		equ	$e82400		* ビデオコントロールレジスタ０
VCRR_01		equ	$e82500		* ビデオコントロールレジスタ１
VCRR_02		equ	$e82600		* ビデオコントロールレジスタ２

GPIP		equ	$e88001
IERA		equ	$e88007

SPCON_HTOTAL	equ	$eb080a		* スプライトコントローラ 画面モードレジスタ H-TOTAL
SPCON_HDISP	equ	$eb080c		* スプライトコントローラ 画面モードレジスタ H-DISP
SPCON_VDISP	equ	$eb080e		* スプライトコントローラ 画面モードレジスタ V-DISP
SPCON_RES	equ	$eb0810		* スプライトコントローラ 画面モードレジスタ V-Res, H-Res


offset_ms_vdp_init			equ	0*4
offset_ms_vdp_read_vram			equ	1*4
offset_ms_vdp_write_vram		equ	2*4
offset_ms_vdp_update_palette		equ	3*4
offset_ms_vdp_update_pnametbl_baddr	equ	4*4
offset_ms_vdp_update_colortbl_baddr	equ	5*4
offset_ms_vdp_update_pgentbl_baddr	equ	6*4
offset_ms_vdp_update_sprattrtbl_baddr	equ	7*4
offset_ms_vdp_update_sprpgentbl_baddr 	equ	8*4
offset_ms_vdp_update_r7_color		equ	9*4
offset_ms_vdp_get_mode_name		equ	10*4
offset_ms_vdp_exec_vdp_command		equ	11*4
offset_ms_vdp_update_resolution		equ	12*4
offset_ms_vdp_vsync_draw		equ	13*4

; typedef struct ms_vdp {
; 	uint8_t	r00;	// Mode register 0
; 	uint8_t	r01;	// Mode register 1
; 	uint8_t	_r02;	// R02の生の値。実際のアクセスでは pnametbl_baddr を使う
; 	uint8_t _r03;	// R03の生の値。実際のアクセスでは R10 と結合した colortbl_baddr を使う
; 	uint8_t _r04;	// R04の生の値。実際のアクセスでは pgentbl_baddr を使う
; 	uint8_t _r05;	// R05の生の値。実際のアクセスでは R11 と結合した sprattrtbl_baddr を使う
; 	uint8_t _r06;	// R06の生の値。実際のアクセスでは sprpgentbl_baddr を使う
; 	uint8_t _r07;	// R09の生の値。実際のアクセスでは text_color / back_color を使う
; 	uint8_t r08;	// Mode register 2
; 	uint8_t r09;	// Mode register 3
; 	uint8_t _r10;	// R10の生の値。実際のアクセスでは R03 と結合した colortbl_baddr を使う
; 	uint8_t _r11;	// R11の生の値。実際のアクセスでは R05 と結合した sprattrtbl_baddr を使う
; 	uint8_t r12;
; 	uint8_t r13;
; 	uint8_t r14;
; 	uint8_t r15;
; 	uint8_t r16;
; 	uint8_t r17;
; 	uint8_t r18;
; 	uint8_t r19;
; 	uint8_t r20;
; 	uint8_t r21;
; 	uint8_t r22;
; 	uint8_t r23;
; 	uint8_t r24;
; 	uint8_t r25;
; 	uint8_t r26;
; 	uint8_t r27;
; 	uint8_t r28;
; 	uint8_t r29;
; 	uint8_t r30;
; 	uint8_t r31;
; 	uint16_t sx;	// 32,33 (並びが逆になるので注意)
; 	uint16_t sy;	// 34,35
; 	uint16_t dx;	// 36,37
; 	uint16_t dy;	// 38,39
; 	uint16_t nx;	// 40,41
; 	uint16_t ny;	// 42,43
; 	uint8_t clr;	// 44
; 	uint8_t arg;	// 45
; 	uint8_t r46;

; 	uint8_t dummy1;	// 47

; 	// Status Registers
; 	uint8_t s00;	// offset = +48
; 	uint8_t s01;
; 	uint8_t s02;
; 	uint8_t s03;
; 	uint8_t s04;
; 	uint8_t s05;
; 	uint8_t s06;
; 	uint8_t s07;
; 	uint8_t s08;
; 	uint8_t s09;	// offset = +57

; 	// Palette Registers
; 	uint16_t palette[16];	// offset = +58

; 	// Special Control Registers
; 	// 	特殊コントロールレジスタ
; 	//  R_00:	.dc.b	0		* [ 0 ][ DG][IE2][IE1][ M5][ M4][ M3][ 0 ]
; 	//	R_01:	.dc.b	0		* [ 0 ][ BL][IE0][ M1][ M2][ 0 ][ SI][MAG]
; 	uint8_t crt_mode;		// R_0,R_1の[ M5]〜[ M0]
; 	uint8_t sprite_size;	// R_1の[ SI]
; 	uint8_t sprite_zoom;	// R_1の[MAG]
; 	uint8_t dummy2;

; 	// base address registers
; 	uint32_t pnametbl_baddr;		// R02: Pattern name table base address
; 	uint32_t colortbl_baddr;		// R03: Color table base address
; 	uint32_t pgentbl_baddr;		// R04: Pattern generator table base address
; 	uint32_t sprattrtbl_baddr;		// R05: Sprite attribute table bse address
; 	uint32_t sprpgentbl_baddr;	// R06: Sprite pattern generator table base address
; 	uint16_t text_color;			// R07: Text color
; ; 	uint16_t back_color;			// R07: Back color

; 	//
; 	uint32_t vram_addr;
; 	uint32_t gram_addr;

; 	//
; 	uint16_t display_mode;
; 	ms_vdp_mode_t *ms_vdp_current_mode;

; 	//
; 	uint16_t tx_active;
; 	uint16_t gr_active;

; 	// X68000側に確保したVRAMの先頭アドレス
; 	uint8_t* vram;

; 	// X68000のPCGに転送するためのバッファ領域
; 	unsigned int* x68_pcg_buffer;
; 	int last_visible_sprite_planes;
; 	int last_visible_sprite_size;
; } ms_vdp_t;

offset_ms_vdp_r00		equ	0
offset_ms_vdp_r01		equ	1
offset_ms_vdp_r02_		equ	2
offset_ms_vdp_r03_		equ	3
offset_ms_vdp_r04_		equ	4
offset_ms_vdp_r05_		equ	5
offset_ms_vdp_r06_		equ	6
offset_ms_vdp_r07_		equ	7
offset_ms_vdp_r08		equ	8
offset_ms_vdp_r09		equ	9
offset_ms_vdp_r10_		equ	10
offset_ms_vdp_r11_		equ	11
offset_ms_vdp_r12		equ	12
offset_ms_vdp_r13		equ	13
offset_ms_vdp_r14		equ	14
offset_ms_vdp_r15		equ	15
offset_ms_vdp_r16		equ	16
offset_ms_vdp_r17		equ	17
offset_ms_vdp_r18		equ	18
offset_ms_vdp_r19		equ	19
offset_ms_vdp_r20		equ	20
offset_ms_vdp_r21		equ	21
offset_ms_vdp_r22		equ	22
offset_ms_vdp_r23		equ	23
offset_ms_vdp_r24		equ	24
offset_ms_vdp_r25		equ	25
offset_ms_vdp_r26		equ	26
offset_ms_vdp_r27		equ	27
offset_ms_vdp_r28		equ	28
offset_ms_vdp_r29		equ	29
offset_ms_vdp_r30		equ	30
offset_ms_vdp_r31		equ	31
offset_ms_vdp_sx		equ	32
offset_ms_vdp_sy		equ	34
offset_ms_vdp_dx		equ	36
offset_ms_vdp_dy		equ	38
offset_ms_vdp_nx		equ	40
offset_ms_vdp_ny		equ	42
offset_ms_vdp_clr		equ	44
offset_ms_vdp_arg		equ	45
offset_ms_vdp_r46		equ	46
offset_ms_vdp_s00		equ	48
offset_ms_vdp_s01		equ	49
offset_ms_vdp_s02		equ	50
offset_ms_vdp_s03		equ	51
offset_ms_vdp_s04		equ	52
offset_ms_vdp_s05		equ	53
offset_ms_vdp_s06		equ	54
offset_ms_vdp_s07		equ	55
offset_ms_vdp_s08		equ	56
offset_ms_vdp_s09		equ	57
offset_ms_vdp_palette		equ	58
offset_ms_vdp_crt_mode		equ	90
offset_ms_vdp_sprite_size	equ	91
offset_ms_vdp_sprite_zoom	equ	92
offset_ms_vdp_dummy2		equ	93
offset_ms_vdp_pnametbl_baddr	equ	94
offset_ms_vdp_colortbl_baddr	equ	98
offset_ms_vdp_pgentbl_baddr	equ	102
offset_ms_vdp_sprattrtbl_baddr	equ	106
offset_ms_vdp_sprpgentbl_baddr 	equ	110
offset_ms_vdp_text_color	equ	114
offset_ms_vdp_back_color	equ	116
offset_ms_vdp_vram_addr		equ	118
offset_ms_vdp_gram_addr		equ	122
;offset_ms_vdp_display_mode	equ	126
offset_ms_vdp_current_mode	equ	128
offset_ms_vdp_tx_active		equ	132
offset_ms_vdp_gr_active		equ	134
offset_ms_vdp_vram		equ	136
offset_ms_vdp_x68_pcg_buffer	equ	140
offset_ms_vdp_last_visible_sprite_planes	equ	144
offset_ms_vdp_last_visible_sprite_size		equ	148


*
*	ＭＳＸの画面モードと６８の画面モードの対応
*
*	ＭＳＸ			６８
*	screen0	(TEXT1,TEXT2)	16色	512*512
*	screen1	(GRAPHIC1)	16色	512*512
*	screen2	(GRAPHIC2)	16色	512*512
*	screen3	(MULTICOLOR)	16色	512*512
*	screen4	(GRAPHIC3)	16色	512*512
*	screen5	(GRAPHIC4)	16色	512*512
*	screen6	(GRAPHIC5)	16色	512*512
*	screen7	(GRAPHIC6)	16色	512*512
*	screen8	(GRAPHIC7)	256色	512*512
*	screen10		65536色	512*512
*	screen11		65536色	512*512
*	screen12		65536色	512*512
*
*
	.68030

	.text
	.even


***************************************************************
*
*	ＶＤＰ設定ルーチン
*
*	int ms_vdp_init_mac(ms_vdp_t *vdp);
*
*	成功時は1を返す
*
***************************************************************
ms_vdp_init_mac:
	link	a6,#0
	movem.l	d3-d7/a0-a5,-(sp)

	; 引数でも vdpインスタンスのポインタを受けとっているが、
	; シングルトンなので、ms_vdp_shared から取得する
	;
	; 構造的には複数インスタンスが作れるようなインターフェースにしているが、
	; 本VDP実装はX68000のグラフィックを占有するため、実質的には1つしか作れない
	; ただ、Kepler X上のVDPとの差し替えができるようにするなどの将来的な拡張のために、
	; APIはかならず引数に vdpインスタンスを受け取るようにしている
	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得

	* プライオリティの設定
	* b15:14 (NONE)
	* b13:12 スプライト優先順位
	* b11:10 テキスト優先順位
	* b09:08 グラフィック優先順位
	* b07:06 ┗グラフィックページ3の優先順位
	* b05:04 ┗グラフィックページ2の優先順位
	* b03:02 ┗グラフィックページ1の優先順位
	* b01:00 ┗グラフィックページ0の優先順位
	move.w	#%00_01_00_10__11_10_01_00,VCRR_01

	move.w	#1,offset_ms_vdp_tx_active(a5)
	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.w	#0,$E82222

	; 割り込み設定
	move.w	sr,d0
	move.w	d0,-(sp)
	or.w	#%00000111_00000000,d0	* 一時的に割り込み禁止
	move.w	d0,sr
@@:
	move.w	ms_vdp_vsync_rate,d1
	and.w	#$0_ff,d1			* 垂直帰線期間で、指定回数ごとに割り込み
	lea.l	vdp_interrupt,a1
	IOCS	__VDISPST
	move.l	d0,d0
	beq	@f
	pea	errms_timer_A_in_use
	DOS	__PRINT
	lea.l	4(sp),sp	
	movea.l	#0,a1	
	IOCS	__VDISPST
	bra	@b
@@:
	move.w	(sp)+,sr			* 割り込み復帰

	movem.l	(sp)+,d3-d7/a0-a5
	unlk	a6

	moveq.l	#1,d0

	rts

vdp_interrupt:
	movem.l	a5,-(sp)
	addq.w	#1,ms_vdp_interrupt_tick

	movea.l	ms_vdp_shared,a5
	btst.b	#5,offset_ms_vdp_r01(a5)	* VDP IE0 (R#1のbit5) をみて、割り込みが許可されているかを調べる
	beq	@f
	bset.b	#7,offset_ms_vdp_s00(a5)	* VDP ステータスレジスタ 0の bit7に、割り込み発生フラグを立てる。これがZ80のINT端子の状態を表している。
	move.b	#1,ms_vdp_int		* 割り込み要求フラグを立てる
@@:
	move.w	#$0001,cpu_yield	* 上位: cpu_yield 
	move.w	host_delay,emu_yield	* 下位: emu_yield
	movem.l	(sp)+,a5
	rte

;
; ＶＤＰの終了処理
;
ms_vdp_deinit_mac:
	move.w	sr,d0
	move.w	d0,-(sp)		* sr を保存
	or.w	#%00000111_00000000,d0	* 一時的に割り込み禁止
	move.w	d0,sr

	clr.l	a1			* 垂直同期割り込みを禁止
	IOCS	__VDISPST

	move.w	(sp)+,sr		* sr を復元
	rts

	.data
	.even

ms_vdp_vsync_rate:
	.dc.w	1
ms_vdp_interrupt_tick:
	.dc.w	0
errms_timer_A_in_use:
	.dc.b	'タイマＡは使用中です',0,0

	.text

*
* バックドロップ用のＢＧを設定
*
enable_backdrop:
	lea.l	$EB8000,a0

	move.l	#$11111111,d1			* パターンの定義
	move.w	#32-1,d0
@@:	move.l	d1,(a0)+
	dbra	d0,@b

	lea.l	$EBC000,a0			* ＢＧの定義
	move.w	#%00000001_00000000,d1
	move.w	#4096-1,d0
@@:	move.w	d1,(a0)+
	dbra	d0,@b

*	ori.w	#%0000001_000_001_001,$EB0808			* BG ON
	ori.w	#%0000001_000_000_000,$EB0808			* BG OFF
	rts

***************************************************************
* VCC R02の更新
* 	b7	常に0
*	b6	スプライト+BG画面の表示
*	b5	テキスト画面の表示
*	b4	1024x1024時のグラフィック画面の表示(512x512なので使わない)
*	b3	512x512時のグラフィック画面 GR3 の表示
*	b2	512x512時のグラフィック画面 GR2 の表示
*	b1	512x512時のグラフィック画面 GR1 の表示
*	b0	512x512時のグラフィック画面 GR0 の表示
***************************************************************
update_VCRR_02:
	link	a6,#0
	movem.l	d0-d1/a5,-(sp)

	movea.l	ms_vdp_shared,a5
	move.w	VCRR_02,d0
	andi.w	#%11111111_00100000,d0
	ori.w	#%00000000_01000000,d0	* スプライト+BG画面の表示

	move.w	offset_ms_vdp_tx_active(a5),d1
	lsl.w	#5,d1
	or.w	d1,d0
	btst.b	#6,offset_ms_vdp_r01(a5)			* VDP Mode register 1 (R#1) の bit6 (BL) が 0 の時は画面を表示しない
	beq	@f
	or.w	offset_ms_vdp_gr_active(a5),d0	
@@:	move.w	d0,VCRR_02

	movem.l	(sp)+,d0-d1/a5
	unlk	a6
	rts

***************************************************************
*
*	ＶＤＰポートからの読み込みルーチン群
*
*    (返り値）
*	d0.b ・・・ 読み込んだ値
*
***************************************************************
read_vdp_0:				* ＶＲＡＭの読み込み
	; 画面モードごとのVRAM読み込み処理を呼び出す
	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	a5,-(sp)		* 構造体のアドレスを引数1に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_read_vram(a0),a0
	jsr	(a0)
	lea.l	4(sp),sp
	rts

read_vdp_1:					* ステータスレジスタの読みだし
	movea.l	ms_vdp_shared,a5
	move.b	offset_ms_vdp_r15(a5),d0	* ステータスレジスタ番号の読みだし
	andi.w	#%00001111,d0
	add.w	d0,d0
	add.w	d0,d0
	lea	r_SReg_jpt,a0 
	move.l	(a0,d0.w),a0
	jmp	(a0)

	.data
r_SReg_jpt:
	.dc.l	r_SReg_0
	.dc.l	r_SReg_1
	.dc.l	r_SReg_2
	.dc.l	r_SReg_3
	.dc.l	r_SReg_4
	.dc.l	r_SReg_5
	.dc.l	r_SReg_6
	.dc.l	r_SReg_7
	.dc.l	r_SReg_8
	.dc.l	r_SReg_9
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f
	.dc.l	r_SReg_f

	.text
r_SReg_0:
	move.b	offset_ms_vdp_s00(a5),d0
	bclr.b	#7,offset_ms_vdp_s00(a5)			* ビット７は読み出すとリセットされる
	clr.b	ms_vdp_int		* 割り込み要求もクリア
	rts
r_SReg_1:
	move.b	offset_ms_vdp_s01(a5),d0
	bclr.b	#1,offset_ms_vdp_s01(a5)			* ビット１は読み出すとリセットされる
	rts
r_SReg_2:
	move.b	offset_ms_vdp_s02(a5),d0
	andi.b	#%10011111,d0
	move.b	GPIP,d1			* いったんレジスタに読む
	btst.l	#7,d1			* GPIP b7:水平帰線期間かどうか (0:水平帰線期間 1:水平帰線期間外(表示期間))
	beq	@f
	ori.b	#%00100000,d0		* VDP S#2 b6:水平帰線期間(0:帰線期間,1:表示期間)

@@:	btst.l	#4,d1			* GPIP b4:垂直帰線期間かどうか (0:垂直帰線期間 1:垂直帰線期間外(表示期間))
	bne	@f
	ori.b	#%01000000,d0		* VDP S#2 b4:垂直帰線期間(0:帰線期間,1:表示期間)
@@:	rts

r_SReg_3:
	move.b	offset_ms_vdp_s03(a5),d0
	rts
r_SReg_4:
	move.b	offset_ms_vdp_s04(a5),d0
	rts
r_SReg_5:
	move.b	offset_ms_vdp_s05(a5),d0
	rts
r_SReg_6:
	move.b	offset_ms_vdp_s06(a5),d0
	rts
r_SReg_7:
	move.b	offset_ms_vdp_s07(a5),d0
	rts
r_SReg_8:
	move.b	offset_ms_vdp_s08(a5),d0
	rts
r_SReg_9:
	move.b	offset_ms_vdp_s09(a5),d0
	rts
r_SReg_f:
	move.b	#$ff,d0
	rts

read_vdp_2:				* 書き込み専用ポート（読み込むと$ffが返るらしい）
read_vdp_3:
	moveq.l	#$ff,d0
	rts


***************************************************************
*
*	ＶＤＰポートへの書き込みルーチン群
*
*    (引数）
*	d1.b ・・・ 書き込む値
*
***************************************************************
write_vdp_0:				* VRAM への書き込み
	; 画面モードごとのVRAM書き込み処理を呼び出す
	andi.l	#$000000ff,d1
	move.l	d1,-(sp)		* 書き込む値を引数2に
	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	a5,-(sp)		* 構造体のアドレスを引数1に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_write_vram(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts


write_vdp_1:
	bchg.b	#0,w_ContReg_mode	* １バイト目か２バイト目か？
	bne	@f
	move.b	d1,first_bite_1		* １バイト目
	rts
@@:
	movea.l	ms_vdp_shared,a5
	move.b	d1,d0
	bmi	set_CReg_Direct		* コントロールレジスタの直接指定モード

	move.l	offset_ms_vdp_vram_addr(a5),d1		* ＶＲＡＭアドレス設定
	andi.w	#%11000000_00000000,d1
	andi.w	#%00000000_00111111,d0
	lsl.w	#8,d0
	move.b	first_bite_1,d0
	or.w	d0,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	movea.l	set_gram_add_rot,a0
	jmp	(a0)

write_vdp_2:				* パレットレジスタへの書き込み
	bchg.b	#0,w_PalReg_mode	* １バイト目か２バイト目か？
	bne	@f
	move.b	d1,first_bite_2		* １バイト目
	rts
@@:
	movea.l	ms_vdp_shared,a5
	andi.w	#%00000111,d1
	add.w	d1,d1
	lea.l	b3_b5_table,a0
	move.w	(a0,d1.w),d1
	lsl.w	#8,d1
	lsl.w	#3,d1			* d1 = %GGGGG000_00000000
	move.b	first_bite_2,d0
	move.b	d0,d2
	andi.w	#%00000000_01110000,d0
	lsr.w	#4,d0			* d0 = %00000000_00000RRR
	add.w	d0,d0
	move.w	(a0,d0.w),d0
	lsl.w	#6,d0			* d0 = %00000RRR_RR000000
	or.w	d0,d1			* d1 = %GGGGGRRR_RR000000
	andi.w	#%00000000_00000111,d2
	add.w	d2,d2
	move.w	(a0,d2.w),d2
	add.w	d2,d2			* d2 = %00000000_00BBBBB0
	or.w	d2,d1			* d1 = %GGGGGRRR_RRBBBBB0
	addq.w	#1,d1			* d1 = %GGGGGRRR_RRBBBBB1

	move.b	offset_ms_vdp_r16(a5),d0			* 書き込むパレット番号の読みだし
	addq.b	#1,offset_ms_vdp_r16(a5)			* R#16はインクリメント
	andi.b	#%00001111,offset_ms_vdp_r16(a5)
	andi.w	#$000f,d0
	add.w	d0,d0
	lea.l	offset_ms_vdp_palette(a5),a0			* X68000の16bitカラー形式に変換した値をP_0?P_15に書き込む
	move.w	d1,0(a0,d0.w)

	; 画面モードに応じてパレットをX68000側の画面に設定
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_palette(a0),a0
	jsr	(a0)
	lea.l	4(sp),sp
	rts

b3_b5_table:				* ３ビットのデータから５ビットのデータを得る
	.dc.w	0			* 0
	.dc.w	4
	.dc.w	9
	.dc.w	13			* 3
	.dc.w	18			* 4
	.dc.w	22
	.dc.w	27
	.dc.w	31			* 7


***************************************************************
*
*	コントロールレジスタ間接書き込みルーチン
*
***************************************************************
write_vdp_3:
	movea.l	ms_vdp_shared,a5
	move.b	offset_ms_vdp_r17(a5),d0
	andi.w	#%00000000_10111111,d0
	bclr.l	#7,d0
	beq	incmode
	cmp.b	#17,d0			* R#17 は間接指定では変更出来ない
	bne	@f
	rts
@@:	move.w	d0,d2
	add.w	d2,d2
	add.w	d2,d2
	lea	w_CReg_jpt,a0
	move.l	(a0,d2.w),a0
	jmp	(a0)


incmode:
	addq.b	#1,offset_ms_vdp_r17(a5)
	cmp.b	#17,d0			* R#17 は間接指定では変更出来ない
	bne	@f
	rts
@@:	move.w	d0,d2
	add.w	d2,d2
	add.w	d2,d2
	lea	w_CReg_jpt,a0
	move.l	(a0,d2.w),a0
	jmp	(a0)
	

***************************************************************
*
*	コントロールレジスタ直接書き込みルーチン
*
***************************************************************
set_CReg_Direct:
	move.b	first_bite_1,d1
	andi.w	#%00000000_00111111,d0
	move.w	d0,d2
	add.w	d2,d2
	add.w	d2,d2
	lea	w_CReg_jpt,a0
	move.l	(a0,d2.w),a0
	jmp	(a0)


* 	サブルーチンへのコールテーブル
*	.d0.w	レジスタ番号		* <-- ワードであることに注意
*	.d1.b	書き込む値
	.data

w_CReg_jpt:
	.dc.l	w_R0			* R#0
	.dc.l	w_R1
	.dc.l	w_R2
	.dc.l	w_R3
	.dc.l	w_R4
	.dc.l	w_R5			* スプライトアトリビュートテーブル(下位)
	.dc.l	w_R6			* スプライトパターンジェネレータテーブル
	.dc.l	w_R7
	.dc.l	w_R8
	.dc.l	w_R9
	.dc.l	w_R10			* R#10
	.dc.l	w_R11			* スプライトアトリビュートテーブル(上位)
	.dc.l	normal
	.dc.l	normal
	.dc.l	w_R14
	.dc.l	w_R15
	.dc.l	w_R16
	.dc.l	w_R17
	.dc.l	normal
	.dc.l	w_R19
	.dc.l	normal		* R#20
	.dc.l	normal
	.dc.l	normal
	.dc.l	w_R23
	.dc.l	normal
	.dc.l	normal
	.dc.l	normal
	.dc.l	normal		* R#27
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister		* 30
	.dc.l	noregister
	.dc.l	SX_l			* R#32
	.dc.l	SX_h
	.dc.l	SY_l
	.dc.l	SY_h
	.dc.l	DX_l
	.dc.l	DX_h
	.dc.l	DY_l
	.dc.l	DY_h
	.dc.l	NX_l			* R#40
	.dc.l	NX_h
	.dc.l	NY_l
	.dc.l	NY_h
MC_add:	.dc.l	w_CLR			* R#44 Color register : CPU-VRAM間データ転送レジスタ
	.dc.l	w_ARG
	.dc.l	w_R46			* R#46
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister
	.dc.l	noregister		* 63

	.text

noregister:
	move.w	d0,d2
	lsr.w	#4,d0
	move.b	@f(pc,d0.w),number_creg+0
	andi.w	#$0f,d2
	move.b	@f(pc,d2.w),number_creg+1

	pea.l	errms_creg
	DOS	__PRINT
	lea.l	4(sp),sp
	rts

@@:	.dc.b	'0123456789ABCDEF'

	.data
errms_creg:
	.dc.b	'おかしなVDPコントロールレジスタに書き込みました。0x'
number_creg:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00


	.even

	.text
normal:
	lea.l	offset_ms_vdp_r00(a5),a0
	move.b	d1,0(a0,d0.w)
	rts

*crtcras_:
*	.dc.l	crtcras

; R#0	VDP Mode Register 0
; 	[ 0 ][ DG][IE2][IE1][ M5][ M4][ M3][ 0 ]
;	DG  : カラーバスを入力モードにしてデータをＶＲＡＭへ取り込む
;	IE2 : ライトペン割り込み
;		０＝禁止
;		１＝許可
;	IE1 : 水平帰線(HSYNC)割り込み
;		０＝禁止
;		１＝許可
;	M5-M1 : 画面モード(後述: set_CRT参照)
w_R0:	move.b	d1,offset_ms_vdp_r00(a5)

	bclr.l	#4,d1			* IE1 のテスト
	beq	@f
					* 走査線割り込みを使用する
	clr.w	d1
	move.b	offset_ms_vdp_r19(a5),d1
	*TBD
	*TBD
	bra	1f
@@:					* 走査線割り込みを使用しない
1:	andi.w	#%00000000_00001110,d1	* 画面モードのセット
	lsl.w	#1,d1			* M5,M4,M3を bit4,3,2の位置に
	move.b	offset_ms_vdp_crt_mode(a5),d0
	andi.w	#%00000000_00000011,d0	* M2,M1と混ぜる
	or.w	d1,d0
	bsr	set_CRT			* 画面の切り替え
	rts

; R#1	VDP Mode Register 1
;	[ 0 ][ BL][IE0][ M1][ M2][ 0 ][ SI][MAG]	
; 	BL  : 画面表示状態
;		０＝非表示
;		１＝表示
;	IE0 : 垂直帰線(VSYNC)割り込み
;		０＝禁止
;		１＝許可
;	SI  : スプライトサイズ
; 		０＝８×８
; 		１＝１６×１６
;	MAG : スプライトの拡大
; 		０＝拡大しない
;		１＝拡大する
;	M5-M1 : 画面モード(後述: set_CRT参照)
;
w_R1:	move.b	d1,offset_ms_vdp_r01(a5)

	bsr	update_VCRR_02

	move.b	d1,d0			* スプライトのサイズ, 0の時 8x8, 1の時 16x16
	andi.b	#%00000010,d0
	lsr.b	#1,d0
	move.b	d0,offset_ms_vdp_sprite_size(a5)

	move.b	d1,d0
	andi.w	#%00000000_00010000,d0
	lsr.w	#4,d0			* M1をbit0に
	move.b	d1,d2
	andi.w	#%00000000_00001000,d2
	lsr.w	#2,d2			* M2をbit1に
	or.w	d2,d0
	move.b	offset_ms_vdp_crt_mode(a5),d2
	andi.w	#%00000000_00011100,d2	* M5,M4,M3と混ぜる
	or.w	d2,d0
	bsr	set_CRT

	move.l	a5,-(sp)		* 構造体のアドレスを引数に
	bsr	_update_sprite_visibility
	lea.l	4(sp),sp
	rts

*
*	システムにパターンネームテーブルが変更されたことを伝える
*
w_R2:	move.b	d1,offset_ms_vdp_r02_(a5)

	andi.l	#%00000000_01111111,d1
	swap	d1
	lsr.l	#6,d1

update_pnametbl_baddr:
	; 画面モードに応じてパターンネームテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_pnametbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts


*
*	システムにカラーテーブルが変更されたことを伝える
*
w_R3:	move.b	d1,offset_ms_vdp_r03_(a5)

	move.l	offset_ms_vdp_colortbl_baddr(a5),d0			* d0 = AAAAAAAA_AA000000
	lsr.w	#6,d0			* d0 = 000000AA_AAAAAAAA
	move.b	d1,d0			* d0 = 000000AA_BBBBBBBB
	lsl.w	#6,d0			* d0 = AABBBBBB_BB000000
	bsr	update_colortbl_baddr
	rts

w_R10:	move.b	d1,offset_ms_vdp_r10_(a5)
	bsr	update_colortbl_baddr
	rts

update_colortbl_baddr:
	; 画面モードに応じてカラーテーブルの更新処理を呼び出す
	move.l	d0,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_colortbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts
	
*
*	システムにパターンジェネレータテーブルが変更されたことを伝える必用がある
*
w_R4:	move.b	d1,offset_ms_vdp_r04_(a5)

	; 画面モードに応じてパターンジェネレータテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_pgentbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts

*
*	R5 はスプライトアトリビュートテーブルの下位バイト
*	システムにスプライトアトリビュートテーブルが変更されたことを伝える必用がある
*
w_R5:	move.b	d1,offset_ms_vdp_r05_(a5)
	bsr	update_spriteattrtbl_baddr
	rts


w_R11:	move.b	d1,offset_ms_vdp_r11_(a5)
	bsr	update_spriteattrtbl_baddr
	rts

update_spriteattrtbl_baddr:
	; 画面モードに応じてスプライトアトリビュートテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_sprattrtbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts
*
*	スプライトパターンジェネレータテーブルの設定
*	システムにスプライトパターンジェネレータテーブルが変更されたことを伝える必用がある
*
w_R6:	move.b	d1,offset_ms_vdp_r06_(a5)

	; 画面モードに応じてスプライトアトリビュートテーブルの更新処理を呼び出す
	move.l	d1,-(sp)		* アドレスを引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_sprpgentbl_baddr(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts

*
*	画面の周辺色の更新
*
w_R7:	move.b	d1,offset_ms_vdp_r07_(a5)

	; 画面モードに応じて周辺色のの更新処理を呼び出す
	move.l	d1,-(sp)		* 値を引数に
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_r7_color(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts

; R#8	VDP Mode Register 2
; 	[ MS][ LP][ TP][ CB][ VR][  0][SPD][ BW]
;	MS  : マウスモード(MSXでは未使用)
;	LP  : ライトペン割り込み (V9958には存在しない)
;	TP  : 透明色の扱い
;		0=色コード0が透明として扱われる
;		1=色コード0がパレットレジスタで指定された色として扱われる
;	CB  : カラーバスの選択
;		0=output(デフォルト)
;		1=input
;	VR  : VRAMの組み合わせ
;	SPD : スプライトの非表示
;		0=スプライト表示
;		1=スプライト非表示
;	BW  : 白黒モード
;		0=カラーモード(デフォルト)
;		1=白黒モード
w_R8:	move.b	d1,offset_ms_vdp_r08(a5)
	move.l	a5,-(sp)		* 構造体のアドレスを引数に
	bsr	_update_sprite_visibility
	lea.l	4(sp),sp
	rts

; R#9	VDP Mode Register 3
;	[ LN][ 0 ][ S1][ S0][ IL][ EO][ NT][ DC]
;	LN  : ライン数の指定
;		0=192ライン
;		1=212ライン
;	S1S0: スーパーインポーズ関連の設定(未実装)
;	IL  : インターレースモード
;		0=非インターレース
;		1=インターレース
;	EO  : 画面の偶数奇数自動交互表示
;		0=交互表示しない
;		1=交互表示する
;	NT  : NTSC / PAL の選択
;		0=NTSC
;		1=PAL
;	DC  : ドットクロックの入出力方向
;		0=出力
;		1=入力
w_R9:	move.b	d1,offset_ms_vdp_r09(a5)

	; 画面モードに応じて解像度設定の更新処理を呼び出す
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_update_resolution(a0),a0
	jsr	(a0)
	lea.l	4(sp),sp
	rts

w_R14:	andi.l	#%00000000_00000111,d1	* d1.l = 00000000_00000000_00000AAA
	swap	d1			* d1.l = 00000AAA_00000000000000000
	lsr.l	#2,d1			* d1.l = 0000000A_AA000000_00000000 
	move.l	offset_ms_vdp_vram_addr(a5),d0
	andi.w	#%00111111_11111111,d0
	or.w	d0,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	movea.l	set_gram_add_rot,a0
	jmp	(a0)

w_R15:	move.b	d1,offset_ms_vdp_r15(a5)
	rts
w_R16:	move.b	d1,offset_ms_vdp_r16(a5)
	rts
w_R17:	move.b	d1,offset_ms_vdp_r17(a5)
	rts

w_R19:	move.b	d1,offset_ms_vdp_r19(a5)
	rts

w_R23:					* 縦スクロール
	move.b	d1,offset_ms_vdp_r23(a5)
	clr.w	d0
	move.b	d1,d0
	add.w	d0,d0
	lea.l	CRTR_13,a0
	move.w	d0,(a0)
	move.w	d0,4(a0)
	move.w	d0,8(a0)
	move.w	d0,12(a0)
	rts

SX_l:	move.b	d1,offset_ms_vdp_sx+1(a5)
	rts
SX_h:	andi.b	#%00000001,d1		* 余計な部分を削除
	move.b	d1,offset_ms_vdp_sx+0(a5)
	rts
SY_l:	move.b	d1,offset_ms_vdp_sy+1(a5)
	rts
SY_h:	move.b	d1,offset_ms_vdp_sy+0(a5)
	rts
DX_l:	move.b	d1,offset_ms_vdp_dx+1(a5)
	rts
DX_h:	move.b	d1,offset_ms_vdp_dx+0(a5)
	rts
DY_l:	move.b	d1,offset_ms_vdp_dy+1(a5)
	rts
DY_h:	move.b	d1,offset_ms_vdp_dy+0(a5)
	rts
NX_l:	move.b	d1,offset_ms_vdp_nx+1(a5)
	rts
NX_h:	move.b	d1,offset_ms_vdp_nx+0(a5)
	rts
NY_l:	move.b	d1,offset_ms_vdp_ny+1(a5)
	rts
NY_h:	move.b	d1,offset_ms_vdp_ny+0(a5)
	rts

w_CLR:	move.b	d1,offset_ms_vdp_clr(a5)
	rts

w_ARG:	move.b	d1,offset_ms_vdp_arg(a5)
	rts

w_R46:
	; 画面モードに応じてVDPコマンドの実行処理を呼び出す
	move.l	d1,-(sp)		* 引数にコマンド番号をセット
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	movea.l	offset_ms_vdp_current_mode(a5),a0
	movea.l	offset_ms_vdp_exec_vdp_command(a0),a0
	jsr	(a0)
	lea.l	8(sp),sp
	rts


***************************************************************
*
*	画面の切り替え
*
*	d0.w	新しいＣＲＴＭＯＤＥレジスターの値
*
*		     | M5 | M4 | M3 | M2 | M1 |
*	|SCREEN 0(40)|  0 |  0 |  0 |  0 |  1 |		0x01	TEXT1
*	|SCREEN 0(80)|  0 |  1 |  0 |  0 |  1 |		0x09	TEXT2
*	|SCREEN 1    |  0 |  0 |  0 |  0 |  0 |		0x00
*	|SCREEN 2    |  0 |  0 |  1 |  0 |  0 |		0x04
*	|SCREEN 3    |  0 |  0 |  0 |  1 |  0 |		0x02	MULTICOLOR
*	|SCREEN 4    |  0 |  1 |  0 |  0 |  0 |		0x08
*	|SCREEN 5    |  0 |  1 |  1 |  0 |  0 |		0x0c
*	|SCREEN 6    |  1 |  0 |  0 |  0 |  0 |		0x10
*	|SCREEN 7    |  1 |  0 |  1 |  0 |  0 |		0x14
*	|SCREEN 8    |  1 |  1 |  1 |  0 |  0 |		0x1c
*
***************************************************************
set_CRT:
	cmp.b	offset_ms_vdp_crt_mode(a5),d0		* 前と変わってなければ何もしない
	bne	@f
	rts
@@:	move.b	d0,offset_ms_vdp_crt_mode(a5)		* ＣＲＴＭＯＤＥレジスターの更新
	ext.l	d0
	move.l	d0,-(sp)
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレスを引数に
	bsr	ms_vdp_set_mode
	lea	8(sp),sp
	rts

set_TEXT1_mac:
	move.l	#s_TEXT1,set_gram_add_rot

	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	movea.l	set_gram_add_rot,a0
	jsr	(a0)

	rts

set_TEXT2_mac:
	move.l	#s_TEXT2,set_gram_add_rot

	movea.l	ms_vdp_shared,a5	* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	movea.l	set_gram_add_rot,a0
	jsr	(a0)

	rts

set_MULTICOLOR_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%1111100011111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%1111111111111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$11111111,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.l	#s_MULTICOLOR,set_gram_add_rot

	rts


set_GRAPHIC1_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%1111100011111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%1111111111111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$11111111,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.l	#s_GRAPHIC1,set_gram_add_rot

	rts

set_GRAPHIC2_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%1111100011111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%1111111111111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$11111111,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.w	#1,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.l	#s_GRAPHIC2,set_gram_add_rot

	rts

set_GRAPHIC3_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	rts

set_GRAPHIC4_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%1111100011111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%1111111111111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$11111111,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	add.l	d1,d1
	swap	d1
	andi.w	#%00000000_00000011,d1		* d1 = アクティブページナンバー

	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.l	#s_GRAPHIC4,set_gram_add_rot

	rts

set_GRAPHIC5_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%1111100011111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%1111111111111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$21212121,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	add.l	d1,d1
	swap	d1
	andi.w	#%00000000_00000011,d1		* d1 = アクティブページナンバー
	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.l	#s_GRAPHIC5,set_gram_add_rot

	rts

set_GRAPHIC6_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%1111100011111111,d0		* 16色モードに
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%1111111111111000,d0		* 16色モードに
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$11111111,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	swap	d1
	andi.w	#%00000000_00000001,d1		* d1 = アクティブページナンバー
	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.l	#s_GRAPHIC6,set_gram_add_rot

	rts

set_GRAPHIC7_mac:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得

	move.w	CRTR_20,d0			* CRT レジスタの設定
	andi.w	#%1111100011111111,d0		* 256色モードに
	ori.w	#%0000000100000000,d0
	move.w	d0,CRTR_20
	move.w	VCRR_00,d0			* ビデオコントロールレジスタの設定
	andi.w	#%1111111111111000,d0		* 256色モードに
	ori.w	#%0000000000000001,d0
	move.w	d0,VCRR_00

	lea.l	$EB8000,a0			* バックドロップ用のＢＧを設定
	move.l	#$11111111,d1			* パターンの定義
	move.w	#16-1,d0
@@:	move.l	d1,(a0)+
	clr.l	(a0)+
	dbra	d0,@b

	move.l	offset_ms_vdp_pnametbl_baddr(a5),d1
	swap	d1
	andi.w	#%00000000_00000001,d1	* d1 = アクティブページナンバー
	clr.w	d0
	bset.l	d1,d0
	move.w	d0,offset_ms_vdp_gr_active(a5)
	bsr	update_VCRR_02

	move.l	#s_GRAPHIC7,set_gram_add_rot

	rts


***************************************************************
*
*	ＧＲＡＭアドレス設定サブルーチン群
*
*	d1.l	・・・ 対応するVRAMアドレス
*
***************************************************************
s_TEXT1:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00000011_11111111,d1		* 上位ワードも０にしたいから.lにしてある
	move.l	d1,d0
	divu.w	#40,d1
	move.w	d1,d0				* d0.l ・・商	y
	lsl.w	#8,d0				* d0.l = d0 * 256	(wordでＯＫ)
	lsl.l	#6,d0				* d0.l = d0 * 64 = y * 1024*16
	swap	d1				* d1.w ・・余り	x
	lsl.w	#3,d1
	move.w	d1,d2				* d2.w = x * 8
	add.w	d1,d1				* d1.w = x * 16
	add.w	d1,d2				* d2.w = x * 24

	add.w	d2,d0				* d0.l = アドレス (word 演算でＯＫ）
	add.l	#$c00000+32,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_TEXT2:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00001111_11111111,d1		* 上位ワードも０にしたいから.lにしてある
	move.l	d1,d0
	divu.w	#80,d1
	move.w	d1,d0				* d0.l ・・商	y
	lsl.w	#8,d0				* d0.l = d0 * 256	(wordでＯＫ)
	lsl.l	#6,d0				* d0.l = d0 * 64 = y * 1024*16
	swap	d1				* d1.w ・・余り	x
	lsl.w	#2,d1
	move.w	d1,d2				* d2.w = x * 4
	add.w	d1,d1				* d1.w = x * 8
	add.w	d1,d2				* d2.w = x * 12

	add.w	d2,d0				* d0.l = アドレス (word 演算でＯＫ）
	add.l	#$c00000+32,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_MULTICOLOR:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	rts

s_GRAPHIC1:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00000011_11111111,d1
	move.l	d1,d0				* 32で割って1024*16倍
	lsl.w	#3,d0				* d0.w = d0 * 8 =  y * 256
	clr.b	d0				* 余計な部分をクリア
	lsl.l	#6,d0				* d0.w = d0 * 64 = y * 1024*16
	andi.w	#%00000000_00011111,d1		* d1.l ・・余り	x
	lsl.w	#5,d1				* d1.l = x * 32

	add.w	d1,d0				* d0.l = アドレス (word 演算でＯＫ）
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_GRAPHIC2:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	andi.l	#%00000011_11111111,d1		* VRAMアドレスの下位10ビットを取得
	; VRAMアドレスを32で割ればライン番号になる
	; それを1024*8倍すると、GRAMのアドレスになる
	; なので、VRAMアドレスを256倍して、下位13ビットをクリアするとGRAMの画面左端アドレスになる
	move.l	d1,d0				* 32で割って1024*8倍 = 256倍
	lsl.l	#8,d0				* d0.w = y * 256
	and.l	#$fffe000,d0			* 下位13ビットをクリア
	; VRAMアドレスを32で割った余りがキャラクタのX座標になる
	; それを8*2倍すると、GRAMのアドレスになる
	andi.w	#%00000000_00011111,d1		* d1.l ・・余り	x
	lsl.w	#4,d1				* d1.l = x * 16
	; 合計するとGRAMアドレスが得られる
	add.l	d1,d0				* d0.l = アドレス
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_GRAPHIC3:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	rts

*
*	ＳＣＲＥＥＮ５，６はちょうど同じになる
*
s_GRAPHIC4:					* SCREEN 5 は,16色512*512モードを使う
s_GRAPHIC5:					* SCREEN 6 は,16色512*512モードを使う
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	lsl.l	#3,d1
	move.l	d1,d0
	andi.w	#%00000000_00000011_11111111,d1
	add.l	d0,d0				* 縦方向は一ラインおきになる
	andi.l	#%00011111_11111000_00000000,d0
	or.w	d1,d0
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

*
*	ＳＣＲＥＥＮ７，８はちょうど同じになる
*
s_GRAPHIC6:
s_GRAPHIC7:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	lsl.l	#2,d1
	move.l	d1,d0
	andi.w	#%00000000_00000011_11111111,d1
	add.l	d0,d0				* 縦方向は一ラインおきになる
	andi.l	#%00001111_11111000_00000000,d0
	or.w	d1,d0
	add.l	#$c00000,d0
	move.l	d0,offset_ms_vdp_gram_addr(a5)

	rts

s_SCREEN10:
s_SCREEN12:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	rts

***************************************************************
*
*	ＶＲＡＭ読み込みルーチン
*
*	d0.b に読みこんだ値を入れて rts
*
***************************************************************
r_GRAPHIC4_mac:					* SCREEN 5
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	move.w	(a0),d0				* d0 = 00000000_0000****
	lsl.w	#4,d0				* d0 = 00000000_****0000
	or.w	4(a0),d0			* d0 = 00000000_****&&&&

	lea.l	8(a0),a0
	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_01111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts

r_GRAPHIC5_mac:					* SCREEN 6
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	move.w	(a0)+,d0
	lsl.w	#6,d0
	move.w	(a0)+,d1
	andi.w	#%00000011,d1
	lsl.w	#4,d1
	or.w	d1,d0
	move.w	(a0)+,d1
	andi.w	#%00000011,d1
	lsl.w	#2,d1
	or.w	d1,d0
	move.w	(a0)+,d1
	andi.w	#%00000011,d1
	or.w	d1,d0

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_01111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts

r_GRAPHIC6_mac:					* SCREEN 7
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	move.w	(a0)+,d0
	lsl.w	#4,d0
	or.w	(a0)+,d0

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_11111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts

r_GRAPHIC7_mac:					* SCREEN 8
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	move.l	(a0)+,d0			* d0 = 00000000_********
						* 姑息な高速化
	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_11111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024*2(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts

***************************************************************
*
*	ＶＲＡＭ書き込みルーチン
*
*	d1.b に書き込む値を入れてコール
*
***************************************************************

* デバッグように描画量を削減するためのフラグ
HALFDRAW	.equ	0		* 1:半分のみ描画 0:全て描画
DRAWWIDTH_TX	.equ	6/(HALFDRAW+1)	* １ラインの描画回数
DRAWWIDTH_GR	.equ	8/(HALFDRAW+1)	* １ラインの描画回数
DIFFDRAW	.equ	1		* 1:変更があった時のみ描画 0:全て描画

; w_TEXT1_mac:
; 	move.l	4(sp),d1
; 	movea.l	VideoRAM,a0
; 	move.l	vram_add,d0			* D0 ・・書き込むアドレス
; 	move.b	d1,0(a0,d0.l)			* VRAM へ書き込み
; 	andi.w	#%11111100_00000000,d0		* 下位１０ビットをクリア
; 	cmp.l	R_2_pnametbl_baddr,d0
; 	bne	@f
; 	move.l	d0,-(sp)
; 	move.w	d1,-(sp)
; 	bsr	w_p_name_tx1_mac		* パターンネームテーブルへの書き込み
; 	move.w	(sp)+,d1
; 	move.l	(sp)+,d0
; @@:	andi.w	#%11111000_00000000,d0
; 	cmp.l	R_4_patgentbl_baddr,d0
; 	bne	@f
; 	bsr	w_p_gene_tx1_mac		* パターンジェネレータテーブルへの書き込み
; @@:	move.l	vram_add,d0
; 	move.w	d0,d2
; 	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
; 	andi.w	#%00111111_11111111,d2
; 	andi.w	#%11000000_00000000,d0
; 	or.w	d2,d0
; 	move.l	d0,vram_add
; 	rts

w_p_gene_tx1_mac:
*
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
*
*	rewrite_f_0	.dc.l	0
*	rewrite_f_1	.dc.l	0
*	rewrite_f_2	.dc.l	0
*	rewrite_f_3	.dc.l	0
*	rewrite_f_4	.dc.l	0
*	rewrite_f_5	.dc.l	0
*	rewrite_f_6	.dc.l	0
*	rewrite_f_7	.dc.l	0
*	
	move.w	#0,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	add.w	d1,d1
	add.w	d1,d1
	move.l	0(a0,d1.w),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w)		* rewrite_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*
w_p_name_tx1_mac:
	move.l	4(sp),d1
	move.l	d4,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	movea.l	offset_ms_vdp_gram_addr(a5),a1		* a1.l ・・・ 表示するＧＲＡＭアドレス
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	lea.l	0(a0,d0.l),a0		* a0 = 実パターンジェネレータテーブルアドレス

	clr.w	d0
	move.b	d1,d0
	add.w	d0,d0
	add.w	d0,d0
	add.w	d0,d0
	lea.l	0(a0,d0.w),a0		* a0 = 表示するフォントのアドレス

	move.w	offset_ms_vdp_text_color(a5),d2		* ２ドット同時書き込みするため
	swap	d2
	move.w	offset_ms_vdp_text_color(a5),d2
	move.w	offset_ms_vdp_back_color(a5),d3
	swap	d3
	move.w	offset_ms_vdp_back_color(a5),d3

	moveq.l	#4-1,d0			* ループカウンタ
loop1_put_char:
	move.w	(a0)+,d1		* d1 = フォントデータ


	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*4,a1	* １ライン下げる
	lsl.w	#2,d1

	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*4,a1	* １ライン下げる

	dbra	d0,loop1_put_char

	suba.l	#1024*16-24,a1		* gram_add の更新
	move.l	a1,d0
	andi.w	#$03ff,d0		* 改行したかのチェック
	cmpi.w	#$03e0,d0
	bne	@f
	adda.l	#1024*15+64,a1
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)
	move.l	(sp)+,d4
	rts

; w_TEXT2_mac:
; 	move.l	4(sp),d1
; 	movea.l	VideoRAM,a0
; 	move.l	vram_add,d0			* D0 ・・書き込むアドレス
; 	move.b	d1,0(a0,d0.l)			* VRAM へ書き込み
; 	andi.w	#%11111000_00000000,d0
; 	cmp.l	R_4_patgentbl_baddr,d0
; 	bne	@f
; 	move.l	d0,-(sp)
; 	move.w	d1,-(sp)
; 	bsr	w_p_gene_tx2			* パターンジェネレータテーブルへの書き込み
; 	move.w	(sp)+,d1
; 	move.l	(sp)+,d0
; @@:	andi.w	#%11110000_00000000,d0		* 下位１２ビットをクリア
; 	move.l	R_2_pnametbl_baddr,d0
; 	bne	@f
; 	bsr	w_p_name_tx2			* パターンネームテーブルへの書き込み
; @@:	move.l	vram_add,d0
; 	move.w	d0,d2
; 	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
; 	andi.w	#%00111111_11111111,d2
; 	andi.w	#%11000000_00000000,d0
; 	or.w	d2,d0
; 	move.l	d0,vram_add
; 	rts

w_p_gene_tx2_mac:
*
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
*
	move.w	#1,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	add.w	d1,d1
	add.w	d1,d1
	move.l	0(a0,d1.w),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w)		* rewrite_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*
w_p_name_tx2_mac:
	move.l	4(sp),d1
	move.l	d4,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
 	movea.l	offset_ms_vdp_vram(a5),a0
	movea.l	offset_ms_vdp_gram_addr(a5),a1		* a1.l ・・・ 表示するＧＲＡＭアドレス
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	lea.l	0(a0,d0.l),a0		* a0 = 実パターンジェネレータテーブルアドレス

	clr.w	d0
	move.b	d1,d0
	add.w	d0,d0
	add.w	d0,d0
	add.w	d0,d0
	lea.l	0(a0,d0.w),a0		* a0 = 表示するフォントのアドレス

	move.w	offset_ms_vdp_text_color(a5),d2
	move.w	offset_ms_vdp_back_color(a5),d3

	moveq.l	#4-1,d0			* ループカウンタ
1:
	move.w	(a0)+,d1		* d1 = フォントデータ(2ライン分一度に読む)


	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ(偶数行目)
2:
	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	3f			* 最上位ビットが１でなければ次へ	
*	move.w	d2,1024(a1)		* 前景色を表示
	move.w	d2,(a1)+
	dbra	d4,2b
	bra	@f
3:
*	move.w	d3,1024(a1)		* 背景色を表示
	move.w	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*2,a1	* １ライン下げる
	lsl.w	#2,d1

	moveq.l	#DRAWWIDTH_TX-1,d4	* ループカウンタ(奇数行目)
2:
	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	3f			* 最上位ビットが１でなければ次へ	
*	move.w	d2,1024(a1)		* 前景色を表示
	move.w	d2,(a1)+
	dbra	d4,2b
	bra	@f
3:
*	move.w	d3,1024(a1)		* 背景色を表示
	move.w	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_TX*2,a1	* １ライン下げる

	dbra	d0,1b

	suba.l	#1024*16-12,a1		* gram_add の更新
	move.l	a1,d0
	andi.w	#$03ff,d0		* 改行したかのチェック
	cmpi.w	#$03e0,d0		* (16ドットオフセット+6ドットx80文字) * 2バイト = 992 = 0x03e0
	bne	@f
	adda.l	#1024*15+64,a1
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)
	move.l	(sp)+,d4
	rts

w_GRAPHIC1_mac:
	move.l	4(sp),d1
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0			* D0 ・・書き込むアドレス
	move.b	d1,0(a0,d0.l)			* VRAM へ書き込み
	andi.w	#%11111111_11000000,d0
	cmp.l	offset_ms_vdp_colortbl_baddr(a5),d0
	bne	@f
	move.w	d1,-(sp)
	bsr	w_color_GR1			* カラーテーブルへの書き込み
	move.w	(sp)+,d1
@@:	andi.w	#%11111100_00000000,d0		* 下位１０ビットをクリア
	cmp.l	offset_ms_vdp_pnametbl_baddr(a5),d0
	bne	@f
	move.l	d0,-(sp)
	move.w	d1,-(sp)
	bsr	w_p_name_GR1			* パターンネームテーブルへの書き込み
	move.w	(sp)+,d1
	move.l	(sp)+,d0
@@:	andi.w	#%11111000_00000000,d0
	cmp.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	bne	@f
	bsr	w_p_gene_GR1			* パターンジェネレータテーブルへの書き込み
@@:	move.l	offset_ms_vdp_vram_addr(a5),d0
	move.w	d0,d2
	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
	andi.w	#%00111111_11111111,d2
	andi.w	#%11000000_00000000,d0
	or.w	d2,d0
	move.l	d0,offset_ms_vdp_vram_addr(a5)
	rts

w_color_GR1:
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
	move.w	#3,rewrite_screen	* セットした画面モードを入れる

	lea.l	rewrite_f_0,a1
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000000_00011111,d1	* d1 ・・ 書き替えたキャラクター番号/8 = 0〜31
	move.w	d1,d2
	andi.w	#%00000000_00011100,d1
	andi.w	#%00000000_00000011,d2
	beq	@f
	cmpi.w	#2,d2
	beq	2f
	bmi	1f
	ori.l	#$ff000000,0(a1,d1.w)
	rts	
@@:	ori.l	#$000000ff,0(a1,d1.w)
	rts	
1:	ori.l	#$0000ff00,0(a1,d1.w)
	rts	
2:	ori.l	#$00ff0000,0(a1,d1.w)
	rts	


w_p_gene_GR1:
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
	move.w	#3,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	add.w	d1,d1
	add.w	d1,d1
	move.l	0(a0,d1.w),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w)		* rewrite_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*	a1 ・・・・ 次に表示するＧＲＡＭアドレス
*
w_p_name_GR1:
	move.l	d4,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a1		* a1.l ・・・ 表示するＧＲＡＭアドレス
	move.l	offset_ms_vdp_colortbl_baddr(a5),d0			* d0 = カラーテーブルベースアドレス
	lea.l	0(a0,d0.l),a2		* a2 = 実カラーテーブルベースアドレス
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	lea.l	0(a0,d0.l),a0		* a0 = 実パターンジェネレータテーブルアドレス

	clr.w	d0
	move.b	d1,d0
	lsl.w	#3,d0
	lea.l	0(a0,d0.w),a0		* a0 = 表示するフォントのアドレス

	lsr.w	#6,d0

	move.b	0(a2,d0.w),d3		* ２ドット同時書き込みするため
	move.w	d3,d2
	swap	d3
	move.w	d2,d3
	lsr.w	#4,d2
	move.w	d2,d0
	swap	d2
	move.w	d0,d2

	moveq.l	#4-1,d0			* ループカウンタ
3:	move.w	(a0)+,d1		* d1 = フォントデータ

	moveq.l	#DRAWWIDTH_GR-1,d4	* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+		* 前景色を表示
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_GR*4,a1	* １ライン下げる

	moveq.l	#DRAWWIDTH_GR-1,d4	* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-DRAWWIDTH_GR*4,a1	* １ライン下げる

	dbra	d0,3b

	suba.l	#1024*16-4*8,a1		* gram_add が次の文字の位置を指すように更新
	move.l	a1,d0
	andi.w	#$03ff,d0		* 改行したかどうかのチェック
	bne	@f
	adda.l	#1024*15,a1
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)
	move.l	(sp)+,d4
	rts


w_GRAPHIC2_mac:
	link	a6,#-2

	move.l	8(a6),d1
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0			* D0 ・・書き込むアドレス
	.if DIFFDRAW=1 ;差分描画の実験
	move.b	0(a0,d0.l),d2
	sub.b	d1,d2
	move.b	d2,-2(a6)			* 差分フラグをセット
	.endif
	move.b	d1,0(a0,d0.l)			* VRAM へ書き込み

	* sprattrtbl_baddrと一致していたらスプライトアトリビュートテーブルへの書き込み
	andi.w	#%11111111_10000000,d0		* 下位7ビットをクリア
	move.l	offset_ms_vdp_sprattrtbl_baddr(a5),d2
	andi.w	#%11111111_10000000,d2
	cmp.l	d2,d0
	bne	@f
	move.l	d0,-(sp)
	bsr	w_SP_attr			* スプライトアトリビュートテーブルへの書き込み
	move.l	(sp)+,d0

	* offset_ms_vdp_pnametbl_baddr(a5)と一致していたらパターンネームテーブルへの書き込み
@@:	andi.w	#%11111100_00000000,d0		* 下位10ビットをクリア
	move.l	offset_ms_vdp_pnametbl_baddr(a5),d2
	andi.w	#%11111100_00000000,d2
	cmp.l	d2,d0
	bne	@f
	.if DIFFDRAW=1 ;差分描画の実験
	cmp.b	#0,-2(a6)			* 差分フラグをチェック
	beq	@f
	.endif
	move.l	d0,-(sp)
	bsr	w_p_name_GR2			* パターンネームテーブルへの書き込み
	move.l	(sp)+,d0

	* sprpatgentbl_baddrと一致していたらスプライトパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11111000_00000000,d0		* 下位11ビットをクリア
	move.l	offset_ms_vdp_sprpgentbl_baddr(a5),d2
	andi.w	#%11111000_00000000,d2
	cmp.l	d2,d0
	bne	@f
	move.l	d0,-(sp)
	bsr	w_SP_p_gene			* スプライトパターンジェネレータテーブルへの書き込み
	move.l	(sp)+,d0

	* pgentbl_baddr と一致していたらパターンジェネレータテーブルへの書き込み
@@:	andi.w	#%11100000_00000000,d0		* 下位13ビットをクリア
	move.l	offset_ms_vdp_pgentbl_baddr(a5),d2
	andi.w	#%11100000_00000000,d2
	cmp.l	d2,d0
	bne	@f
	move.l	d0,-(sp)
	bsr	w_p_gene_GR2			* パターンジェネレータテーブルへの書き込み
	move.l	(sp)+,d0

	* colortbl_baddrと一致していたらカラーテーブルへの書き込み
@@:	move.l	offset_ms_vdp_colortbl_baddr(a5),d2
	andi.w	#%11100000_00000000,d2
	cmp.l	d2,d0
	bne	@f
	move.l	d0,-(sp)
	bsr	w_color_GR2			* カラーテーブルへの書き込み
	move.l	(sp)+,d0

@@:	* VRAM書き込みアドレスをインクリメント
9:	move.l	offset_ms_vdp_vram_addr(a5),d0
	move.w	d0,d2
	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
	andi.w	#%00111111_11111111,d2
	andi.w	#%11000000_00000000,d0
	or.w	d2,d0
	move.l	d0,offset_ms_vdp_vram_addr(a5)

	unlk	a6
	rts

* スプライトアトリビュートテーブルへの書き込み
* d1.b ・・・ 値
w_SP_attr:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d0
	sub.l	offset_ms_vdp_sprattrtbl_baddr(a5),d0			* オフセット
	and.l	#$ff,d1
	movem.l	d0-d2,-(sp)
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレス
	jsr	_write_sprite_attribute
	lea.l	4(sp),sp
	movem.l	(sp)+,d0-d2
	rts

* スプライトパターンジェネレータテーブルへの書き込み
* d1.b ・・・ 値
w_SP_p_gene:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d0
	sub.l	offset_ms_vdp_sprpgentbl_baddr(a5),d0			* オフセット
	and.l	#$ff,d1
	movem.l	d0-d2,-(sp)
	move.l	ms_vdp_shared,-(sp)		* 構造体のアドレス
	jsr	_write_sprite_pattern
	lea.l	4(sp),sp
	movem.l	(sp)+,d0-d2
	rts


w_color_GR2:
	move.w	#4,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.l	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	move.l	(a0,d1.w*4),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,(a0,d1.w*4)		* rewrite_f_n へ書き込み
	rts	

w_p_gene_GR2:
	move.w	#4,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.l	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	move.l	0(a0,d1.w*4),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w*4)		* rewrite_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	d1.b ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,a0 ・・・ 破壊
*	a1 ・・・・ 次に表示するＧＲＡＭアドレス
*
w_p_name_GR2:
	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	d4,-(sp)

	.if DIFFDRAW=1 ;差分描画の実験
	move.l	d1,-(sp)
	move.l	offset_ms_vdp_vram_addr(a5),d1
	bsr	s_GRAPHIC2
	move.l	(sp)+,d1
	.endif

	movea.l	offset_ms_vdp_gram_addr(a5),a1	* a1.l ・・・ 表示するＧＲＡＭアドレス

	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むアドレス
	andi.l	#%00000011_00000000,d0		* d0.l ・・書き込むブロック × 0x100
	lsl.l	#3,d0				* d0.l ・・書き込むブロック × 0x800

	move.l	offset_ms_vdp_colortbl_baddr(a5),d3	* d3 = カラーテーブルベースアドレス
	andi.w	#%11100000_00000000,d3
	clr.l	d2
	move.b	d1,d2
	lsl.w	#3,d2			* キャラクタ番号*8
	add.l	d0,d2			* d2 = ブロック番号*0x800 + キャラクタ番号*8
	add.l	d2,d3
	lea.l	0(a0,d3.l),a2		* a2 = 表示するキャラのカラーテーブルアドレス

	move.l	offset_ms_vdp_pgentbl_baddr(a5),d3	* d3 = パターンジェネレータテーブルアドレス
	andi.w	#%11100000_00000000,d3
	add.l	d2,d3
	lea.l	0(a0,d3.l),a0		* a0 = 表示するフォントのアドレス

	moveq.l	#8-1,d0			* Y方向ループカウンタ(8ライン)
3:	move.b	(a0)+,d1		* d1 = フォントデータ
	move.b	(a2)+,d2		* カラーテーブルから色を取得 d2: 前景色 d3: 背景色
	move.w	d2,d3
	lsr.w	#4,d2			* 前景色
	andi.w	#%00001111,d3		* 背景色
	bne	@f
	move.w	offset_ms_vdp_back_color(a5),d3
@@:
	moveq.l	#DRAWWIDTH_GR-1,d4	* X方向ループカウンタ(8ドット)
2:	lsl.b	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
	move.w	d2,(a1)+		* 前景色を表示
	bra	@f
1:	move.w	d3,(a1)+		* 背景色を表示
@@:	dbra	d4,2b

	; 次のラインへ
	adda.l	#1024-(DRAWWIDTH_GR*2),a1
	dbra	d0,3b

	; 一つ右の文字へ
	suba.l	#1024*8-(DRAWWIDTH_GR*2),a1	* gram_add の更新
	move.l	a1,d0
	andi.w	#$01ff,d0		* 改行したかのチェック
	bne	@f
	adda.l	#1024*8-256*2,a1	* 右端まで達した場合は、実画面512のx=256の位置にいるので、7.5行下げる
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)

	move.l	(sp)+,d4
	rts

w_GRAPHIC3_mac:
	move.l	4(sp),d1

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_vram(a5),a0
	move.l	offset_ms_vdp_vram_addr(a5),d0			* D0 ・・書き込むアドレス
	move.b	d1,0(a0,d0.l)			* VRAM へ書き込み
	andi.w	#%11111100_00000000,d0		* 下位１０ビットをクリア
	cmp.l	offset_ms_vdp_pnametbl_baddr(a5),d0
	bne	@f
	move.l	d0,-(sp)
	move.w	d1,-(sp)
	bsr	w_p_name_GR3			* パターンネームテーブルへの書き込み
	move.w	(sp)+,d1
	move.l	(sp)+,d0
@@:	andi.w	#%11100000_00000000,d0
	cmp.l	offset_ms_vdp_colortbl_baddr(a5),d0
	bne	@f
	move.l	d0,-(sp)
	move.w	d1,-(sp)
	bsr	w_p_gene_GR3			* パターンジェネレータテーブルへの書き込み
	move.w	(sp)+,d1
	move.l	(sp)+,d0
@@:	cmp.l	offset_ms_vdp_pgentbl_baddr(a5),d0
	bne	@f
	bsr	w_color_GR3			* カラーテーブルへの書き込み
@@:	move.l	offset_ms_vdp_vram_addr(a5),d0
	move.w	d0,d2
	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
	andi.w	#%00111111_11111111,d2
	andi.w	#%11000000_00000000,d0
	or.w	d2,d0
	move.l	d0,offset_ms_vdp_vram_addr(a5)
	rts

w_color_GR3:
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
	move.w	#4,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	add.w	d1,d1
	add.w	d1,d1
	move.l	0(a0,d1.w),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w)		* rewrite_f_n へ書き込み
	rts	

w_p_gene_GR3:
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
	move.w	#4,rewrite_screen	* セットした画面モードを入れる

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	move.l	offset_ms_vdp_vram_addr(a5),d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	lea.l	rewrite_f_0,a0
	add.w	d1,d1
	add.w	d1,d1
	move.l	0(a0,d1.w),d0		* rewrite_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,0(a0,d1.w)		* rewrite_f_n へ書き込み
	rts	

w_p_name_GR3:
	move.l	d4,-(sp)

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a1	* a1.l ・・・ 表示するＧＲＡＭアドレス
	move.l	offset_ms_vdp_vram_addr(a5),d0	* D0 ・・書き込むアドレス
	andi.l	#%00000011_00000000,d0		* d0.l ・・書き込むブロック × 0x100
	lsl.l	#3,d0				* d0.l ・・書き込むブロック × 0x800

	move.l	offset_ms_vdp_colortbl_baddr(a5),d3			* d3 = カラーテーブルベースアドレス
	andi.w	#%11100000_00000000,d3
	clr.l	d2
	move.b	d1,d2
	lsl.w	#3,d2			* キャラクタ番号＊８
	add.l	d0,d2
	add.l	d2,d3
	lea.l	0(a0,d3.l),a2		* a2 = 表示するキャラのカラーテーブルアドレス

	move.l	offset_ms_vdp_pgentbl_baddr(a5),d3			* d3 = パターンジェネレータテーブルアドレス
	andi.w	#%11100000_00000000,d3
	add.l	d2,d3
	lea.l	0(a0,d3.l),a0		* a0 = 表示するフォントのアドレス

	moveq.l	#4-1,d0			* ループカウンタ
3:	move.w	(a0)+,d1		* d1 = フォントデータ

	move.b	(a2)+,d3		* ２ドット同時書き込みするため
	move.w	d3,d2
	swap	d3
	move.w	d2,d3
	lsr.w	#4,d2
	move.w	d2,d4
	swap	d2
	move.w	d4,d2

	moveq.l	#8-1,d4			* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+		* 前景色を表示
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-32,a1	* １ライン下げる
	move.b	(a2)+,d3		* ２ドット同時書き込みするため
	move.w	d3,d2
	swap	d3
	move.w	d2,d3
	lsr.w	#4,d2
	move.w	d2,d4
	swap	d2
	move.w	d4,d2

	moveq.l	#8-1,d4			* ループカウンタ
2:	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	1f			* 最上位ビットが１でなければ次へ	
*	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	dbra	d4,2b
	bra	@f
1:
*	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
	dbra	d4,2b

@@:	adda.l	#1024+1024-32,a1	* １ライン下げる

	dbra	d0,3b

	suba.l	#1024*16-32,a1		* gram_add の更新
	move.l	a1,d0
	andi.w	#$03ff,d0		* 改行したかのチェック
	bne	@f
	adda.l	#1024*15,a1
@@:	move.l	a1,offset_ms_vdp_gram_addr(a5)

	move.l	(sp)+,d4
	rts

w_GRAPHIC4_mac:
	move.l	4(sp),d1

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	move.b	d1,d0
	lsr.w	#4,d0
	move.w	d0,(a0)+
	move.w	d0,(a0)+
	move.w	d1,(a0)+
	move.w	d1,(a0)+

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_01111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts

w_GRAPHIC5_mac:
	move.l	4(sp),d1

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	clr.w	d0
	move.b	d1,d0
	lsr.w	#6,d0
	move.w	d0,(a0)+

	move.b	d1,d0
	andi.w	#%00110000,d0
	lsr.w	#4,d0
	move.w	d0,(a0)+

	move.b	d1,d0
	andi.w	#%00001100,d0
	lsr.w	#2,d0
	move.w	d0,(a0)+

	andi.w	#%00000011,d1
	move.w	d1,(a0)+

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_01111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts

w_GRAPHIC6_mac:
	move.l	4(sp),d1

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	clr.w	d0
	move.b	d1,d0
	lsr.w	#4,d0
	move.w	d0,(a0)+

*	andi.w	#%00001111,d1
	move.w	d1,(a0)+

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_11111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts
	
w_GRAPHIC7_mac:
	move.l	4(sp),d1

	movea.l	ms_vdp_shared,a5		* ms_vdp_t へのポインタを取得
	movea.l	offset_ms_vdp_gram_addr(a5),a0
	clr.l	d0
	move.b	d1,d0
	swap	d0
	move.b	d1,d0
	move.l	d0,(a0)+

	move.l	offset_ms_vdp_vram_addr(a5),d1
	addq.l	#1,d1				* インクリメント	
	andi.l	#%00000001_11111111_11111111,d1
	move.l	d1,offset_ms_vdp_vram_addr(a5)
	andi.w	#%00000000_00000000_11111111,d1	* ライン境界をまたいだか
	bne	@f
	lea.l	1024(a0),a0			* 一ライン飛ばす
@@:	move.l	a0,offset_ms_vdp_gram_addr(a5)
	rts


*
* VDP コマンド
*

*
*	Ｐｓｅｔ
*
PSET_G4:
	bsr	get_D_gram_add_G4
	move.b	offset_ms_vdp_clr(a5),d0
	andi.w	#%00000011,d0
	move.w	d0,(a0)

	rts

PSET_G5:
	bsr	get_D_gram_add_G5
	move.b	offset_ms_vdp_clr(a5),d0
	andi.w	#%00000011,d0
	move.w	d0,(a0)

	rts

*
*	Ｌｉｎｅ	適当バージョン
*
LINE_G5:
	movem.l	d4-d6,-(sp)

	andi.w	#%00000000_00001111,d1

	bsr	get_D_gram_add_G5	* 始点のＧＲＡＭアドレス（DX,DYから求める）

	move.b	offset_ms_vdp_arg(a5),d1
	bclr.l	#0,d1			* MAJ のテスト
	bne	9f			* 長辺がＹ方向の時

	move.w	offset_ms_vdp_ny(a5),d5
*	subq.w	#1,d5			* d5 = Ｙ方向の長さ
	
	move.w	offset_ms_vdp_nx(a5),d2		* d2 = 長辺ドット数
*	subq.w	#1,d2			* d2 = Ｘ方向の長さ

	bclr.l	#2,d1			* DIX を調べる
	bne	1f
	move.l	#2,d0
	bra	@f
1:	move.l	#-2,d0
@@:	bclr.l	#3,d1			* DIY を調べる
	bne	1f
	move.l	#1024*2,d1
	add.w	d5,offset_ms_vdp_dy(a5)
	bra	@f
1:	move.l	#-1024*2,d1
	sub.w	d5,offset_ms_vdp_dy(a5)
@@:
	move.b	offset_ms_vdp_clr(a5),d6		* color
	andi.w	#%00000011,d6

	move.w	d2,d4
	neg.w	d4			* d4 = 誤差情報初期値

	move.w	d2,d3			* d3 = ループカウンタ
	add.w	d2,d2			* d2 = 誤差情報修正値
1:
	move.w	d6,(a0)
*	move.w	d6,1024(a0)
	adda.l	d0,a0

	add.w	d5,d4
	bmi	@f
	sub.w	d2,d4	
	adda.l	d1,a0
@@:	dbra	d3,1b

	movem.l	(sp)+,d4-d6

	rts

9:
	movem.l	(sp)+,d4-d6
	rts

*
*	ＬＭＭＣ
*
LMMC_G5:
	movem.l	d4-d6,-(sp)

	andi.w	#%00000000_00001111,d1	* d1 = ロジカルオペレーション

	ori.b	#%00000001,offset_ms_vdp_s02(a5)		* CE を０ に

	bsr	get_D_gram_add_G5	* 始点のＧＲＡＭアドレス（DX,DYから求める）
	movea.l	d0,a0

	move.w	offset_ms_vdp_ny(a5),d5
	move.w	offset_ms_vdp_nx(a5),d2
	
	move.b	offset_ms_vdp_arg(a5),d1
	bclr.l	#2,d1			* DIX を調べる
	bne	1f
	move.l	#2,d0
	bra	@f
1:	move.l	#-2,d0
@@:	andi.b	#%00001000,d1		* DIY を調べる
	bne	1f
	move.l	#1024*2,d1
	move.w	offset_ms_vdp_dy(a5),d6
	add.w	d5,d6
	move.w	d6,NEXT_DY		* コマンド終了時のDYを設定
	bra	@f
1:	move.l	#-1024*2,d1
	move.w	offset_ms_vdp_dy(a5),d6
	add.w	d5,d6
	move.w	d6,NEXT_DY		* コマンド終了時のDYを設定
@@:
	move.b	offset_ms_vdp_clr(a5),d6		* color
	andi.w	#%00000011,d6

	move.l	a0,g_add_2

	move.w	d6,(a0)

	adda.l	d0,a0
	subq.w	#1,d2			* loop_x -= 1
	bne	@f
	add.l	d1,g_add_2
	move.l	g_add_2,a0
	move.w	offset_ms_vdp_nx(a5),d2		* loop_x 再設定
	subq.w	#1,d5
	bne	@f

	andi.b	#%11111110,offset_ms_vdp_s02(a5)		* コマンド終了
	move.w	NEXT_DY,offset_ms_vdp_dy(a5)
	move.l	#w_CLR,MC_add

	movem.l	(sp)+,d4-d6

	rts

@@:	move.w	d5,loop_y
	move.w	d2,loop_x
	move.l	a0,g_add
	move.l	d0,add_x
	move.l	d1,add_y

	move.l	#DO_LMMC_G5,MC_add

	movem.l	(sp)+,d4-d6

	rts

DO_LMMC_G5:
	andi.w	#%00000011,d1
	move.l	g_add,a0

	move.w	d1,(a0)

	adda.l	add_x,a0
	subq.w	#1,loop_x		* loop_x -= 1
	bne	@f
	move.l	add_y,d1
	add.l	d1,g_add_2
	move.l	g_add_2,a0
	move.w	offset_ms_vdp_nx(a5),loop_x		* loop_x 再設定
	subq.w	#1,loop_y
	bne	@f

	andi.b	#%11111110,offset_ms_vdp_s02(a5)		* コマンド終了
	move.w	NEXT_DY,offset_ms_vdp_dy(a5)
	move.l	#w_CLR,MC_add
	rts

@@:	move.l	a0,g_add
	rts
	

	.data

loop_x:	.dc.w	0
loop_y:	.dc.w	0
g_add:	.dc.l	0
g_add_2:
	.dc.l	0			* Ｙ方向のループの時に使う


add_x:	.dc.l	0			* アドレスのＸ方向増分
add_y:	.dc.l	0			* アドレスのＹ方向増分

NEXT_DY:
	.dc.w	0

	.text

***************************************************************
*
*	サブルーチン
*
***************************************************************
*
*	ＳＸ，ＳＹからＧＲＡＭアドレスを求める
*
*	(返り値)
*		a0.l	求めたアドレス
*
get_S_gram_add_G5:
	move.w	offset_ms_vdp_sy(a5),d0
	andi.l	#%00000011_11111111,d0
	add.w	#$00c0*32,d0		* gram base add
	swap	d0
	lsr.l	#5,d0			* d0.l = $c00000 + SY * 2048
	add.w	offset_ms_vdp_sx(a5),d0		* ワードでＯＫ
	add.w	offset_ms_vdp_sx(a5),d0		* d0.1 = $c00000 + SY * 2048 + SX * 2
	movea.l	d0,a0
	rts

*
*	ＤＸ，ＤＹからＧＲＡＭアドレスを求める
*
*	(返り値)
*		a0.l	求めたアドレス
*
get_D_gram_add_G4:
	move.w	offset_ms_vdp_dy(a5),d0
	andi.l	#%00000011_11111111,d0
	add.w	#$00c0*32,d0		* gram base add
	swap	d0
	lsr.l	#5,d0			* d0.l = $c00000 + DY * 2048
	movea.l	d0,a0
	move.w	offset_ms_vdp_dx(a5),d0		* ワードでＯＫ
	add.w	d0,d0
	add.w	d0,d0
	adda.w	d0,a0			* a0.l = $c00000 + DY * 2048 + DX * 4
	rts

get_D_gram_add_G5:
	move.w	offset_ms_vdp_dy(a5),d0
	andi.l	#%00000011_11111111,d0
	add.w	#$00c0*32,d0		* gram base add
	swap	d0
	lsr.l	#5,d0			* d0.l = $c00000 + DY * 2048
	add.w	offset_ms_vdp_dx(a5),d0		* ワードでＯＫ
	add.w	offset_ms_vdp_dx(a5),d0		* d0.l = $c00000 + DY * 2048 + DX * 2
	movea.l	d0,a0
	rts

***************************************************************
*
*	線分描画（整数化Bresenham＋両端描画）
*
*
***************************************************************

	.data

	.offset	0	*glineの引数構造
*
*X0:	.ds.w	1	*始点座標
*Y0:	.ds.w	1	*
*X1:	.ds.w	1	*終点座標
*Y1:	.ds.w	1	*
*COL:	.ds.w	1	*描画色
*
	.text
	.even
*
_xorline:
ARGPTR	=	4+8*4+6*4
	movem.l	d0-d7/a0-a5,-(sp)

*	bsr	set_apage

	movea.l	ARGPTR(sp),a5	*a5 = 引数列
	movem.w	(a5)+,d0-d3	*d0〜d3に座標を取り出す

 	cmp.w	d2,d0		*x0≦x1を保証する
	ble	gline0		*
	exg.l	d0,d2		*
	exg.l	d1,d3		*

gline0:	move.w	d1,d6		*始点/終点のG-RAMアドレスを求める
	move.w	d3,d7		*
	ext.l	d6		*
	ext.l	d7		*
				*
*	moveq.l	#GSFTCTR,d4	*
	asl.l	d4,d6		*
	asl.l	d4,d7		*
	add.w	d0,d6		*
	add.w	d0,d6		*
	add.w	d2,d7		*
	add.w	d2,d7		*
				*
*	movea.l	gbase,a0	*
	movea.l	a0,a2		*
	add.l	d6,a0		*a0 = 始点のG-RAMアドレス
	add.l	d7,a2		*a2 = 終点のG-RAMアドレス

*	move.w	#GNBYTE,d5	*d5 = 横1ライン分のバイト数
	sub.w	d1,d3		*d3 = y1-y0
	beq	hor_line	*y0＝y1なら水平線
	bpl	gline1
	neg.w	d3
	neg.w	d5
gline1:	sub.w	d0,d2		*d2 = x1-x0 ( >=0 )
	beq	ver_line	*x0＝x1なら垂直線
*この時点で
*	d2 = dx = abs(x1-x0) ( > 0 )
*	d3 = dy = abs(y1-y0) ( > 0 )
*	d5 = sy = sgn(y1-y0) ( -1 or 1 )
*	（ただしd5はGNBYTE倍済み）

	move.w	(a5),d0		*d0 = 描画色

	cmp.w	d3,d2		*dy＞dxならば
	bcs	yline		*　yについてループ
	beq	xyline		*dy＝dxならば45度の線

			*dx≧dyのとき
xline:	move.w	d2,d1		*d1 = dx
	neg.w	d1		*d1 = e = -dx
	move.w	d2,d6		*d6 = n = dx
	add.w	d2,d2		*d2 = 2*dx
	add.w	d3,d3		*d3 = 2*dy
	subq.w	#1,d6		*dbraの動作を計算に入れて
	lsr.w	#1,d6		*　ループカウンタを半減
	scs.b	d4		*奇数ピクセルのとき非0
	addq.l	#2,a2		*プリデクリメントする分補正
				*do {
xline0:	eor.w	d0,(a0)+	*  pset(x++,y)
	eor.w	d0,-(a2)	*  pset(--x',y')
	add.w	d3,d1		*  e += 2*dy
	bmi	xline1		*  if (e >= 0) {
	adda.w	d5,a0		*    y += sy
	suba.w	d5,a2		*    y'-= sy
	sub.w	d2,d1		*    e -= 2*dx
				*  }
xline1:	dbra	d6,xline0	*} while (--n >= 0)

	tst.b	d4		*奇数ピクセル？
	beq	done		*　そうじゃない
	bra	odd		*中央のピクセルを点灯

			*dx＜dyのとき
yline:	move.w	d3,d1		*d1 = dy
	neg.w	d1		*d1 = e = -dy
	move.w	d3,d6		*d6 = n = dy
	add.w	d2,d2		*d2 = 2*dx
	add.w	d3,d3		*d3 = 2*dy
	subq.w	#1,d6		*dbraのことを計算に入れて
	lsr.w	#1,d6		*　ループカウンタを半減
	scs.b	d4		*奇数ピクセルのとき非0
	move.w	d5,d7		*d7 = d5 + 2
	addq.w	#2,d7		*
				*do {
yline0:	add.w	d2,d1		*  e += 2*dx
	bpl	yline1		*  if (e < 0) {
	eor.w	d0,(a0)		*    pset(x,y)
	adda.w	d5,a0		*    y += sy
	eor.w	d0,(a2)		*    pset(x',y')
	suba.w	d5,a2		*    y'-= sy
				*  }
	dbra	d6,yline0
	bra	done0
				*  else {
yline1:	eor.w	d0,(a0)+	*    pset(x++,y)
	adda.w	d5,a0		*    y += sy
	eor.w	d0,(a2)		*    pset(x',y')
	suba.w	d7,a2		*    x'--, y'-= sy
	sub.w	d3,d1		*    e -= 2*dy
				*  }
	dbra	d6,yline0	*} while (--n >= 0)

done0:	tst.b	d4		*奇数ピクセル？
	beq	done		*　そうじゃない
odd:	eor.w	d0,(a0)		*中央のピクセルを点灯

done:	movem.l	(sp)+,d0-d7/a0-a5
	rts
*
hor_line:		*水平線分
	sub.w	d0,d2		*d2 = dx = x1-x0
	move.w	(a5),d0		*d0 = 描画色
hloop:	eor.w	d0,(a0)+	*pset(x++,y)
	dbra	d2,hloop
	bra	done

xyline:			*45度の線分
	addq.w	#2,d5		*d5 = 2±GNBYTE
ver_line:		*垂直線分
	move.w	(a5),d0		*d0 = 描画色
vloop:	eor.w	d0,(a0)		*pset(x,y)
	adda.w	d5,a0		*y += sx
	dbra	d3,vloop	*dy+1回繰り返す
	bra	done

**************************************************************
*
*		ワークエリア
*
**************************************************************

	.data
	.even

set_gram_add_rot:
	.dc.l	s_TEXT1

w_ContReg_mode:				* ポート＃１は２バイトひとかたまりでアクセス
	.dc.w	0			* するので、１バイト目か２バイト目かの区別を
					* するためのもの
					* ０・・１バイト目
					* １・・２バイト目
first_bite_1:				* １バイト目にどんな値が書き込まれたのかが
	.dc.b	0			* 入っている

w_PalReg_mode:
	.dc.b	0
first_bite_2:
	.dc.b	0

	.even

rewrite_screen:
		.dc.w	$ffff		* 下の rewrite_f をどの画面モードがセットしたか
					* が入る。垂直帰線期間の時に現在の画面モードと比
					* 較して、違う時にはrewrite_fをすべてクリアして
					* 何もしない。
					*  $ffff が入っている時は何も変更されていないこ
					* とを示す。

*	ＳＣＲＥＥＮ０，２，４で使う
ms_vdp_rewrite_flag_tbl:
		.dc.l	rewrite_f_0

rewrite_f_0:	.dc.l	0
rewrite_f_1:	.dc.l	0
rewrite_f_2:	.dc.l	0
rewrite_f_3:	.dc.l	0
rewrite_f_4:	.dc.l	0
rewrite_f_5:	.dc.l	0
rewrite_f_6:	.dc.l	0
rewrite_f_7:	.dc.l	0


; *	------ ＶＤＰ Ｒｅｇｉｓｔｅｒｓ ------
; ms_vdp:				* 構造体の先頭アドレス
; *	コントロールレジスタ
; Control_registers:
; R_00:	.dc.b	0		* Mode register 0

; VDP_R_01:
; R_01:	.dc.b	0		* Mode register 1
; R_02:	.dc.b	0
; R_03:	.dc.b	0
; R_04:	.dc.b	0
; R_05:	.dc.b	0
; R_06:	.dc.b	0		* Sprite
; R_07:	.dc.b	0
; R_08:	.dc.b	0		* Mode register 2
; R_09:	.dc.b	0		* Mode register 3
; R_10:	.dc.b	0		* >> R#3
; R_11:	.dc.b	0		* >> R#5
; R_12:	.dc.b	0		* TEXT color / Back color register (ブリンクで使用）
; R_13:	.dc.b	0
; R_14:	.dc.b	0		* >> vram_add
; R_15:	.dc.b	0
; R_16:	.dc.b	0		* Color Palette Address pointer
; R_17:	.dc.b	0		* Control Register pointer
; R_18:	.dc.b	0
; R_19:	.dc.b	0
; R_20:	.dc.b	0
; R_21:	.dc.b	0
; R_22:	.dc.b	0
; R_23:	.dc.b	0
; R_24:	.dc.b	0
; R_25:	.dc.b	0
; R_26:	.dc.b	0
; R_27:	.dc.b	0
; 	.dc.b	0		* dummy
; 	.dc.b	0		* dummy
; 	.dc.b	0		* dummy
; 	.dc.b	0		* dummy
; SX:	.dc.w	0		* 32,33 並びが逆になるので注意
; SY:	.dc.w	0		* 34,35
; DX:	.dc.w	0		* 36,37
; DY:	.dc.w	0		* 38,39
; NX:	.dc.w	0		* 40,41
; NY:	.dc.w	0		* 42,43
; CLR:	.dc.b	0
; ARG:	.dc.b	0
; R_46:	.dc.b	0

; 	.dc.b	0		* dummy

; *	ステータスレジスタ
; VDP_S_00:
; S_0:	.dc.b	0
; S_1:	.dc.b	%00000100		* V9958 のＩＤ
; S_2:	.dc.b	%10001100		* TR は常に１
; S_3:	.dc.b	0
; S_4:	.dc.b	%11111110
; S_5:	.dc.b	0
; S_6:	.dc.b	%11111100
; S_7:	.dc.b	0
; S_8:	.dc.b	0
; S_9:	.dc.b	%11111100

; 	.even

; *	パレットレジスタ
; *		%GGGG_GRRR_RRBB_B001
; *P_0:	.dc.w	%0000_0000_0000_0000
; *P_1:	.dc.w	%0000_0000_0000_0000
; *P_2:	.dc.w	%0000_0000_0000_0000
; *P_3:	.dc.w	%0000_0000_0000_0000
; *P_4:	.dc.w	%0000_0000_0000_0000
; *P_5:	.dc.w	%0000_0000_0000_0000
; *P_6:	.dc.w	%0000_0000_0000_0000
; *P_7:	.dc.w	%0000_0000_0000_0000
; *P_8:	.dc.w	%0000_0000_0000_0000
; *P_9:	.dc.w	%0000_0000_0000_0000
; *P_10:	.dc.w	%0000_0000_0000_0000
; *P_11:	.dc.w	%0000_0000_0000_0000
; *P_12:	.dc.w	%0000_0000_0000_0000
; *P_13:	.dc.w	%0000_0000_0000_0000
; *P_14:	.dc.w	%0000_0000_0000_0000
; *P_15:	.dc.w	%0000_0000_0000_0000

; P_0:	.dc.w	%0000_0000_0000_0000
; P_1:	.dc.w	%0000_0000_0000_0000
; P_2:	.dc.w	%1101_1001_0000_1001
; P_3:	.dc.w	%1111_1011_0101_1011
; P_4:	.dc.w	%0010_0001_0011_1111
; P_5:	.dc.w	%0110_1010_0111_1111
; P_6:	.dc.w	%0010_0101_1000_1001
; P_7:	.dc.w	%1101_1010_0111_1111
; P_8:	.dc.w	%0010_0111_1100_1001
; P_9:	.dc.w	%0110_1111_1101_1011
; P_10:	.dc.w	%1101_1110_1100_1001
; P_11:	.dc.w	%1101_1110_1110_0101
; P_12:	.dc.w	%1001_0001_0000_1001
; P_13:	.dc.w	%0100_1110_1110_1101
; P_14:	.dc.w	%1011_0101_1010_1101
; P_15:	.dc.w	%1111_1111_1111_1111

; *	.dc.w	%00000			* 0
; *	.dc.w	%00100
; *	.dc.w	%01001
; *	.dc.w	%01101			* 3
; *	.dc.w	%10010			* 4
; *	.dc.w	%10110
; *	.dc.w	%11011
; *	.dc.w	%11111			* 7

; *	特殊コントロールレジスタ
; * R_00:	.dc.b	0		* [ 0 ][ DG][IE2][IE1][ M5][ M4][ M3][ 0 ]
; * R_01:	.dc.b	0		* [ 0 ][ BL][IE0][ M1][ M2][ 0 ][ SI][MAG]	

; CRT_mode:			* R_0,R_1の[ M5]〜[ M0]
; 	.dc.b	0		* M5〜M0 がそれぞれビット５〜０に入っている
; _sprite_size:			* R_1の[ SI]
; 	.dc.b	0		* スプライトのサイズ ０・・８×８  １・・１６×１６
; sprite_zoom:			* R_1の[MAG]
; 	.dc.b	0		* スプライトの拡大   ０・・なし    １・・あり

; 	.even

; R_2_pnametbl_baddr:
; 	.dc.l	0		* Pattern name table base address
; R_3_colortbl_baddr:
; 	.dc.l	0		* Color table base address
; R_4_patgentbl_baddr:
; 	.dc.l	$0800		* Pattern generator table base address
; R_5_sprattrtbl_baddr:
; 	.dc.l	0		* Sprite attribute table bse address
; R_6_sprpatgentbl_baddr:
; 	.dc.l	0		* Sprite pattern generator table base address
; ;R_7:				  Text color / Back drop color register
; text_color:			* 文字の色
; 	.dc.w	0
; back_color:			* 背景の色
; 	.dc.w	0


; *	ＶＲＡＭアクセスアドレス
; vram_add:			* 
; 	.dc.l	0
; gram_add:
; 	.dc.l	$C00000		* gramのvram_addに対応するアドレス
; 				* 

; *	現在の画面モード
; display_mode:
; 	.dc.w	0		* 0 ・・・ TEXT1
; 				* 1 ・・・ TEXT2
; 				* 2 ・・・ multi color
; 				* 3 ・・・ GRAPHIC1
; 				* 4 ・・・ GRAPHIC2
; 				* 5 ・・・ GRAPHIC3
; 				* 6 ・・・ GRAPHIC4
; 				* 7 ・・・ GRAPHIC5
; 				* 8 ・・・ GRAPHIC6
; 				* 9 ・・・ GRAPHIC7
; 				*10 ・・・ SCREEN10
; 				*11 ・・・ SCREEN12
; *
; *	画面モード
; *	MMMMM
; *	54321
; *
; *	00000		GRAPHIC1
; *	00001		TEXT1
; *	00010		multicolor
; *	00100		GRAPHIC2
; *	01000		GRAPHIC3
; *	01001		TEXT2
; *	01100		GRAPHIC4
; *	10000		GRAPHIC5
; *	10100		GRAPHIC6
; *	11100		GRAPHIC7

; ; テキスト画面の表示 ON/OF (0:OFF 1:ON)
; tx_active:
; 	.dc.w	1
; ; MSXの画面の表示状態を勘案し、X68000の表示するグラフィックページ番号(0:OFF, 0x1-0xf:対応するページのビットを1にする)
; gr_active:
; 	.dc.w	1

; ; X68000側に確保したVRAMの先頭アドレス
; VideoRAM:
; 	.dc.l	0		* ＶＲＡＭのアドレス


; *gbase:	.dc.l	GPAGE0		* ラインルーチン内等で使用

; cliprect:
; 	.dc.w	0		*クリッピング領域
; 	.dc.w	0		*
; *	.dc.w	GNPIXEL-1	*
; *	.dc.w	GNPIXEL-1	*
; ucliprect:
; 	.dc.w	$8000		*クリッピング領域
; 	.dc.w	$8000		*（$8000のゲタ履き）
; *	.dc.w	$8000+GNPIXEL-1	*
; *	.dc.w	$8000+GNPIXEL-1	*


; fillptr:
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	255		* color

; pointptr:
; 	.dc.w	0
; 	.dc.w	0
; 	.dc.w	0		* return color code

	.even

filebuf:
	.ds.b	53 

errmes_file:
	.dc.b	"ファイルエラーです",$0d,$0a,$00
errmes_memory:
	.dc.b	"メモリが確保できません",$0d,$0a,$00

mes_screen:
	.dc.b	'ＳＣＲＥＥＮを'
num:	.dc.b	'1'
	.dc.b	'にしました。',0xd,0xa,0


number:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00

mes_w_GR1:
	.dc.b	'SCREEN1に書き込みました。',0x0d,0x0a,0x00

	.even

	.end

