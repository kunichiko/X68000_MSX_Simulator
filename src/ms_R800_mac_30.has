*
*	Ｍｓｘ Ｓｉｍｕｌａｔｅｒ
*
*		[[[ Ｒ８００ Ｓｉｍｕｌａｔｅｒ ]]]		
*			ＭＣ６８０３０以降専用バージョン
*
*				1995.9.24		by Kuni.
*

*	TODO:
*	ＲＥＴＮとＲＥＴＩをちゃんとやってない

; TODO lists
;
; # WZレジスタの実装
; WZレジスタは、LD A,(nn) の nnの値など、内部的なメモリアクセスの際のアドレスを保持するためのレジスタです。
; Z80の表面的なスペック上は見えませんが、F5,F3レジスタなどにこの値が反映されるケースがあるため、内部的には
; WZレジスタの値も追従する必要があります。
;
; # iレジスタの正確な実装
; iレジスタは、Mode2割り込みで使用される割り込みベクタの上位8ビットとして使用されます。
; MSXでは Mode2割り込みは使わないため、正確に実装していません。
;
; # rレジスタの正確な実装
; rレジスタはリフレッシュカウンタとして使われるレジスタのため、正確に実装していません。
; ただ、稀に乱数のシードなどに使われるケースがあるので、定数だとまずいケースがあり、
; 適当に実装しています。
; 正確に実装するためには、後述のZ80のサイクルを正確にカウントする必要があります。
; 
; # サイクルカウントの正確な実装
; Z80のサイクルカウントは、命令ごとに異なるサイクル数が必要です。
; これを正確に実装するためには、命令ごとにサイクル数をカウントする必要があります。

*	 31     16 15 8 7  0
*	|         |    | A  |  d4	Ａレジスタ
*	| 1st| 2nd| result  |  d5	フラグ再計算情報
*	|      xxx|dirt|flag|  d6	フラグおよび関連情報
*	| PC page | PC (8k) |  d7
*	|     registers     |  a3	a3 = レジスターの格納されているアドレス
*	|    PC Base ADD    |  a4	a4 = PC
*
*	PC Base ADD + PC(16k) = 実アドレス
*
*	PC page は PC(R800) の上位3ビットの値が入っている
*	PC(8k)  は PC(R800) の下位13ビットの値
*
*		PC(R800)  $8100  =  %100____00001_00000000 
*
*		=> d7 %00000000_00000100_00000001_00000000
*
*	registers:
*	a:	.dc.b	0	* Aレジスタは d4 を使うから使わない
*	f:	.dc.b	0	* Fレジスタは d5,d6 を使うから使わない
*	b:	.dc.b	0
*	c:	.dc.b	0
*	d:	.dc.b	0
*	e:	.dc.b	0
*	h:	.dc.b	0
*	l:	.dc.b	0
*
*	ix_h:	.dc.b	0
*	ix_l:	.dc.b	0
*	iy_h:	.dc.b	0
*	iy_l:	.dc.b	0
*
*	s:	.dc.b	0
*	p:	.dc.b	0
*

	.cpu 68030

	.include	iocscall.mac
	.include	doscall.mac
	.include	ms.mac

	.text
	.even

	; CPUから見える8Kバイト単位のメモリのポインタ配列
	.xref	ms_cpu_mem_ptr_array

	.xref	dumpsp_c

	.xref	ms_read_mem_8
	.xref	ms_read_mem_16
	.xref	ms_write_mem_8
	.xref	ms_write_mem_16

	.xref	ms_io_input_table
	.xref	ms_io_output_table

	.xref	native_jpt_add		* ６８ネイティブルーチンのジャンプテーブル

	; CPUコアに対する割り込み要求フラグ(実CPUのINT端子に相当する)
	; この1バイトの値が1になるとCPUに対する割り込み要求となる
	; このフラグ領域は本CPUコアは定義していないので、外部で定義する必要がある
	; MSXの場合はVDPのステータスレジスタ0のbit7の値が割り込み要求フラグになる
	.xref	ms_cpu_int

	.xref	HEX
	.xref	int_block_count

	.xref	ms_vsync_interrupt_tick	; TODO VDP依存を除去

	.xref	eval_flag_all
	.xref	eval_flag_SZ
	.xref	eval_flag_F5F3
	.xref	eval_flag_HC_C
	.xref	eval_flag_PV_N

	.xdef	f

	.xdef	ms_cpu_emulate
	.xdef	ms_cpu_step
	.xdef	ms_cpu_step_break
	.xdef	ms_instructions_ptr
	.xdef	ms_cpu_registers_ptr
	.xdef	ms_cpu_needs_refresh_PC

	.xdef	emu_counter
	.xdef	emu_counter_latch

	;.xdef	cpu_main
	.xdef	cpu_sub_emu_yield
	.xdef	cpu_yield		* 一定周期(VSYNC)などで必ず呼び出される割り込み要求
	.xdef	sub_yield		* その他の要因で呼ばれる割り込み要求
	.xdef	emu_yield
	.xdef	cpu_cycle_last
	.xdef	cpu_cycle_wait
	.xdef	debug_log_level
	.xdef	int_skip_counter
	.xdef	int_exec_counter
	.xdef	interrupt_history_ptr
	.xdef	interrupt_history_wr
	.xdef	interrupt_history_rd

	.xdef	base

a	equ	0
f	equ	1	
b	equ	2	
c	equ	3	
d	equ	4
e	equ	5
h	equ	6
l	equ	7
ix_h	equ	8
ix_l	equ	9
iy_h	equ	10
iy_l	equ	11
s	equ	12
p	equ	13

bc	equ	2
de	equ	4
hl	equ	6
ix	equ	8
iy	equ	10
sp_	equ	12

a_	equ	14
f_	equ	15	
b_	equ	16	
c_	equ	17	
d_	equ	18
e_	equ	19
h_	equ	20
l_	equ	21

af_	equ	14
bc_	equ	16
de_	equ	18
hl_	equ	20

r	equ	r_-base
i	equ	i_-base

wz	equ	wz_-base
w	equ	w_-base
z	equ	z_-base

target_16 equ	target_16_-base
target_8 equ	target_8_-base

MS_LOG_FATAL	equ	1
MS_LOG_ERROR	equ	2
MS_LOG_INFO	equ	3
MS_LOG_DEBUG	equ	4
MS_LOG_FINE 	equ	5
MS_LOG_TRACE	equ	6
MS_LOG_CPUTRACE equ	7

PC_page_inc	macro
		swap	d7
		addq.w	#1,d7
		andi.w	#PAGENUMMASK,d7
		lea	ms_cpu_mem_ptr_array,a4
		movea.l	(a4,d7.w*4),a4
		swap	d7
		endm

PC_page_dec	macro
		swap	d7
		subq.w	#1,d7
		andi.w	#PAGENUMMASK,d7
		lea	ms_cpu_mem_ptr_array,a4
		movea.l	(a4,d7.w*4),a4
		swap	d7
		endm

PC_page_set	macro			* JP命令等で PCが変わった時の処理
		swap	d7		* 上位 16bitに移動
		lsr.l	#8,d7		* PCの上位 3bit(Page番号)が上位ワードに残るようにする
		lsr.l	#8-PAGENUMBIT,d7
		lsr.w	#PAGENUMBIT,d7	* 下位16bitのみをシフト
		; この時点で以下のようになっている
		;  31     16 15 8 7  0
		; | PC page |  PC(8k) |  d7
		swap	d7
		lea	ms_cpu_mem_ptr_array,a4
		movea.l	(a4,d7.w*4),a4
		swap	d7
		endm

write_mem_8	macro
		jsr	ms_write_mem_8
		jsr	refresh_PC_if_needed
		endm

write_mem_16	macro
		jsr	ms_write_mem_16
		jsr	refresh_PC_if_needed
		endm

	.text

;
;
refresh_PC_if_needed:
	tst.w	ms_cpu_needs_refresh_PC
	beq	1f
	move.w	#0,ms_cpu_needs_refresh_PC
	swap	d7
	lea	ms_cpu_mem_ptr_array,a4
	movea.l	(a4,d7.w*4),a4
	swap	d7
1:	rts


	.data

; メモリ書き込みやI/Oポートへの書き込みをした後にこのフラグがセットされていたら、
; エミュレータはPCを再読み込みする必要がある
ms_cpu_needs_refresh_PC:
	.dc.w	0

cpu_cycle:
	.dc.l	0
cpu_cycle_latch:		* クリアする前にラッチした値
	.dc.l	0
cpu_cycle_last:			* C側に見せている値(デバッグ表示中に重くなって値が変わるのを回避)
	.dc.l	0
cpu_cycle_wait:
	.dc.l	0
cpu_cycle_wait_max:
	.dc.l	$7fffffff
emu_counter:
	.dc.l	0
emu_counter_latch:
	.dc.l	0
emu_counter_latch_r:		* Rレジスタ用のラッチ
	.dc.l	0
int_skip_counter:
	.dc.l	0
int_exec_counter:
	.dc.l	0
emu_yield_div:
	.dc.w	0

interrupt_history_ptr:
	.dc.l	interrupt_history
interrupt_history:
	; ロングワード*2 *32個のリングバッファ
	; struct interrupt_history_st {
	;    unsigned short int_tick;
	;    unsigned short process_type;
	;    unsigned long emu_counter;
	; }
	; int_tick はその時点の interrupt_tick の値
	; reason は割り込みが発生した時にどう処理したかを示す
	; 0x00: EI状態で、正常にZ80に割り込みがかかった
	; 0x01: EIだったが、emu_counterが int_block_count に達していなかったのでスキップ
	; 0x02: DI状態のため、Z80の割り込みがスキップされた
	; emu_counterには、割り込み時の emu_counter - emu_counter_latch の値を格納

	.ds.l	2*32
interrupt_history_wr:
	.dc.w	0
interrupt_history_rd:
	.dc.w	0

	.text
*
*	void ms_cpu_emulate(emu_loop_func, max_wait);
*
ms_cpu_emulate:
	link	a6,#0
	movem.l	d3-d7/a0-a5,-(sp)	* ※1 emu_endと対応
	
	move.l	8(a6),emu_loop_func		* 引数1のループ関数のポインタを保存しておく
	move.l	12(a6),cpu_cycle_wait_max	* 引数2の最大ウエイトを保存しておく

	lea.l	registers,a3
	clr.w	d7			* pc = 0
	PC_page_set
	clr.w	sp_(a3)			* sp = 0
	move.b	#$00,interrupt_enable	* DI に
	clr.b	interrupt_mode		* IM を０に

	clr.l	emu_counter
	clr.l	emu_counter_latch
	clr.w	emu_yield_div
	clr.w	interrupt_history_wr
	clr.w	interrupt_history_rd
cpu_main:
	add.b	#1,emu_counter+3
	bcc	@f
	; 256回に一回ここに入ってくる
	add.l	#$100,emu_counter
	; このタイミングでちょっと重めの処理を入れると、影響が1/256になる
	; ウエイトが必要な場合はウエイトを入れる
	bsr	do_wait
@@:	move.l	cpu_sub_emu_yield,d0
	beq	cpu_main_next
	bsr	check_yield
cpu_main_next:
	.ifdef	DEBUG
	bsr	debug_log_pc
	.endif
	bsr	cpu_exec_core
	bra	cpu_main

;
;
do_wait:
	cmp.w	#0,interrupt_return		* 割り込み中はウエイトを入れない
 	beq	@f
 	rts
@@:	move.l	cpu_cycle_wait,d0
	bne	1f
	rts
	; 単純ループだとアクセラレータなどで負荷がかからないので、VRAMの読み込み&書き込みを行う
1:	move.w	$C00000,d1
	move.w	d1,$C00000
	dbra	d0,1b
	rts

;
;
debug_log_pc:
	cmp.w	#MS_LOG_CPUTRACE,debug_log_level
	bge	@f				* ログレベルがCPUTRACEの時のみ
	rts
@@:	cmp.w	#0,interrupt_return		* 割り込み中はログを出力しない
 	beq	@f
 	rts
@@:	link	a6,#-2
	movem.l	d0-d7/a0-a6,-(sp)
	move.l	d7,d0
	move.l	d7,d1			* d1.w = 000?????_????????
	lsr.l	#3,d0			* d0.w = ppp000??_????????
	andi.w	#%11100000_00000000,d0	* d1.w = ppp00000_00000000
	or.w	d1,d0			* d0.w = ppp?????_???????? = PC (R800)

	move.w	d0,-2(a6)		* PCを保存

	cmpi.w	#$0454,d0
	blt	@f
	cmpi.w	#$045d,d0
	ble	9f

@@:	cmpi.w	#$04b7,d0
	blt	@f
	cmpi.w	#$04c0,d0
	ble	9f

@@:	cmpi.w	#$0980,d0
	blt	@f
	cmpi.w	#$098f,d0
	ble	9f

@@:	cmpi.w	#$7b70,d0
	blt	@f
	cmpi.w	#$7b7f,d0
	ble	9f

@@:	cmpi.w	#$7d60,d0
	blt	@f
	cmpi.w	#$7d6f,d0
	ble	9f

@@:	lea.l	HEX,a0

	; PC
	lea.l	cpu_pc_msg_pc,a1
	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	; OPCODE
	move.w	-2(a6),d0
	jsr	ms_read_mem_16
	ror.w	#8,d0			* エンディアンを逆にする

	lea.l	HEX,a0
	lea.l	cpu_pc_msg_opcode,a1
	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	add.l	#1,a1

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+


	; SP
	move.w	sp_(a3),d0
	lea.l	cpu_pc_msg_sp,a1

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	; HL
	move.w	hl(a3),d0
	lea.l	cpu_pc_msg_hl,a1

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	; IX
	move.w	ix(a3),d0
	lea.l	cpu_pc_msg_ix,a1

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+

	rol.w	#4,d0
	move.w	d0,d1
	andi.w	#$0f,d1
	move.b	(a0,d1.w),(a1)+


	pea.l	cpu_pc_msg
	DOS	__PRINT
	lea.l	4(sp),sp

;	move.w	#$d,d1
;	IOCS	__BITSNS
	; BITSNSのワークエリアを直接参照
	move.b	$80d,d0			* F6    : bit0
	and.b	$80e,d0			* SHIFT : bit0
	andi.b	#%00000001,d0		* F6とSHIFTの両方が押されているか？
	move.b	cpu_pc_f6_flg,d1
	lsl.b	#1,d1
	or.b	d0,d1			* b1:前回、b0:今回
	move.b	d1,cpu_pc_f6_flg
	cmp.b	#%01,d1
	bne	9f
	* SHIFT+F6が押されたらこの場でログレベルを一つ戻す(ここで調べないと止まらなくなるため)
	sub.w	#1,debug_log_level

9:	movem.l	(sp)+,d0-d7/a0-a6
	unlk	a6
	rts

	.data

cpu_pc_f6_flg:
	.dc.b	1

cpu_pc_msg:
	.dc.b	'PC:'
cpu_pc_msg_pc:
	.dc.b	'0000 '
	.dc.b	'OP:'
cpu_pc_msg_opcode:
	.dc.b	'00,00 '
	.dc.b	'SP:'
cpu_pc_msg_sp:
	.dc.b	'0000 '
	.dc.b	'HL:'
cpu_pc_msg_hl:
	.dc.b	'0000 '
	.dc.b	'IX:'
cpu_pc_msg_ix:
	.dc.b	'0000'
	.dc.b	$0d,$0a,$00

	.text
	.even

;---------------------------------------------------------------------------------------
cpu_exec_core:
	clr.w	d0			* d0 の上位ビットを０にクリア
	move.b	(a4,d7.w),d0		* 命令を読み込む
	move.b	d0,last_opcode		* 最後に実行した命令を保存
	lea.l	instructions,a0
	movea.l	(a0,d0.w*4),a0		* ジャンプ先を取得
	move.l	-4(a0),d1		* 命令のサイクル数と命令語長を取得 d1:サイクル数, d2:命令語長
	move.w	d1,d2			* 命令語長をd2にコピー(命令語長-1の値が入っているので1バイト命令の時は0が入っている)
	beq	cpu_exec_core_1		* 命令語長が1命令の時は特殊処理へ
	; サイクル数を加算
	swap	d1
	ext.l	d1
	add.l	d1,cpu_cycle
	; 2バイト目から5バイト目をd1に先読み
	move.l	1(a4,d7.w),d1
	cmpi.w	#PAGEADDRMASK-4,d7	* ページ境界をまたいでるか？
	ble	cpu_exec_core_2

; 命令語長が2以上で、かつ先読みでページ境界をまたいでいる場合
cpu_exec_core_edge:
	move.l	a0,-(sp)		* a0を保存
	; まず先に命令語長に応じてPCを進める
	move.l	d7,d0			* 元のPCをd0に残しておく
	add.w	d2,d7
	addq.w	#1,d7			* 命令語長は-1されているので+1する
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f
	; ページ境界を跨ぐ場合
	PC_page_inc
	andi.w	#PAGEADDRMASK,d7
@@:	; 次に、元のPCの場所の絶対アドレスを取得し、1バイトずつ読み出す
	; TODO: 効率が悪いがここに入る確率はいくいのでとりあえず無視している。将来的には直したい
	move.l	d0,d2
	lsr.l	#3,d2			* d2 = ppp000??_????????
	andi.w	#%11100000_00000000,d2	* d0 = ppp00000_00000000
	or.w	d2,d0			* d0 = PC (R800)
	; +1バイト目を読み直す
	addq.w	#1,d0
	move.w	d0,-(sp)
	jsr	ms_read_mem_8
	move.b	d0,d1
	move.w	(sp)+,d0
	move.l	d1,-(sp)
	; +2バイト目を読み直す
	addq.w	#1,d0
	move.w	d0,-(sp)
	jsr	ms_read_mem_8
	move.b	d0,d2
	move.w	(sp)+,d0
	move.l	(sp)+,d1
	lsl.l	#8,d1
	move.b	d2,d1
	move.l	d1,-(sp)
	; +3バイト目を読み直す
	addq.w	#1,d0
	move.w	d0,-(sp)
	jsr	ms_read_mem_8
	move.b	d0,d2
	move.w	(sp)+,d0
	move.l	(sp)+,d1
	lsl.l	#8,d1
	move.b	d2,d1
	move.l	d1,-(sp)
	; +4バイト目を読み直す
	addq.w	#1,d0
	move.w	d0,-(sp)
	jsr	ms_read_mem_8
	move.b	d0,d2
	move.w	(sp)+,d0
	move.l	(sp)+,d1
	lsl.l	#8,d1
	move.b	d2,d1

	move.l	(sp)+,a0		* a0を復元
	bra	cpu_exec_core_e

; 命令語長が2以上で、かつ先読みでページ境界をまたいでいない場合
cpu_exec_core_2:
	; 命令語長に応じてPCを進める
	add.w	d2,d7
	addq.w	#1,d7			* 命令語長は-1されているので+1する
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	cpu_exec_core_e
	; ページ境界を跨ぐ場合
	PC_page_inc
	andi.w	#PAGEADDRMASK,d7
	bra	cpu_exec_core_e

; 命令語長が1のとき　
cpu_exec_core_1:
	; サイクル数を加算
	swap	d1
	ext.l	d1
	add.l	d1,cpu_cycle
	addq.w	#1,d7			* PC += 1
	andi.w	#PAGEADDRMASK,d7	* PC がページ境界をまたいだか？
	bne	cpu_exec_core_e
	PC_page_inc
cpu_exec_core_e:
	; 命令を実行
	; この時点のレジスタは以下の通り
	; d0.l : N/A
	; d1.l : 命令語長が1の時はN/A。それ以外は2バイト目から5バイト目の値が入っている
	; d7.l : 命令語長だけ進めたPCの値
ms_cpu_jmp:					* デバッガでBP設定する時用のラベル
	jmp	(a0)				* rts を省略するためにjmpで呼び出す

;---------------------------------------------------------------------------------------


; cpu_yield, sub_yield, emu_yieldのいずれかが0でない場合の中断処理
check_yield:
	move.w	sr,d0
	move.w	d0,-(sp)
	or.w	#%00000111_00000000,d0	* 一時的に割り込み禁止
	move.w	d0,sr

	; cpu_yieldの処理
	cmpi.b	#0,cpu_yield
	beq	next_sub_yield
	subq.b	#1,cpu_yield
	bne	next_sub_yield
	bra	next_cpu_yield

next_sub_yield:
	; sub_yieldの処理
	cmpi.b	#0,sub_yield
	beq	next_emu_yield
	subq.b	#1,sub_yield
	bne	next_emu_yield
	; HSYNC割り込み処理
	cmpi.b	#0,interrupt_enable
	beq	next_emu_yield	* DIなら割り込まない
	; EI = 1だった場合、割り込みを処理するが、
	; EIの実行直後の場合は割り込みをスキップする
	cmpi.b	#$fb,last_opcode
	beq	next_emu_yield
	; あらためて割り込み要求端子の値(ms_cpu_int)を見て割り込み要求があるかどうかを見る
	cmpi.b	#0,ms_cpu_int
	beq	next_emu_yield
	bsr	INT
	bra	check_yield_rts

next_cpu_yield:
	; cpu_yieldが1→0になったので、1/60ごとの定期処理を行う
	; まずはCPUサイクル数を見て早すぎる場合のウエイト量を計算
	move.l	cpu_cycle,d0
	move.l	d0,cpu_cycle_latch
	clr.l	cpu_cycle
	cmp.l	#3579545/60*4/5,d0	* 1/60秒分のサイクル数 (MSXのM1ウエイトを考慮して4/5倍している) = 47727 = $BA6F
	blt	calc_wait_slow
calc_wait_fast:
	; 速い時
	; d0には正の数が入っているので、まずこの値と $BA6Fとの比率を計算する
	divu.w	#3579545/60*4/5,d0
	; d0:下位に商、上位に余りが入る
	; 例: 速度が1.1倍早かった時、$BA6F * 1.1 / $BA6F = $0001 (余り $12A5)
	; ひとまず、余りの1/4096 + 1をウエイトに加算(+1?+12)し、商が2以上の場合はさらに+16を加算する
	clr.l	d1
	swap	d0
	move.w	d0,d1
	clr.w	d0
	swap	d0
	lsr.w	#8,d1
	lsr.w	#4,d1
	add.l	#1,d1
	add.l	cpu_cycle_wait,d1
	bcc	1f
	; オーバーフローした場合(ないと思うが)
	move.l	#$7fffffff,d1
1:	cmp.w	#1,d0
	beq	1f
	add.l	#16,d1
	bcc	1f
	; オーバーフローした場合(ないと思うが)
	move.l	#$7fffffff,d1
1:	cmp.l	cpu_cycle_wait_max,d1
	bcs	1f
	move.l	cpu_cycle_wait_max,d1
1:	; ウエイトをセット
	move.l	d1,cpu_cycle_wait
	bra	check_interrupt
calc_wait_slow:
	; 遅い時
	; ウエイトを3/4倍にする(動作速度が4/3倍になるわけではないのでひとまずこれでOK)
	move.l	cpu_cycle_wait,d0
	move.l	d0,d1
	lsr.l	#1,d0		; 1/2倍
	lsr.l	#2,d1		; 1/4倍
	add.l	d1,d0		; 3/4倍
	move.l	d0,cpu_cycle_wait

	; 割り込み処理
check_interrupt:
	cmpi.b	#0,interrupt_enable
	beq	skip_interrupt	* DIなら割り込まない
	; EI = 1だった場合、割り込みを処理するが、
	; EIの実行直後の場合は割り込みをスキップする
	cmpi.b	#$fb,last_opcode
	beq	skip_interrupt
	; あらためて割り込み要求端子の値(ms_cpu_int)を見て割り込み要求があるかどうかを見る
	cmpi.b	#0,ms_cpu_int
	beq	next_emu_yield
	; emu_counter の増加量が int_block_count に達していなかったら割り込みを一回スキップ(実験)
	; move.l	emu_counter,d0
	; sub.l	emu_counter_latch,d0
	; cmp.l	int_block_count,d0
	; bgt	1f
	; ; Skip処理
	; addq.l	#1,int_skip_counter

	; move.w	#1,d0
	; bsr	add_interrupt_history

	; bra	check_yield_rts

1:
	addq.l	#1,int_exec_counter
	bsr	INT
	move.w	#0,d0
	bsr	add_interrupt_history
	move.l	emu_counter,emu_counter_latch	* この時点の値を覚えておく
	bra	check_yield_rts

skip_interrupt:
	move.w	#2,d0
	bsr	add_interrupt_history
	bra	next_emu_yield

	; emu_yieldの処理
next_emu_yield:
	bsr	get_emu_yield_func
	cmpi.l	#0,d0
	beq	check_yield_rts
	; C側の処理を呼び出す
	movea.l	d0,a0
	move.l	emu_counter,d0
	sub.l	emu_counter_latch,d0
	move.l	cpu_cycle_latch,cpu_cycle_last
	move.w	(sp)+,sr			* ここで割り込み許可に戻す
	movem.l	d1-d7/a0-a6,-(sp)
	move.l	d0,-(sp)			* カウンタ差分を引数として渡す
	move.l	d7,-(sp)			* PCを引数として渡す
	jsr	(a0)
	lea.l	8(sp),sp
	movem.l	(sp)+,d1-d7/a0-a6
	move.l	d0,d0
	bne	@f
	rts					* 割り込許可済みなのでそのままrts
@@:	
	; 0以外が帰ってきたのでエミュレータを終了
	; サブルーチンを1段飛ばすために、SPをインクリメント
	lea.l	4(sp),sp
	bra	emu_end

check_yield_rts:
	move.w	(sp)+,sr
	rts

; emu_yieldの処理
;
; 返り値: d0 : C側の処理ルーチンのアドレス(NULLなら何もしない)
get_emu_yield_func:
	cmpi.w	#0,emu_yield
	bne	@f
	clr.l	d0
	rts
@@:	subq.w	#1,emu_yield
	beq	@f
	clr.l	d0
	rts

	; emu_yieldが0になったので、C側の処理を呼び出す
@@:	move.l	emu_loop_func,d0
	rts

emu_end:
	movem.l	(sp)+,d3-d7/a0-a5
	unlk	a6
	moveq.l #-1,d0
	rts
dumpsp:
	movem.l	d0-d7/a0-a6,-(sp)
	move.l	d6,-(sp)
	move.l	d4,-(sp)
	move.l	d7,-(sp)
	move.l	a4,-(sp)
	move.l	a0,-(sp)
	move.w	sp_(a3),-(sp)
	move.w	#0,-(sp)
	move.l	a3,-(sp)
	jsr	dumpsp_c
	lea	28(sp),sp
	movem.l	(sp)+,d0-d7/a0-a6
	rts

*
*	void step(ms_cpu_state* context, int count);
*
ms_cpu_step_break:
	.dc.l	0

ms_cpu_step:
	link	a6,#0
	movem.l	d3-d7/a0-a5,-(sp)
	
	move.l	8(a6),a5	* 引数1のcpu contextへのポインタを取得
	move.l  12(a6),d0	* 引数2のステップ数を取得

	move.l	d0,-(sp)

;	 31     16 15 8 7  0
;	|         |    | A  |  d4	Ａレジスタ
;	|         |    |HC1 |  d5	フラグ
;	|         |flag| SZ |  d6	フラグ
;	| PC page | PC (8k) |  d7
;	|     registers     |  a3	a3 = レジスターの格納されているアドレス
;	|    PC Base ADD    |  a4	a4 = PC
;
; struct ms_cpu_state {
;	void* pc_base_addr;
; 	uint16_t pc, sp, ix, iy;
; 	uint8_t a, b, c, d, e, h, l;
; 	uint8_t a_, b_, c_, d_, e_, h_, l_, f_;
; 	uint8_t i, r;
;
; 	uint8_t f;
;
;	uint16_t wz;					// 30,31
;
; 	uint8_t iff_delay;
; 	uint8_t interrupt_mode;  // 0: IM0, 1: IM1, 2: IM2
;
; 	uint8_t halted;	// 0: normal, 1: halted
; };

	clr.l	d4
	clr.l	d5
	clr.l	d6
	clr.l	d7
	lea.l	registers,a3
	;movea.l	(a5),a4			* PC Base ADD
	move.w	4(a5),d7		* PC(64k)
	PC_page_set			* 64kのPCをページ番号と16kのPCに分解
	move.w	6(a5),sp_(a3)		* SP
	move.w	8(a5),ix_h(a3)		* IX
	move.w	10(a5),iy_h(a3)		* IY
	move.b	12(a5),d4		* A register
	move.b	d4,a(a3)		* f5,f3の値などはメモリ上に保持。その他フラグは各種レジスタに保持
	move.b	13(a5),b(a3)		* B
	move.b	14(a5),c(a3)		* C
	move.b	15(a5),d(a3)		* D
	move.b	16(a5),e(a3)		* E
	move.b	17(a5),h(a3)		* H
	move.b	18(a5),l(a3)		* L
	move.b	19(a5),a_(a3)
	move.b	20(a5),b_(a3)
	move.b	21(a5),c_(a3)
	move.b	22(a5),d_(a3)
	move.b	23(a5),e_(a3)
	move.b	24(a5),h_(a3)
	move.b	25(a5),l_(a3)
	move.b	26(a5),f_(a3)

	move.b	27(a5),i(a3)
	move.b	28(a5),r(a3)

	; フラグのセット
	clr.l	d6			* ダーティフラグなどを一通りクリア
	clr.l	d5			* フラグ再計算情報をクリア(しなくてもいいが条件を揃えるため)
	move.b	29(a5),d6		* F

	; WZレジスタのセット
	move.w	30(a5),wz(a3)

	; cycles
	move.l	36(a5),cpu_cycle

	;
	;	d0個の命令を実行
	clr.l	ms_cpu_step_break
@@:
	move.l	(sp)+,d0
@@:	move.l	d0,-(sp)

	bsr	cpu_exec_core

	;bsr	dumpsp

	move.l	(sp)+,d0
	tst.l	ms_cpu_step_break
	bne	@f
	subq.l	#1,d0
	bne	@b

@@:	
	;	実行後の結果を書き戻す
	;move.l	a4,(a5)			* PC Base ADD
	move.l	d7,d0
	swap	d7			* d7 = 00000000_00000ppp
	ror.w	#PAGENUMBIT,d7		* d7 = ppp00000_00000000
	or.w	d7,d0			* d0 = pppaaaaa_aaaaaaaa = PC (64k)
	move.w	d0,4(a5)		* PC(64k)
	move.w	sp_(a3),6(a5)		* SP
	move.w	ix_h(a3),8(a5)		* IX
	move.w	iy_h(a3),10(a5)		* IY	
	move.b	d4,12(a5)		* A
	move.b	b(a3),13(a5)		* B
	move.b	c(a3),14(a5)		* C
	move.b	d(a3),15(a5)		* D
	move.b	e(a3),16(a5)		* E
	move.b	h(a3),17(a5)		* H
	move.b	l(a3),18(a5)		* L
	move.b	a_(a3),19(a5)
	move.b	b_(a3),20(a5)
	move.b	c_(a3),21(a5)
	move.b	d_(a3),22(a5)
	move.b	e_(a3),23(a5)
	move.b	h_(a3),24(a5)
	move.b	l_(a3),25(a5)
	move.b	f_(a3),26(a5)

	move.b	i(a3),27(a5)
	move.b	r(a3),28(a5)

	; フラグの書き戻し処理
	bsr	eval_flag_all
	move.b	d6,29(a5)

	; WZレジスタの書き戻し処理
	move.w	wz(a3),30(a5)

	; cycles
	move.l	cpu_cycle,36(a5)

	movem.l	(sp)+,d3-d7/a0-a5
	unlk	a6
	moveq.l #0,d0
	rts

*
* 割り込みヒストリに情報を追記します
*	入力: d0.w	割り込みに対する対応の結果:
*		 0: EI状態で割り込みがかかった
*		 1: EIだったがスキップ
*		 2: DI状態で割り込みがスキップ
* 	破壊: a0, d0, d1
*
add_interrupt_history:
	lea	interrupt_history,a0
	move.w	interrupt_history_wr,d1
	move.w	ms_vsync_interrupt_tick,(a0,d1.w*8)
	move.w	d0,2(a0,d1.w*8)
	move.l	emu_counter,d0
	sub.l	emu_counter_latch,d0
	move.l	d0,4(a0,d1.w*8)
	addq.w	#1,d1				* wrを一つ進める
	andi.w	#$1f,d1
	move.w	interrupt_history_rd,d0
	cmp.w	d0,d1
	bne	history_not_full
	; 履歴が一杯になったので、読み出し開始位置をずらず
	addq.w	#1,d0				※ rdを一つ進める
	andi.w	#$1f,d0
history_not_full:
	move.w	d1,interrupt_history_wr
	move.w	d0,interrupt_history_rd

	rts


*******************************************************************
* 基本命令ジャンプテーブル
*******************************************************************

	.data
	.quad

ms_instructions_ptr:
	.dc.l	instructions

instructions:
	.dc.l	nop				* $00
	.dc.l	LD_BC_nn
	.dc.l	LD_lBCl_A
	.dc.l	INC_BC
	.dc.l	INC_B
	.dc.l	DEC_B
	.dc.l	LD_B_n
	.dc.l	RLCA
	.dc.l	EX_AF_AFd			* $08
	.dc.l	ADD_HL_BC
	.dc.l	LD_A_lBCl
	.dc.l	DEC_BC
	.dc.l	INC_C
	.dc.l	DEC_C
	.dc.l	LD_C_n
	.dc.l	RRCA				* $0f

	.dc.l	DJNZ				* $10
	.dc.l	LD_DE_nn
	.dc.l	LD_lDEl_A
	.dc.l	INC_DE
	.dc.l	INC_D
	.dc.l	DEC_D
	.dc.l	LD_D_n
	.dc.l	RLA
	.dc.l	JR				* $18
	.dc.l	ADD_HL_DE
	.dc.l	LD_A_lDEl
	.dc.l	DEC_DE
	.dc.l	INC_E
	.dc.l	DEC_E
	.dc.l	LD_E_n
	.dc.l	RRA				* $1f

	.dc.l	JR_NZ				* $20
	.dc.l	LD_HL_nn
	.dc.l	LD_lnnl_HL
	.dc.l	INC_HL
	.dc.l	INC_H
	.dc.l	DEC_H
	.dc.l	LD_H_n
	.dc.l	DAA
	.dc.l	JR_Z				* $28
	.dc.l	ADD_HL_HL
	.dc.l	LD_HL_lnnl
	.dc.l	DEC_HL
	.dc.l	INC_L
	.dc.l	DEC_L
	.dc.l	LD_L_n
	.dc.l	CPL				* $2f

	.dc.l	JR_NC				* $30
	.dc.l	LD_SP_nn
	.dc.l	LD_lnnl_A
	.dc.l	INC_SP
	.dc.l	INC_lHLl
	.dc.l	DEC_lHLl
	.dc.l	LD_lHLl_n
	.dc.l	SCF
	.dc.l	JR_C				* $38
	.dc.l	ADD_HL_SP
	.dc.l	LD_A_lnnl
	.dc.l	DEC_SP
	.dc.l	INC_A
	.dc.l	DEC_A
	.dc.l	LD_A_n
	.dc.l	CCF				* $3f

	.dc.l	LD_B_B				* 0
	.dc.l	LD_B_C
	.dc.l	LD_B_D
	.dc.l	LD_B_E
	.dc.l	LD_B_H
	.dc.l	LD_B_L
	.dc.l	LD_B_lHLl
	.dc.l	LD_B_A
	.dc.l	LD_C_B				* $08
	.dc.l	LD_C_C
	.dc.l	LD_C_D
	.dc.l	LD_C_E
	.dc.l	LD_C_H
	.dc.l	LD_C_L
	.dc.l	LD_C_lHLl
	.dc.l	LD_C_A				* $0f

	.dc.l	LD_D_B				* $50
	.dc.l	LD_D_C
	.dc.l	LD_D_D
	.dc.l	LD_D_E
	.dc.l	LD_D_H
	.dc.l	LD_D_L
	.dc.l	LD_D_lHLl
	.dc.l	LD_D_A
	.dc.l	LD_E_B				* $58
	.dc.l	LD_E_C
	.dc.l	LD_E_D
	.dc.l	LD_E_E
	.dc.l	LD_E_H
	.dc.l	LD_E_L
	.dc.l	LD_E_lHLl
	.dc.l	LD_E_A				* $5f

	.dc.l	LD_H_B				* $60
	.dc.l	LD_H_C
	.dc.l	LD_H_D
	.dc.l	LD_H_E
	.dc.l	LD_H_H
	.dc.l	LD_H_L
	.dc.l	LD_H_lHLl
	.dc.l	LD_H_A
	.dc.l	LD_L_B				* $68
	.dc.l	LD_L_C
	.dc.l	LD_L_D
	.dc.l	LD_L_E
	.dc.l	LD_L_H
	.dc.l	LD_L_L
	.dc.l	LD_L_lHLl
	.dc.l	LD_L_A				* $6f

	.dc.l	LD_lHLl_B			* $70
	.dc.l	LD_lHLl_C
	.dc.l	LD_lHLl_D
	.dc.l	LD_lHLl_E
	.dc.l	LD_lHLl_H
	.dc.l	LD_lHLl_L
	.dc.l	HALT
	.dc.l	LD_lHLl_A
	.dc.l	LD_A_B				* $78
	.dc.l	LD_A_C
	.dc.l	LD_A_D
	.dc.l	LD_A_E
	.dc.l	LD_A_H
	.dc.l	LD_A_L
	.dc.l	LD_A_lHLl
	.dc.l	LD_A_A				* $7f

	.dc.l	ADD_A_B				* $80
	.dc.l	ADD_A_C
	.dc.l	ADD_A_D
	.dc.l	ADD_A_E
	.dc.l	ADD_A_H
	.dc.l	ADD_A_L
	.dc.l	ADD_A_lHLl
	.dc.l	ADD_A_A
	.dc.l	ADC_A_B				* $88
	.dc.l	ADC_A_C
	.dc.l	ADC_A_D
	.dc.l	ADC_A_E
	.dc.l	ADC_A_H
	.dc.l	ADC_A_L
	.dc.l	ADC_A_lHLl
	.dc.l	ADC_A_A				* $8f

	.dc.l	SUB_B				* $90
	.dc.l	SUB_C
	.dc.l	SUB_D
	.dc.l	SUB_E
	.dc.l	SUB_H
	.dc.l	SUB_L
	.dc.l	SUB_lHLl
	.dc.l	SUB_A
	.dc.l	SBC_A_B				* $98
	.dc.l	SBC_A_C
	.dc.l	SBC_A_D
	.dc.l	SBC_A_E
	.dc.l	SBC_A_H
	.dc.l	SBC_A_L
	.dc.l	SBC_A_lHLl
	.dc.l	SBC_A_A				* $9f

	.dc.l	AND_B				* $A0
	.dc.l	AND_C
	.dc.l	AND_D
	.dc.l	AND_E
	.dc.l	AND_H
	.dc.l	AND_L
	.dc.l	AND_lHLl
	.dc.l	AND_A
	.dc.l	XOR_B				* $A8
	.dc.l	XOR_C
	.dc.l	XOR_D
	.dc.l	XOR_E
	.dc.l	XOR_H
	.dc.l	XOR_L
	.dc.l	XOR_lHLl
	.dc.l	XOR_A				* $Af

	.dc.l	OR_B				* $B0
	.dc.l	OR_C
	.dc.l	OR_D
	.dc.l	OR_E
	.dc.l	OR_H
	.dc.l	OR_L
	.dc.l	OR_lHLl
	.dc.l	OR_A
	.dc.l	CP_B				* $B8
	.dc.l	CP_C
	.dc.l	CP_D
	.dc.l	CP_E
	.dc.l	CP_H
	.dc.l	CP_L
	.dc.l	CP_lHLl
	.dc.l	CP_A				* $Bf

	.dc.l	RET_NZ				* $C0
	.dc.l	POP_BC
	.dc.l	JP_NZ
	.dc.l	JP
	.dc.l	CALL_NZ
	.dc.l	PUSH_BC
	.dc.l	ADD_A_n
	.dc.l	RST_00H
	.dc.l	RET_Z				* $C8
	.dc.l	RET
	.dc.l	JP_Z
	.dc.l	CB				* $CB ライン命令
	.dc.l	CALL_Z
	.dc.l	CALL
	.dc.l	ADC_A_n
	.dc.l	RST_08H				* $Cf

	.dc.l	RET_NC				* $D0
	.dc.l	POP_DE
	.dc.l	JP_NC
	.dc.l	OUT_n_A
	.dc.l	CALL_NC
	.dc.l	PUSH_DE
	.dc.l	SUB_n
	.dc.l	RST_10H
	.dc.l	RET_C				* $D8
	.dc.l	EXX
	.dc.l	JP_C
	.dc.l	IN_A_n
	.dc.l	CALL_C
	.dc.l	DD				* $DD ライン命令
	.dc.l	SBC_A_n
	.dc.l	RST_18H				* $Df

	.dc.l	RET_PO				* $E0
	.dc.l	POP_HL
	.dc.l	JP_PO
	.dc.l	EX_lSPl_HL
	.dc.l	CALL_PO
	.dc.l	PUSH_HL
	.dc.l	AND_n
	.dc.l	RST_20H
	.dc.l	RET_PE				* $E8
	.dc.l	JP_lHLl
	.dc.l	JP_PE
	.dc.l	EX_DE_HL
	.dc.l	CALL_PE
	.dc.l	ED				* $ED ライン命令
	.dc.l	XOR_n
	.dc.l	RST_28H				* $Ef

	.dc.l	RET_P				* $F0
	.dc.l	POP_AF
	.dc.l	JP_P
	.dc.l	DI
	.dc.l	CALL_P
	.dc.l	PUSH_AF
	.dc.l	OR_n
	.dc.l	RST_30H
	.dc.l	RET_M				* $F8
	.dc.l	LD_SP_HL
	.dc.l	JP_M
	.dc.l	EI
	.dc.l	CALL_M
	.dc.l	FD				* $FD ライン命令
	.dc.l	CP_n
	.dc.l	RST_38H				* $ff

	.text

*	------ 割り込み処理 ------
INT:	move.b	#0,interrupt_enable	* DI に
	cmpi.b	#1,interrupt_mode	* 割り込みがかかった時の処理
	bhi	mode2
					* モード０割り込みは実現できない
mode1:	move.l	d7,d1
	swap	d7		* d7 = 00000000_00000ppp
	ror.w	#PAGENUMBIT,d7	* d7 = ppp00000_00000000
	or.w	d7,d1		* d1 = pppaaaaa_aaaaaaaa = PC (64k)
	move.w	d1,interrupt_return	* 戻り先アドレスを保存
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	write_mem_16

	move.w	#$0038,d7
	PC_page_set
	rts

mode2:	move.l	d7,d1
	swap	d7		* d7 = 00000000_00000ppp
	ror.w	#PAGENUMBIT,d7	* d7 = ppp00000_00000000
	or.w	d7,d1		* d1 = pppaaaaa_aaaaaaaa = PC (64k)
	subq.w	#2,sp_(a3)	* PUSH	
	move.w	sp_(a3),d0
	write_mem_16

	move.b	i(a3),d0
	lsl.w	#8,d0

	jsr	ms_read_mem_16
	move.w	d0,d7
	PC_page_set
	rts


	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
nop:	rts

*
*	-------- ＬＤ --------
*
*	------ ＬＤ Ａ,？ ------
	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_A:	rts

	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_B:	move.b	b(a3),d4
	rts

	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_C:	move.b	c(a3),d4
	rts

	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_D:	move.b	d(a3),d4
	rts

	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_E:	move.b	e(a3),d4
	rts

	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_H:	move.b	h(a3),d4
	rts

	.dc.w	4			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_L:	move.b	l(a3),d4
	rts

	.dc.w	7			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	rts

	.dc.w	7			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_lBCl:
	move.w	bc(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	rts

	.dc.w	7			* サイクル数
	.dc.w	0			* 命令語長-1
LD_A_lDEl:
	move.w	de(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	rts

	.dc.w	13			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_A_lnnl:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d4
	rts

*	------ ＬＤ Ｂ,？ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_A:	move.b	d4,b(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_B:	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_C:	move.b	c(a3),b(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_D:	move.b	d(a3),b(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_E:	move.b	e(a3),b(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_H:	move.b	h(a3),b(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_L:	move.b	l(a3),b(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_B_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,b(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,b(a3)
	rts

*	------ ＬＤ Ｃ,？ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_A:	move.b	d4,c(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_B:	move.b	b(a3),c(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_C:	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_D:	move.b	d(a3),c(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_E:	move.b	e(a3),c(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_H:	move.b	h(a3),c(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_L:	move.b	l(a3),c(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_C_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,c(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,c(a3)
	rts

*	------ ＬＤ Ｄ,？ ------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_A:	move.b	d4,d(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_B:	move.b	b(a3),d(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_C:	move.b	c(a3),d(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_D:	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_E:	move.b	e(a3),d(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_H:	move.b	h(a3),d(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_L:	move.b	l(a3),d(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_D_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d(a3)
	rts

*	------ ＬＤ Ｅ,？ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_A:	move.b	d4,e(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_B:	move.b	b(a3),e(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_C:	move.b	c(a3),e(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_D:	move.b	d(a3),e(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_E:	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_H:	move.b	h(a3),e(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_L:	move.b	l(a3),e(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_E_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,e(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,e(a3)
	rts

*	------ ＬＤ Ｈ,？ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_A:	move.b	d4,h(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_B:	move.b	b(a3),h(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_C:	move.b	c(a3),h(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_D:	move.b	d(a3),h(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_E:	move.b	e(a3),h(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_H:	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_L:	move.b	l(a3),h(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_H_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,h(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_H_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,h(a3)
	rts

*	------ ＬＤ Ｌ,？ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_A:	move.b	d4,l(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_B:	move.b	b(a3),l(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_C:	move.b	c(a3),l(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_D:	move.b	d(a3),l(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_E:	move.b	e(a3),l(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_H:	move.b	h(a3),l(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_L:	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_L_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,l(a3)
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_L_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,l(a3)
	rts

*	------ ＬＤ （ＨＬ）,？
	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lHLl_A:
	move.w	hl(a3),d0
	move.b	d4,d1
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lHLl_B:
	move.w	hl(a3),d0
	move.b	b(a3),d1
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lHLl_C:
	move.w	hl(a3),d0
	move.b	c(a3),d1
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lHLl_D:
	move.w	hl(a3),d0
	move.b	d(a3),d1
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lHLl_E:
	move.w	hl(a3),d0
	move.b	e(a3),d1
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lHLl_H:
	move.w	hl(a3),d0
	move.b	h(a3),d1
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lHLl_L:
	move.w	hl(a3),d0
	move.b	l(a3),d1
	write_mem_8
	rts

	.dc.w	10			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_lHLl_n:
	move.w	hl(a3),d0
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lBCl_A:
	move.w	bc(a3),d0
	move.b	d4,d1
	write_mem_8
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_lDEl_A:
	move.w	de(a3),d0
	move.b	d4,d1
	write_mem_8
	rts

	.dc.w	13			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lnnl_A:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0
	move.b	d4,d1
	write_mem_8
	rts


*	------ ＬＤ ＸＸ,nn ------
	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_BC_nn:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,bc(a3)
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_DE_nn:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,de(a3)
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_HL_nn:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,hl(a3)
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_SP_nn:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,sp_(a3)
	rts

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
LD_SP_HL:
	move.w	hl(a3),sp_(a3)
	rts


*	------ ＬＤ ＨＬ,(nn) ------
	.dc.w	16			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_HL_lnnl:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0
	jsr	ms_read_mem_16
	move.w	d0,hl(a3)
	rts

*	------ ＬＤ (nn),ＨＬ ------
	.dc.w	16			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lnnl_HL:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0
	move.w	hl(a3),d1
	write_mem_16
	rts

*------ ＡＤＤ ------

;---------------------------------------------------------------------------------------
ADD_A_X macro
	; b18 : 加算なので0
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 加算なのでN=0
	andi.l	#%000_11111101_11111101,d6
	ori.l	#%000_11111101_00000000,d6	* S,Z,F5,H,F3,PV,Cのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 足す数を 第2項に
	swap	d5
	add.b	d0,d4			* 演算実行
	move.b	d4,d5			* 結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_A:
	move.b	d4,target_8(a3)
	ADD_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_B:
	move.b	b(a3),target_8(a3)
	ADD_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_C:
	move.b	c(a3),target_8(a3)
	ADD_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_D:
	move.b	d(a3),target_8(a3)
	ADD_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_E:
	move.b	e(a3),target_8(a3)
	ADD_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_H:
	move.b	h(a3),target_8(a3)
	ADD_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_L:
	move.b	l(a3),target_8(a3)
	ADD_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_A_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	ADD_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_A_n:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	ADD_A_X
	rts

;---------------------------------------------------------------------------------------
; ADD HL,XX の挙動は以下の通り
; * S : 変化しない
; * Z : 変化しない
; * F5: 上位8bitの加算の結果のbit5
; * H : 上位8bitの加算の実行によるハーフキャリー
; * F3: 上位8bitの加算の結果のbit5
; * PV: 変化しない
; * N : 0
; * C : 上位8bitの加算の実行によるキャリー
ADD_HL_XX macro
	bsr	eval_flag_all
	; b18 : 加算なので0
	; b17 : 算術演算なので0
	; b16 : キャリーなしなので0
	; b1  : 加算なのでN=0
	andi.l	#%000_00000000_11000100,d6	* S,Z,PVのみ保存
	ori.l	#%000_00111001_00000000,d6	* F5,H,F3,Cのダーティビットを立てる
	move.w	hl(a3),d0
	move.w	target_16(a3),d1
	add.b	d1,d0			* 下位８ビットを加算
	bcc	@f			* キャリーが発生していない場合はスキップ
	ori.l	#%001_00000000_00000000,d6	* 再計算用キャリーをセット
@@:	move.b	d0,l(a3)		* 下位８ビットを保存
	lsr.w	#8,d0
	lsr.w	#8,d1
	move.b	d0,d5			* 第1項
	lsl.w	#8,d5
	move.b	d1,d5			* 足す数を 第2項に
	swap	d5
	and.b	#%11101111,ccr		* Xフラグをクリア
	btst	#16,d6
	beq	1f
	or.b	#%00010000,ccr		* Xフラグをセット
1:	addx.b	d1,d0			* 演算実行
	move.b	d0,d5			* 結果を保存
	move.b	d0,h(a3)		* 上位８ビットを保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_HL_BC:
	move.w	bc(a3),target_16(a3)
	ADD_HL_XX
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_HL_DE:
	move.w	de(a3),target_16(a3)
	ADD_HL_XX
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_HL_HL:
	move.w	hl(a3),target_16(a3)
	ADD_HL_XX
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADD_HL_SP:
	move.w	sp_(a3),target_16(a3)
	ADD_HL_XX
	rts


*	------ ＡＤＣ ------
;---------------------------------------------------------------------------------------
ADC_A_X macro
	move.w	d0,-(sp)
	bsr	eval_flag_HC_C		* HC,C フラグを再評価
	move.w	(sp)+,d0
	btst.l	#0,d6
	beq	ADC_A_X_fallback	* Cy が０の時 ADD と同じ
	; b18 : 加算なので0
	; b17 : 算術演算なので0
	; b16 : 事前キャリーありなので1
	; b1  : 加算なのでN=0
	andi.l	#%000_11111101_11111101,d6
	ori.l	#%001_11111101_00000000,d6	* S,Z,F5,H,F3,PV,Cのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 足す数を 第2項に
	swap	d5
	or.b	#%00010000,ccr		* Xフラグをセット
	addx.b	d0,d4			* 演算実行
	move.b	d4,d5			* 結果を保存
	endm

ADC_A_X_fallback:
	ADD_A_X
	rts
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_A:
	move.b	d4,target_8(a3)
	ADC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_B:
	move.b	b(a3),target_8(a3)
	ADC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_C:
	move.b	c(a3),target_8(a3)
	ADC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_D:
	move.b	d(a3),target_8(a3)
	ADC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_E:
	move.b	e(a3),target_8(a3)
	ADC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_H:
	move.b	h(a3),target_8(a3)
	ADC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_L:
	move.b	l(a3),target_8(a3)
	ADC_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
ADC_A_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	ADC_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADC_A_n:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	ADC_A_X
	rts

*	------ ＳＵＢ ------
;---------------------------------------------------------------------------------------
SUB_A_X macro
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 減算なのでN=1
	andi.l	#%000_11111101_11111101,d6
	ori.l	#%100_11111101_00000010,d6	* S,Z,F5,H,F3,PV,Cのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 引く数を 第2項に
	swap	d5
	sub.b	d0,d4			* 演算実行
	move.b	d4,d5			* 結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_A:	move.b	d4,target_8(a3)
	SUB_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_B:	move.b	b(a3),target_8(a3)
	SUB_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_C:	move.b	c(a3),target_8(a3)
	SUB_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_D:	move.b	d(a3),target_8(a3)
	SUB_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_E:	move.b	e(a3),target_8(a3)
	SUB_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_H:	move.b	h(a3),target_8(a3)
	SUB_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_L:	move.b	l(a3),target_8(a3)
	SUB_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
SUB_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SUB_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
SUB_n:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	SUB_A_X
	rts

*	------ ＳＢＣ ------
;---------------------------------------------------------------------------------------
SBC_A_X macro
	bsr	eval_flag_HC_C		* HC,C フラグを再評価
	btst.l	#0,d6
	beq	SBC_A_X_fallback		* Cy が０の時 SUB と同じ
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーありなので1
	; b1  : 減算なのでN=1
	andi.l	#%000_11111101_11111101,d6
	ori.l	#%101_11111101_00000010,d6	* S,Z,F5,H,F3,PV,Cのダーティビットを立てる。
	move.b	target_8(a3),d0
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 引く数を 第2項に
	swap	d5
	or.b	#%00010000,ccr		* Xフラグをセット
	subx.b	d0,d4			* 演算実行
	move.b	d4,d5			* 結果を保存
	endm

SBC_A_X_fallback:
	SUB_A_X
	rts
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_A:
	move.b	d4,target_8(a3)
	SBC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_B:
	move.b	b(a3),target_8(a3)
	SBC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_C:
	move.b	c(a3),target_8(a3)
	SBC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_D:
	move.b	d(a3),target_8(a3)
	SBC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_E:
	move.b	e(a3),target_8(a3)
	SBC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_H:
	move.b	h(a3),target_8(a3)
	SBC_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_L:
	move.b	l(a3),target_8(a3)
	SBC_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
SBC_A_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SBC_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
SBC_A_n:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	SBC_A_X
	rts


*	------ ＡＮＤ ------
;---------------------------------------------------------------------------------------
AND_X	macro
	; b18 : Don't care
	; b17 : 論理演算なので1
	; b16 : Don't care
	; b4  : AND演算時はH=1固定
	; b1  : 論理演算時はN=0
	; b0  : AND演算時はC=0固定
	andi.l	#%000_11101100_11101100,d6
	ori.l	#%010_11101100_00010000,d6	* S,Z,F5,F3,PV,Cのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 演算対象を 第2項に
	swap	d5
	and.b	d0,d4			* 演算実行
	move.b	d4,d5			* 結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_A:	move.b	d4,target_8(a3)
	AND_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_B:	move.b	b(a3),target_8(a3)
	AND_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_C:	move.b	c(a3),target_8(a3)
	AND_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_D:	move.b	d(a3),target_8(a3)
	AND_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_E:	move.b	e(a3),target_8(a3)
	AND_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_H:	move.b	h(a3),target_8(a3)
	AND_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_L:	move.b	l(a3),target_8(a3)
	AND_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
AND_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	AND_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
AND_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	AND_X
	rts

*	------ ＸＯＲ ------
;---------------------------------------------------------------------------------------
_OR_X	macro	opname
	; b18 : Don't care
	; b17 : 論理演算なので1
	; b16 : Don't care
	; b4  : OR/XOR演算時はH=0固定
	; b1  : 論理演算時はN=0
	; b0  : AND演算時はC=0固定
	andi.l	#%000_11101100_11101100,d6
	ori.l	#%010_11101100_00000000,d6	* S,Z,F5,F3,PV,Cのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 演算対象を 第2項に
	swap	d5
	opname.b	d0,d4			* 演算実行
	move.b	d4,d5			* 結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_A:	move.b	d4,target_8(a3)
	_OR_X	eor
	rts	

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_B:	move.b	b(a3),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_C:	move.b	c(a3),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_D:	move.b	d(a3),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_E:	move.b	e(a3),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_H:	move.b	h(a3),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_L:	move.b	l(a3),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
XOR_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	_OR_X	eor
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
XOR_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	_OR_X	eor
	rts

*	------ ＯＲ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_A:	move.b	d4,target_8(a3)
	_OR_X	or
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_B:	move.b	b(a3),target_8(a3)
	_OR_X	or
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_C:	move.b	c(a3),target_8(a3)
	_OR_X	or
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_D:	move.b	d(a3),target_8(a3)
	_OR_X	or
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_E:	move.b	e(a3),target_8(a3)
	_OR_X	or
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_H:	move.b	h(a3),target_8(a3)
	_OR_X	or
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_L:	move.b	l(a3),target_8(a3)
	_OR_X	or
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
OR_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	_OR_X	or
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
OR_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	_OR_X	or
	rts

*	------ ＣＰ ------
;---------------------------------------------------------------------------------------
; CP X の挙動は以下の通り
; * S : 結果の最上位ビット
; * Z : 結果が0の時 1、それ以外の時 0
; * F5: 引く n の bit5 (SUBとは動作が違う)
; * H : 演算の結果
; * F3: 引く n の bit3 (SUBとは動作が違う)
; * PV: 演算の結果のオーバーフロー
; * N : 1
; * C : 演算の結果のキャリー
CP_A_X	macro
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 減算なのでN=1
	andi.l	#%000_11010101_11010101,d6
	ori.l	#%100_11010101_00000010,d6	* S,Z,H,PV,Cのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 引く数を 第2項に
	swap	d5
	move.b	d4,d5			* Aレジスタをd5にコピー
	sub.b	d0,d5			* 比較(減算)演算の結果をd5のみに反映(Aレジスタ(d4)は破壊されない)
	andi.b	#%00101000,d0		* F5,F3 のみを取り出す
	or.b	d0,d6			* F5,F3 をセット
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_A:	move.b	d4,target_8(a3)
	CP_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_B:	move.b	b(a3),target_8(a3)
	CP_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_C:	move.b	c(a3),target_8(a3)
	CP_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_D:	move.b	d(a3),target_8(a3)
	CP_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_E:	move.b	e(a3),target_8(a3)
	CP_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_H:	move.b	h(a3),target_8(a3)
	CP_A_X
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_L:	move.b	l(a3),target_8(a3)
	CP_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	1-1			* 命令語長-1
CP_lHLl:
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	CP_A_X
	rts

	.dc.w	7			* サイクル数
	.dc.w	2-1			* 命令語長-1
CP_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,target_8(a3)
	CP_A_X
	rts

*	------ ＩＮＣ ------
;---------------------------------------------------------------------------------------
INC_X	macro
	bsr	eval_flag_HC_C		* incでCフラグは変化しないので、この時点のHC,C フラグを再評価
	; b18 : 加算なので0
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 加算なのでN=0
	andi.l	#%000_11111100_11111101,d6	* Cのダーティビットをクリア(再評価したのでクリアされているはず)
	ori.l	#%000_11111100_00000000,d6	* S,Z,F5,H,F3,PVのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d0,d5			* 第1項がターゲットの値
	lsl.w	#8,d5
	move.b	#1,d5			* 足す数=1を 第2項に
	swap	d5
	addq.b	#1,d0			* 演算実行
	move.b	d0,d5			* 結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_A:	move.b	d4,target_8(a3)
	INC_X
	move.b	d0,d4			* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_B:	move.b	b(a3),target_8(a3)
	INC_X
	move.b	d0,b(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_C:	move.b	c(a3),target_8(a3)
	INC_X
	move.b	d0,c(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_D:	move.b	d(a3),target_8(a3)
	INC_X
	move.b	d0,d(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_E:	move.b	e(a3),target_8(a3)
	INC_X
	move.b	d0,e(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_H:	move.b	h(a3),target_8(a3)
	INC_X
	move.b	d0,h(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_L:	move.b	l(a3),target_8(a3)
	INC_X
	move.b	d0,l(a3)		* 結果を反映
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_lHLl:
	move.w	hl(a3),d0		* d0にHLの値をロード
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)		* D0 には (HL)の値が入っている
	INC_X
	move.b	d0,d1			* インクリメントした結果が d0に入っているので d1 に退避
	move.w	hl(a3),d0		* d0 には HL の値が入っている
	write_mem_8		* (HL) に結果を書き込む
	rts

;---------------------------------------------------------------------------------------
; INC_XX
;---------------------------------------------------------------------------------------

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_BC:	addi.w	#1,bc(a3)
	rts

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_DE:	addi.w	#1,de(a3)
	rts

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_HL:	addi.w	#1,hl(a3)
	rts

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
INC_SP:	addi.w	#1,sp_(a3)
	rts

*	------ ＤＥＣ ------
;---------------------------------------------------------------------------------------
DEC_X	macro
	bsr	eval_flag_HC_C		* incでCフラグは変化しないので、この時点のHC,C フラグを再評価
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 減算なのでN=1
	andi.l	#%000_11111100_11111101,d6	* Cのダーティビットをクリア(再評価したのでクリアされているはず)
	ori.l	#%100_11111100_00000010,d6	* S,Z,F5,H,F3,PVのダーティビットを立てる
	move.b	target_8(a3),d0
	move.b	d0,d5			* 第1項がターゲットの値
	lsl.w	#8,d5
	move.b	#1,d5			* 引く数=1を 第2項に
	swap	d5
	subq.b	#1,d0			* 演算実行
	move.b	d0,d5			* 結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_A:	move.b	d4,target_8(a3)
	DEC_X
	move.b	d0,d4			* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_B:	move.b	b(a3),target_8(a3)
	DEC_X
	move.b	d0,b(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_C:	move.b	c(a3),target_8(a3)
	DEC_X
	move.b	d0,c(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_D:	move.b	d(a3),target_8(a3)
	DEC_X
	move.b	d0,d(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_E:	move.b	e(a3),target_8(a3)
	DEC_X
	move.b	d0,e(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_H:	move.b	h(a3),target_8(a3)
	DEC_X
	move.b	d0,h(a3)		* 結果を反映
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_L:	move.b	l(a3),target_8(a3)
	DEC_X
	move.b	d0,l(a3)		* 結果を反映
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_lHLl:
	move.w	hl(a3),d0		* d0にHLの値をロード
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)		* d0 には (HL)の値が入っている
	DEC_X
	move.b	d0,d1			* デクリメントした結果が d0に入っているので d1 に退避
	move.w	hl(a3),d0		* d0 には HL の値が入っている
	write_mem_8		* (HL) に結果を書き込む
	rts

;---------------------------------------------------------------------------------------
; DEC_XX
;---------------------------------------------------------------------------------------

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_BC:	subi.w	#1,bc(a3)
	rts

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_DE:	subi.w	#1,de(a3)
	rts

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_HL:	subi.w	#1,hl(a3)
	rts

	.dc.w	6			* サイクル数
	.dc.w	1-1			* 命令語長-1
DEC_SP:	subi.w	#1,sp_(a3)
	rts


*	DAAの仕様は http://z80-heaven.wikidot.com/instructions-set:daa を参照
*	これによると以下の動きをするらしい：
*	* 直前の演算が加算の時(N=0の時):
*	  1. 下位4ビットに9より大きな値(0xa-f)が入っているか、Hフラグが1の時、0x06を加算する
*	  2. 上位4ビットに9より大きな値(0xa-f)が入っているか、Cフラグが1の時、0x60を加算する
*	* 直前の演算が減算の時(N=1の時):
*	  1. 下位4ビットに9より大きな値(0xa-f)が入っているか、Hフラグが1の時、0x06を減算する
*	  2. 上位4ビットに9より大きな値(0xa-f)が入っているか、Cフラグが1の時、0x60を減算する
*
*	● フラグ変化:
*	* S : 結果のAレジスタが、正なら0、負なら1
*	* Z : 結果のAレジスタが、0なら1、それ以外なら0
*	* F5: 結果のAレジスタの、bit5
*	* H : (ちょっと複雑なので後述)
*	* F3: 結果のAレジスタの、bit3
*	* PV: 結果のAレジスタの、パリティが偶数なら1、奇数なら0)
*	* N : 変化しない
*	* C : 2の操作(0x60の加算or減算)が発生したら1、それ以外なら0
*
*	● Hフラグ変化:
*	DAA後のHフラグは、直前の演算が加算の時(N=0の時)と、減算の時(N=1の時)で異なる。
*	* 加算の時:
*	  補正前に下位4ビットに9より大きな値(0xa-f)が入っていた場合に H フラグがセットされる
*	  →これはBCDの補正処理(+6)によって、下位4ビットが一周する(キャリーが発生する)ことを意味する
*	* 減算の時:
*	  補正前に下位4ビットに6より小さい値(0x0-5)が入っていた場合かつ、Hフラグが立っていた時に H フラグがセットされる
*	  →これはBCDの補正処理(-6)によって、下位4ビットが一周する(キャリーが発生する)ことを意味する
*
*	なので、全体をまとめると、以下のように実装すればいいことになる
*	1. 補正係数を correct = 0とする
*	2. 下位4ビットに9より大きな値(0xa-f)が入っているか、Hフラグが1の時、correct に 0x06 を加算する
*	3. Aレジスタにに0x99より大きな値が入っているか、Cフラグが1の時、correct に 0x60 を加算する
*	4. Nフラグを見て、Aレジスタにcorrectを加算 or 減算する(N=0なら加算、N=1なら減算)
*       5. S,Z,F5,H,F3 は、Aレジスタとcorrectの ADD または SUB の結果と同じになる
*       6. PVは演算結果のパリティになる
*       7. Cは上位4ビットの補正があった場合に1、それ以外は0になる
*
*	------ ＤＡＡ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DAA:	bsr	eval_flag_HC_C		* HC,C フラグを再評価
	clr.b	d0			* 補正係数を 0 に初期化
	move.b	d4,d1
	andi.b	#$0f,d1			* 下位4ビットを取り出す
	cmpi.b	#$09,d1			* 下位4ビットが9より大きい？
	bgt	1f			* 10以上の時
	btst	#4,d6			* H フラグを調べる
	beq	2f
1:	add.b	#$06,d0			* 下位4ビットが10以上の時、補正係数に 0x06 を加算
2:	clr.w	d1
	move.b	d4,d1
	cmpi.w	#$99,d1			* 0x99より大きい？ (ワードで見ないと符号あり8bitになってしまうので注意)
	bgt	1f			* 10以上の時
	btst	#0,d6			* C フラグを調べる
	beq	2f
1:	add.b	#$60,d0			* 上位4ビットが10以上の時、補正係数に 0x60 を加算
2:	move.b	d4,d5			* Aレジスタの値を第1項に
	lsl.w	#8,d5
	move.b	d0,d5			* 補正係数を第2項に
	swap	d5
	btst.l	#1,d6			* N フラグを調べる
	bne	1f
	; b18 : 加算なので0
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 加算なのでN=0(もともと0なのでそのままにしておけばOK)
	andi.l	#%000_11111000_11111010,d6	* PV,Cはこの場で計算するので、0初期化しダーティビットもクリア
	ori.l	#%000_11111000_00000000,d6	* S,Z,F5,H,F3のダーティビットを立てる
	add.b	d0,d4				* 補正係数を加算
	bra	2f
1:	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 減算なのでN=1(もともと1なのでそのままにしておけばOK)
	andi.l	#%000_11111000_11111010,d6	* PV,Cはこの場で計算するので、0初期化しダーティビットもクリア
	ori.l	#%100_11111000_00000000,d6	* S,Z,F5,H,F3,PVのダーティビットを立てる
	sub.b	d0,d4			* 補正係数を減算
2:	move.b	d4,d5			* 結果を保存
	; 上位4ビットの補正があった場合はキャリーをセットする
	andi.b	#$f0,d0
	beq	1f
	ori.b	#%00000001,d6		* C フラグをセット
1:	; パリティをこの場で計算
	move.b	d4,d0
	move.b  d0,d1
	lsr.b	#4,d1
	eor.b	d1,d0
	move.b	d0,d1
	lsr.b	#2,d1
	eor.b	d1,d0
	move.b	d0,d1
	lsr.b	#1,d1
	eor.b	d1,d0
	btst	#0,d0
	bne	@f		; パリティーが奇数ならPVフラグは0なので何もしない(感覚と逆なので注意)
	ori.b	#%00000100,d6	; パリティーが偶数ならPVフラグをセット
@@:	rts


*	------ ＪＰ ------
	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP:	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d7
	PC_page_set
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
JP_lHLl:
	move.w	hl(a3),d7
	PC_page_set
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_C:	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Cフラグをテスト
	bne	JP		* Cが１ならジャンプ
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_NC:	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Cフラグをテスト
	beq	JP		* Cが０ならジャンプ
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_Z:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	bne	JP		* Zが1ならジャンプ
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_NZ:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	beq	JP		* Zが0ならジャンプ
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_PE:	bsr	eval_flag_PV_N	* PV フラグを再評価
	btst.l	#2,d6		* PVフラグをテスト
	bne	JP		* PVが偶数(=1)ならジャンプ
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_PO:	bsr	eval_flag_PV_N	* PV フラグを再評価
	btst.l	#2,d6		* PVフラグをテスト
	beq	JP		* PVが奇数(=0)ならジャンプ
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_P:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#7,d6		* Sフラグをテスト
	beq	JP		* Sが0ならジャンプ
	rts

	.dc.w	10			* サイクル数
	.dc.w	3-1			* 命令語長-1
JP_M:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#7,d6		* Sフラグをテスト
	bne	JP		* Sが1ならジャンプ
	rts

*	------ ＪＲ ------
	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
JR:	; この時点でPC(d7)は次の命令の位置を指しているので、そこの絶対アドレスを計算し
	; そこからの相対番地にジャンプする
	rol.l	#8,d1			* 先読みしていた相対移動量 nを取得
	ext.w	d1			* ワードに符号拡張
	move.l	d7,d0
	lsr.l	#3,d0			* d0 = ppp000??_????????
	andi.w	#%11100000_00000000,d0	* d0 = ppp00000_00000000
	or.w	d0,d7			* d7 = PC (R800)
	add.w	d1,d7			* 相対量を足す
	PC_page_set
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
JR_NZ:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	beq	JR		* Zが0ならジャンプ
	;　条件不成立時はサイクル数が7なので、5引く
	subq.l	#5,cpu_cycle
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
JR_Z:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	bne	JR		* Zが1ならジャンプ
	;　条件不成立時はサイクル数が7なので、5引く
	subq.l	#5,cpu_cycle
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
JR_NC:	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Cフラグをテスト
	beq	JR		* Cが０ならジャンプ
	;　条件不成立時はサイクル数が7なので、5引く
	subq.l	#5,cpu_cycle
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
JR_C:	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Cフラグをテスト
	bne	JR		* Cが１ならジャンプ
	;　条件不成立時はサイクル数が7なので、5引く
	subq.l	#5,cpu_cycle
	rts

*	------ ＣＡＬＬ ------
	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL:	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,-(sp)
	; 戻り先アドレスを計算
	; この時点でPC(d7)は次の命令の位置を指しているので、そこの絶対アドレスを計算し
	; スタックに積む
	move.l	d7,d0
	move.w	d7,d1
	lsr.l	#3,d0			* d0 = ppp000??_????????
	andi.w	#%11100000_00000000,d0	* d0 = ppp00000_00000000
	or.w	d0,d1			* d1 = PC (R800)
	subq.w	#2,sp_(a3)		* PUSH	
	move.w	sp_(a3),d0
	write_mem_16
	move.w 	(sp)+,d7
	PC_page_set
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_C:	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Cフラグをテスト
	bne	CALL		* Cが１ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_NC:
	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Cフラグをテスト
	beq	CALL		* Cが０ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_Z:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	bne	CALL		* Zが1ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_NZ:
	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	beq	CALL		* Zが0ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_PE:
	bsr	eval_flag_PV_N	* PV フラグを再評価
	btst.l	#2,d6		* PVフラグをテスト
	bne	CALL		* PVが偶数(=1)ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_PO:
	bsr	eval_flag_PV_N	* PV フラグを再評価
	btst.l	#2,d6		* PVフラグをテスト
	beq	CALL		* PVが奇数(=0)ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_P:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#7,d6		* Sフラグをテスト
	beq	CALL		* Sが0ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

	.dc.w	17			* サイクル数
	.dc.w	3-1			* 命令語長-1
CALL_M:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#7,d6		* Sフラグをテスト
	bne	CALL		* Sが1ならコール
	;　条件不成立時はサイクル数が10なので、7引く
	subq.l	#7,cpu_cycle
	rts

*	------ ＲＥＴ ------
	.dc.w	10			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET:	move.w	sp_(a3),d0
	jsr	ms_read_mem_16
	addq.w	#2,sp_(a3)
	cmp.w	interrupt_return,d0	* 割り込み発生時にセットした戻り先アドレスに戻ったか？
	bne	@f
	move.w	#0,interrupt_return
@@:	move.w	d0,d7
	PC_page_set
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_C:	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Ｃｙフラグをテスト
	bne	RET		* Ｃｙが１ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts
	
	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_NC:	bsr	eval_flag_HC_C	* HC,C フラグを再評価
	btst.l	#0,d6		* Ｃｙフラグをテスト
	beq	RET		* Ｃｙが０ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_Z:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	bne	RET		* Zが1ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_NZ:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#6,d6		* Zフラグをテスト
	beq	RET		* Zが0ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_M:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#7,d6		* Sフラグをテスト
	bne	RET		* Sが1ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_P:	bsr	eval_flag_SZ	* SZ フラグを再評価
	btst.l	#7,d6		* Sフラグをテスト
	beq	RET		* Sが0ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_PE:	bsr	eval_flag_PV_N	* PV フラグを再評価
	btst.l	#2,d6		* PVフラグをテスト
	bne	RET		* PVが偶数(=1)ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RET_PO:	bsr	eval_flag_PV_N	* PV フラグを再評価
	btst.l	#2,d6		* PVフラグをテスト
	beq	RET		* PVが奇数(=0)ならリターン
	;　条件不成立時はサイクル数が5なので、6引く
	subq.l	#6,cpu_cycle
	rts

*	------ ＤＪＮＺ ------
	.dc.w	13			* サイクル数
	.dc.w	2-1			* 命令語長-1
DJNZ:	subq.b	#1,b(a3)	* b = b-1
	bne	JR		* b != 0 ならブランチ
	;　ループしない時はサイクル数が8なので、5引く
	subq.l	#5,cpu_cycle
	rts


*	------ ＰＵＳＨ  ＰＯＰ ------
;---------------------------------------------------------------------------------------
PUSH_XX	macro
	subq.w	#2,sp_(a3)		; スタックを2バイト減らす
	move.w	sp_(a3),d0
	move.w	target_16(a3),d1
	write_mem_16		; スタックに書き込む
	endm
;---------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------
POP_XX	macro
	move.w	sp_(a3),d0		; スタックから読み込む
	jsr	ms_read_mem_16
	addq.w	#2,sp_(a3)		; スタックを2バイト増やす
	endm
;---------------------------------------------------------------------------------------

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
PUSH_AF:
	bsr	eval_flag_all
	move.b	d4,d1
	lsl.w	#8,d1
	move.b	d6,d1
	move.w	d1,target_16(a3)
	PUSH_XX	d1
	rts

	.dc.w	10			* サイクル数
	.dc.w	1-1			* 命令語長-1
POP_AF:
	POP_XX
	move.w	d0,d4			; Aレジスタのロード
	lsr.w	#8,d4			; 位置合わせ
	move.b	d0,d6			; フラグのロード
	andi.l	#%000_00000000_11111111,d6	; フラグのダーティビットをクリア
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
PUSH_BC:
	move.w	bc(a3),target_16(a3)
	PUSH_XX
	rts

	.dc.w	10			* サイクル数
	.dc.w	1-1			* 命令語長-1
POP_BC:
	POP_XX
	move.w	d0,bc(a3)
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
PUSH_DE:
	move.w	de(a3),target_16(a3)
	PUSH_XX
	rts

	.dc.w	10			* サイクル数
	.dc.w	1-1			* 命令語長-1
POP_DE:
	POP_XX	de(a3)
	move.w	d0,de(a3)
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
PUSH_HL:
	move.w	hl(a3),target_16(a3)
	PUSH_XX
	rts

	.dc.w	10			* サイクル数
	.dc.w	1-1			* 命令語長-1
POP_HL:
	POP_XX	hl(a3)
	move.w	d0,hl(a3)
	rts

*	------ ＥＸ ------
	.dc.w	19			* サイクル数
	.dc.w	1-1			* 命令語長-1
EX_lSPl_HL:
	move.w	sp_(a3),d0
	jsr	ms_read_mem_16
	move.w	hl(a3),d1
	move.w	d0,hl(a3)
	move.w	sp_(a3),d0
	write_mem_16
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
EXX:	move.l	bc(a3),d0		* d0 = bc, de
	move.w	hl(a3),d1

	move.l	bc_(a3),bc(a3)
	move.w	hl_(a3),hl(a3)

	move.l	d0,bc_(a3)
	move.w	d1,hl_(a3)

	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
EX_DE_HL:
	move.l	de(a3),d0
	swap	d0
	move.l	d0,de(a3)
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
EX_AF_AFd:
	move.b	d4,d1
	move.b	a_(a3),d4
	move.b	d1,a_(a3)
	bsr	eval_flag_all
	move.b	d6,d1
	move.b	f_(a3),d6
	andi.l	#%000_00000000_11111111,d6	; フラグのダーティビットをクリア
	move.b	d1,f_(a3)

	rts


; CCFの挙動は以下の通り
; * S : 変化しない
; * Z : 変化しない
; * F5: A レジスタの bit5
; * H : 元のCフラグの値
; * F3: A レジスタの bit3
; * PV: 変化しない
; * N : 0
; * C : Cの反転
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CCF:	bsr	eval_flag_all		* 全てのフラグを再評価
	move.b	d6,d0			* 元のCフラグの値を保存
	andi.b	#%00000001,d0		* Cフラグのみを取得
	lsl.b	#4,d0			* C→HCの位置に移動
	move.b	d4,d1			* Aレジスタの値を取得
	andi.b	#%00101000,d1		* AレジスタからF5,F3を取得
	or.b	d1,d0			* F5,F3を混ぜる
	and.l	#%000_00000000_11000101,d6	* S,Z,PV,Cのみを保存し、あとはクリア
	bchg	#0,d6			* Cフラグを反転
	or.b	d0,d6			* F5,H,F3を反映
	rts	

; SCFの挙動は以下の通り
; * S : 変化しない
; * Z : 変化しない
; * F5: A レジスタの bit5
; * H : 0
; * F3: A レジスタの bit3
; * PV: 変化しない
; * N : 0
; * C : 1
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
SCF:	bsr	eval_flag_all		* 全てのフラグを再評価
	move.b	d4,d0			* Aレジスタの値を取得
	andi.b	#%00101000,d0		* AレジスタからF5,F3を取得
	and.l	#%000_00000000_11000100,d6	* S,Z,PVのみを保存し、あとはクリア
	bset	#0,d6			* Cフラグを1に
	or.b	d0,d6			* F5,F3を反映
	;
	rts

; CPLの挙動は以下の通り
; * A : 反転
; * S : 変化しない
; * Z : 変化しない
; * F5: 反転後のA レジスタの bit5
; * H : 1
; * F3: 反転後のA レジスタの bit3
; * PV: 変化しない
; * N : 1
; * C : 変化しない
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
CPL:	bsr	eval_flag_all		* 全てのフラグを再評価
	eori.b	#$ff,d4			* Aレジスタの値を反転
	move.b	d4,d0			* 反転後のAレジスタの値を取得
	andi.b	#%00101000,d0		* AレジスタからF5,F3を取得
	and.l	#%000_00000000_11000101,d6	* S,Z,PV,Cのみを保存し、あとはクリア
	ori.b	#%00010010,d6		* N,Hを1に
	or.b	d0,d6			* F5,F3を反映
	;
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
DI:	move.b	#0,interrupt_enable
	rts

;
; EIの挙動として、「次の命令までは割り込みがかからずに実行される」というものがあります。
; 割り込み処理ルーチンの最後は通常以下のような並びになっていますが、
;	EI
;	RETI
; この仕様のおかげで、割り込みが許可されるのは RETIによって元の処理に戻った後になります。
; これを実現するためには、EIの命令の直後であることをなんらかのフラグで覚えておく必要があります。
; 今は、「最後に実行したOPコード」を last_opcodeに覚えておくようにして対応しています。
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
EI:	move.b	#1,interrupt_enable	* 割り込みを許可
	cmpi.b	#0,ms_cpu_int
	beq	@f
	move.w	#2,cpu_yield		* 外部割り込み要求がある場合は2サイクル後に割り込み判定をかける
@@:	rts

;---------------------------------------------------------------------------------------
RST_XXH	macro	value
	;move.w	value,d0
	;bsr	print_debug_rst
	move.l	d7,d1
	lsr.l	#3,d7			* d7 = ppp000??_????????
	andi.w	#%11100000_00000000,d7	* d7 = ppp00000_00000000
	or.w	d7,d1			* d1 = PC (R800) = next instruction
	subq.w	#2,sp_(a3)		* PUSH	
	move.w	sp_(a3),d0
	write_mem_16
	move.w	value,d7
	PC_page_set
	endm
;---------------------------------------------------------------------------------------

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_00H:
	RST_XXH	#$0000
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_08H:
	RST_XXH	#$0008
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_10H:
	RST_XXH	#$0010
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_18H:
	RST_XXH	#$0018
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_20H:
	RST_XXH	#$0020
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_28H:
	RST_XXH	#$0028
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_30H:
	RST_XXH	#$0030
	rts

	.dc.w	11			* サイクル数
	.dc.w	1-1			* 命令語長-1
RST_38H:
	RST_XXH	#$0038
	rts

print_debug_rst:
	cmp.w	#MS_LOG_TRACE,debug_log_level
	bge	@f				* ログレベルが TRACE 以上の時
	rts
@@:	movem.l	d0-d3/a0-a3,-(sp)
	move.w	d0,d1
	lsr.w	#4,d0
	lea.l	HEX,a0
	move.b	(a0,d0.w),debug_rst_number+0
	andi.w	#$0f,d1
	move.b	(a0,d1.w),debug_rst_number+1

	pea.l	debug_rst_msg
	DOS	__PRINT
	lea.l	4(sp),sp
	movem.l	(sp)+,d0-d3/a0-a3
	rts

	.data

debug_rst_msg:
	.dc.b	'RST 0x'
debug_rst_number:
	.dc.b	'00'
debug_rst_msg2:
	.dc.b	'が呼ばれました'
	.dc.b	0x0d,0x0a,0x00

	.text

*	------ ＲＬＣＡ ------
*	------ ＲＬＡ ------
*	------ ＲＲＣＡ ------
*	------ ＲＲＡ ------

;---------------------------------------------------------------------------------------
RXXA	macro	isLeft, isCircular
	bsr	eval_flag_HC_C
	.if isCircular
	  ; キャリーを経由せずにローテート
	  .if isLeft
	    rol.b	#1,d4
	  .else
	    ror.b	#1,d4
	  .endif
	.else
	  ; キャリーを経由してローテート
	  ; Xフラグにキャリーをセットし、rox命令を使う
	  btst.l	#0,d6
	  bne	1f
	  andi.b	#%11101111,ccr	; Xフラグをリセット
	  bra	2f
1:  	  ori.b		#%00010000,ccr	; Xフラグをセット
2:
	  .if isLeft
	    roxl.b	#1,d4
	  .else
	    roxr.b	#1,d4
	  .endif
	.endif
	; はみ出したキャリーをCフラグにセット
	bcs	1f
	andi.l	#%000_11000100_11101100,d6	* HC,N,Cをクリア
	ori.l	#%010_00101000_00000000,d6	* F5,F3のダーティビットをセット
	bra	2f
1:	andi.l	#%000_11000100_11101100,d6	* HC,N,Cをクリア
	ori.l	#%010_00101000_00000001,d6	* F5,F3のダーティビットをセット、Cをセット
2:	move.b	d4,d5
	endm
;---------------------------------------------------------------------------------------

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
RLCA:	RXXA	1, 1
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
RRCA:	RXXA	0, 1
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
RLA:	RXXA	1, 0
	rts

	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
RRA:	RXXA	0, 0
	rts

*	------ ＨＡＬＴ ------
	.dc.w	4			* サイクル数
	.dc.w	1-1			* 命令語長-1
HALT:
	; pea.l	halt_msg
	; DOS	__PRINT
	; lea.l	4(sp),sp
9:	move.l	cpu_sub_emu_yield,d0	* X68000側の割り込みがかかるまで待機
	beq	9b
	; 一時的に割り込み禁止
	move.w	sr,d0
	move.w	d0,-(sp)
	or.w	#%00000111_00000000,d0
	move.w	d0,sr

	cmpi.b	#0,interrupt_enable
	beq	8f		* DIなら割り込まない(永遠に出られない？ NMIなら出られるようにすべき？)
	; あらためて割り込み要求端子の値(ms_cpu_int)を見て割り込み要求があるかどうかを見る
	cmpi.b	#0,ms_cpu_int
	beq	8f
	bsr	INT		* 割り込みがかかったので割り込み処理を実施
	move.w	#0,d0
	bsr	add_interrupt_history
	move.l	emu_counter,emu_counter_latch	* この時点の値を覚えておく
	move.w	(sp)+,sr	* ここで割り込み許可に戻す
	rts			* HALT命令終了

8:	; HALT中でも特殊キーの処理を回したいので、yieldチェック
	add.l	#1,emu_counter
	bsr	get_emu_yield_func
	cmpi.l	#0,d0
	bne	@f
	move.w	(sp)+,sr		* ここで割り込み許可に戻す
	bra	9b

@@:	; タイミングが来たのでC側の処理を呼び出す
	movea.l	d0,a0			* 処理ルーチンのアドレス
	move.l	emu_counter,d0
	sub.l	emu_counter_latch,d0
	move.w	(sp)+,sr		* ここで割り込み許可に戻す
	movem.l	d1-d7/a0-a6,-(sp)
	move.l	d0,-(sp)		* カウンタ差分を引数として渡す
	move.l	d7,-(sp)		* PCを引数として渡す
	jsr	(a0)
	lea.l	8(sp),sp
	movem.l	(sp)+,d1-d7/a0-a6
	move.l	d0,d0
	beq	9b
	; 0以外が帰ってきたのでエミュレータを終了
	; サブルーチンを1段飛ばすために、SPをインクリメント
	lea.l	4(sp),sp
	bra	emu_end

halt_msg:
	.dc.b	'HALT',0x0d,0x0a,0x00,0x00

	.even

*
*	＄ＣＢライン命令
*
*	  c    b   
*	%1100_1011_cccc_crrr
*
*		ccccc ・ 00000	RLC
*			 00001	RRC
*			 00010	RL
*			 00011	RR
*			 00100	SLA
*			 00101	SRA
*			 00110	SLI		* undifined instruction
*			 00111	SRL
*
*			 01000
*			   |	BIT 0〜7
*			 01111
*
*			 10000
*			   |	RES 0〜7
*			 10111
*
*			 11000
*			   |	SET 0〜7
*			 11111
*
*		rrr ・・ 000 - b
*			 001 - c
*			 010 - d
*			 011 - e
*			 100 - h
*			 101 - l
*			 110 - (hl)
*			 111 - a
*
*
;	CBラインのSET命令はほとんどサイクル数=8
	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
CB:	* 先読みした値から第二オペコードを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d0
@@:	bclr.l	#7,d0			* ００Ｈ〜７ＦＨの命令かどうか
	beq	case2			* そうなら case2へ
case1:
	bclr.l	#6,d0
	beq	RES			* ＲＥＳ命令

;	------ ＳＥＴ ------
SET:	move.b	d0,d1
	andi.w	#%00000000_00111000,d0		* BIT_n_? の n を d0にロード
	lsr.w	#3,d0

	andi.w	#%00000000_00000111,d1		* レジスタの値をロード
	addq.w	#2,d1
	bclr.l	#3,d1
	bne	SET_aorhl			* SET A, SET (HL)の時
	bset.b	d0,a(a3,d1.w)			* レジスタの nビット目をセット
	rts

SET_aorhl:
	tst.w	d1
	beq	set_lhll
	bset.l	d0,d4				* A レジスタの nビット目をセット
	rts
set_lhll
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	d0,-(sp)
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.w	(sp)+,d1
	bset.l	d1,d0				* (HL)の nビット目をセット
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8		
	rts

;	------ ＲＥＳ ------
RES:	move.b	d0,d1
	andi.w	#%00000000_00111000,d0		* BIT_n_? の n を d0にロード
	lsr.w	#3,d0

	andi.w	#%00000000_00000111,d1		* レジスタの値をロード
	addq.w	#2,d1
	bclr.l	#3,d1
	bne	RES_aorhl			* RES A, RES (HL)の時
	bclr.b	d0,a(a3,d1.w)			* レジスタの nビット目をクリア
	rts
RES_aorhl:
	tst.w	d1
	beq	RES_lhll
	bclr.l	d0,d4				* A レジスタの nビット目をクリア
	rts
RES_lhll
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	d0,-(sp)
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.w	(sp)+,d1
	bclr.l	d1,d0				* (HL)の nビット目をセット
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8		
	rts

;	------ CASE2 ------
case2:
	bclr.l	#6,d0
	beq	rot_sft			* ローテート、シフト関係の命令

;	------ ＢＩＴ ------
; ＢＩＴ命令の挙動は以下の通り
; * S : BIT 7,?の時だけ、対象のbit7が1なら1。それ以外の時は0
; * Z : 対象のbitが0なら1。それ以外の時は0
; * F5: 対象のbit5
; * H : 1
; * F3: 対象のbit3
; * PV: Zフラグと同じ
; * N : 0
; * C : 変化しない
; ただし、対象が(HL)の場合だけ、F5,F3は内部のWZレジスタの上位8bitの値(bit13,11)が入るらしい
BIT:	move.w	d0,-(sp)
	bsr	eval_flag_HC_C		* HC,C フラグを再評価
	andi.l	#%000_00000000_00000001,d6	* Cフラグ以外をクリア
	ori.l	#%000_00000000_00010000,d6	* Hフラグをセット
	move.w	(sp)+,d0
	move.w	d0,d1
	andi.w	#%00000000_00111000,d0	* BIT_n_? の n を d0にロード
	lsr.w	#3,d0
	moveq.l	#1,d2
	lsl	d0,d2			* 対象位置のビットをセット

	andi.w	#%00000000_00000111,d1
	addq.w	#2,d1
	andi.w	#%00000111,d1
	cmpi.w	#1,d1
	beq	BIT_a			* BIT Aの時
	blt	BIT_lhll		* BIT (HL)の時
	move.b	a(a3,d1.w),d0		* B,C,D,E,H,Lのいずれかのレジスタの値をロード
	move.b	d0,d1			* F5,F3に反映させるレジスタ値をd1にロード
	bra	@f
BIT_a:
	move.b	d4,d0			* Aレジスタの値をロード
	move.b	d0,d1			* F5,F3に反映させるレジスタ値をd1にロード
	bra	@f
BIT_lhll:
	; (HL) の場合はサイクル数が12なので4を足す
	add.l	#4,cpu_cycle
	move.w	d2,-(sp)
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.w	(sp)+,d2
	move.b	w(a3),d1		* F5,F3に反映させるレジスタ値をd1にロード  (hl)の時は wレジスタが使われるらしい
@@:
	andi.b	#%00101000,d1		* F5,F3を取得
	or.b	d1,d6			* F5,F3をFレジスタに反映
	and.b	d2,d0			* レジスタの nビット目をテストするためにマスク
	bne	1f
	ori.l	#%000_00000000_01000100,d6	* Z,PVフラグをセット
1:	andi.b	#%10000000,d0		* bit7のみ残す
	or.b	d0,d6			* bit7を Sフラグに反映
	rts


;	------ ローテート,シフト ------
rot_sft:
	andi.w	#%0000_0000_0011_1111,d0	* 命令にジャンプ
	move.w	Rot_Sft_JPT(pc,d0.w*2),d0
	jmp	Rot_Sft_JPT(pc,d0.w)

Rot_Sft_JPT:
	.dc.w	RLC_B-Rot_Sft_JPT	* $00
	.dc.w	RLC_C-Rot_Sft_JPT
	.dc.w	RLC_D-Rot_Sft_JPT
	.dc.w	RLC_E-Rot_Sft_JPT
	.dc.w	RLC_H-Rot_Sft_JPT
	.dc.w	RLC_L-Rot_Sft_JPT
	.dc.w	RLC_lHLl-Rot_Sft_JPT
	.dc.w	RLC_A-Rot_Sft_JPT
	.dc.w	RRC_B-Rot_Sft_JPT	* $08
	.dc.w	RRC_C-Rot_Sft_JPT
	.dc.w	RRC_D-Rot_Sft_JPT
	.dc.w	RRC_E-Rot_Sft_JPT
	.dc.w	RRC_H-Rot_Sft_JPT
	.dc.w	RRC_L-Rot_Sft_JPT
	.dc.w	RRC_lHLl-Rot_Sft_JPT
	.dc.w	RRC_A-Rot_Sft_JPT	* $0f

	.dc.w	RL_B-Rot_Sft_JPT	* $10
	.dc.w	RL_C-Rot_Sft_JPT
	.dc.w	RL_D-Rot_Sft_JPT
	.dc.w	RL_E-Rot_Sft_JPT
	.dc.w	RL_H-Rot_Sft_JPT
	.dc.w	RL_L-Rot_Sft_JPT
	.dc.w	RL_lHLl-Rot_Sft_JPT
	.dc.w	RL_A-Rot_Sft_JPT
	.dc.w	RR_B-Rot_Sft_JPT	* $18
	.dc.w	RR_C-Rot_Sft_JPT
	.dc.w	RR_D-Rot_Sft_JPT
	.dc.w	RR_E-Rot_Sft_JPT
	.dc.w	RR_H-Rot_Sft_JPT
	.dc.w	RR_L-Rot_Sft_JPT
	.dc.w	RR_lHLl-Rot_Sft_JPT
	.dc.w	RR_A-Rot_Sft_JPT	* $1f

	.dc.w	SLA_B-Rot_Sft_JPT	* $20
	.dc.w	SLA_C-Rot_Sft_JPT
	.dc.w	SLA_D-Rot_Sft_JPT
	.dc.w	SLA_E-Rot_Sft_JPT
	.dc.w	SLA_H-Rot_Sft_JPT
	.dc.w	SLA_L-Rot_Sft_JPT
	.dc.w	SLA_lHLl-Rot_Sft_JPT
	.dc.w	SLA_A-Rot_Sft_JPT
	.dc.w	SRA_B-Rot_Sft_JPT	* $28
	.dc.w	SRA_C-Rot_Sft_JPT
	.dc.w	SRA_D-Rot_Sft_JPT
	.dc.w	SRA_E-Rot_Sft_JPT
	.dc.w	SRA_H-Rot_Sft_JPT
	.dc.w	SRA_L-Rot_Sft_JPT
	.dc.w	SRA_lHLl-Rot_Sft_JPT
	.dc.w	SRA_A-Rot_Sft_JPT	* $2f

	.dc.w	SLI_B-Rot_Sft_JPT	* $30	SLI 未定義命令(Shift Left Increment)
	.dc.w	SLI_C-Rot_Sft_JPT	*	ビット０に１が入る左シフト
	.dc.w	SLI_D-Rot_Sft_JPT
	.dc.w	SLI_E-Rot_Sft_JPT
	.dc.w	SLI_H-Rot_Sft_JPT
	.dc.w	SLI_L-Rot_Sft_JPT
	.dc.w	SLI_lHLl-Rot_Sft_JPT
	.dc.w	SLI_A-Rot_Sft_JPT
	.dc.w	SRL_B-Rot_Sft_JPT	* $38
	.dc.w	SRL_C-Rot_Sft_JPT
	.dc.w	SRL_D-Rot_Sft_JPT
	.dc.w	SRL_E-Rot_Sft_JPT
	.dc.w	SRL_H-Rot_Sft_JPT
	.dc.w	SRL_L-Rot_Sft_JPT
	.dc.w	SRL_lHLl-Rot_Sft_JPT
	.dc.w	SRL_A-Rot_Sft_JPT	* $3f

;
; RLC, RRC, RL, RR のローテーション(最後にAがついてない方)をまとめたマクロ
;
; フラグの挙動は以下の通り
; * S : 結果の最上位ビット
; * Z : 結果が0なら1。それ以外の時は0
; * F5: 結果のbit5
; * H : 0
; * F3: 結果のbit3
; * PV: 結果のパリティ
; * N : 0
; * C : ローテーションによってはみ出た値
;
RXX_	macro	isLeft, isCircular
	bsr	eval_flag_HC_C		* HC,C フラグを再評価
	move.b	target_8(a3),d0
	.if isCircular
	  ; キャリーを経由せずにローテート
	  .if isLeft
	    rol.b	#1,d0
	  .else
	    ror.b	#1,d0
	  .endif
	.else
	  ; キャリーを経由してローテート
	  ; Xフラグにキャリーをセットし、rox命令を使う
	  btst.l	#0,d6
	  bne	1f
	  andi.b	#%11101111,ccr	; Xフラグをリセット
	  bra	2f
1:  	  ori.b		#%00010000,ccr	; Xフラグをセット
2:
	  .if isLeft
	    roxl.b	#1,d0
	  .else
	    roxr.b	#1,d0
	  .endif
	.endif
	; はみ出したキャリーをCフラグにセット
	bcs	1f
	; b18 : don't care
	; b17 : 論理演算なので1
	; b16 : don't care
	andi.l	#%000_11000100_11101100,d6	* HC,F5,N,F3,Cをクリア
	ori.l	#%010_11101100_00000000,d6	* Cは0、SZとPVはダーティビットを立てる
	bra	2f
1:
	andi.l	#%000_11000100_11101100,d6	* HC,F5,N,F3,Cをクリア
	ori.l	#%010_11101100_00000001,d6	* Cは1、S,Z,F5,F3,PVはダーティビットを立てる
2:	move.b	d0,d5				* 論理演算結果を保存
	endm

*	------ ＲＬＣ ------
RLC_A:	move.b	d4,target_8(a3)
	RXX_	1, 1
	move.b	d0,d4
	rts
RLC_B:	move.b	b(a3),target_8(a3)
	RXX_	1, 1
	move.b	d0,b(a3)
	rts
RLC_C:	move.b	c(a3),target_8(a3)
	RXX_	1, 1
	move.b	d0,c(a3)
	rts
RLC_D:	move.b	d(a3),target_8(a3)
	RXX_	1, 1
	move.b	d0,d(a3)
	rts
RLC_E:	move.b	e(a3),target_8(a3)
	RXX_	1, 1
	move.b	d0,e(a3)
	rts
RLC_H:	move.b	h(a3),target_8(a3)
	RXX_	1, 1
	move.b	d0,h(a3)
	rts
RLC_L:	move.b	l(a3),target_8(a3)
	RXX_	1, 1
	move.b	d0,l(a3)
	rts
RLC_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	1, 1
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

*	------ ＲＲＣ ------
RRC_A:	move.b	d4,target_8(a3)
	RXX_	0, 1
	move.b	d0,d4
	rts
RRC_B:	move.b	b(a3),target_8(a3)
	RXX_	0, 1
	move.b	d0,b(a3)
	rts
RRC_C:	move.b	c(a3),target_8(a3)
	RXX_	0, 1
	move.b	d0,c(a3)
	rts
RRC_D:	move.b	d(a3),target_8(a3)
	RXX_	0, 1
	move.b	d0,d(a3)
	rts
RRC_E:	move.b	e(a3),target_8(a3)
	RXX_	0, 1
	move.b	d0,e(a3)
	rts
RRC_H:	move.b	h(a3),target_8(a3)
	RXX_	0, 1
	move.b	d0,h(a3)
	rts
RRC_L:	move.b	l(a3),target_8(a3)
	RXX_	0, 1
	move.b	d0,l(a3)
	rts
RRC_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	0, 1
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

*	------ ＲＬ ------
RL_A:	move.b	d4,target_8(a3)
	RXX_	1, 0
	move.b	d0,d4
	rts
RL_B:	move.b	b(a3),target_8(a3)
	RXX_	1, 0
	move.b	d0,b(a3)
	rts
RL_C:	move.b	c(a3),target_8(a3)
	RXX_	1, 0
	move.b	d0,c(a3)
	rts
RL_D:	move.b	d(a3),target_8(a3)
	RXX_	1, 0
	move.b	d0,d(a3)
	rts
RL_E:	move.b	e(a3),target_8(a3)
	RXX_	1, 0
	move.b	d0,e(a3)
	rts
RL_H:	move.b	h(a3),target_8(a3)
	RXX_	1, 0
	move.b	d0,h(a3)
	rts
RL_L:	move.b	l(a3),target_8(a3)
	RXX_	1, 0
	move.b	d0,l(a3)
	rts
RL_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	1, 0
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

*	------ ＲＲ ------
RR_A:	move.b	d4,target_8(a3)
	RXX_	0, 0
	move.b	d0,d4
	rts
RR_B:	move.b	b(a3),target_8(a3)
	RXX_	0, 0
	move.b	d0,b(a3)
	rts
RR_C:	move.b	c(a3),target_8(a3)
	RXX_	0, 0
	move.b	d0,c(a3)
	rts
RR_D:	move.b	d(a3),target_8(a3)
	RXX_	0, 0
	move.b	d0,d(a3)
	rts
RR_E:	move.b	e(a3),target_8(a3)
	RXX_	0, 0
	move.b	d0,e(a3)
	rts
RR_H:	move.b	h(a3),target_8(a3)
	RXX_	0, 0
	move.b	d0,h(a3)
	rts
RR_L:	move.b	l(a3),target_8(a3)
	RXX_	0, 0
	move.b	d0,l(a3)
	rts
RR_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	0, 0
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

;
; SLA, SRA, SLI, SRL のシフトをまとめたマクロ
;
; フラグの挙動は以下の通り
; * S : 結果の最上位ビット
; * Z : 結果が0なら1。それ以外の時は0
; * F5: 結果のbit5
; * H : 0
; * F3: 結果のbit3
; * PV: 結果のパリティ
; * N : 0
; * C : 命令による(SLA:はみ出た値、SRA:はみ出た値、SLI:はみ出た値、SRL:はみ出た値)
;
; RXXほどの対称性はないのでちょっと分かりづらいが、以下のような動作をする
; * SLA: 左に1ビットシフト、bit0には0が入る、はみ出た値は C フラグにセット
; * SRA: 右に1ビットシフト、bit7は元の値の最上位ビット、はみ出た値は C フラグにセット
; * SLI: 左に1ビットシフト、bit0には1が入る、はみ出た値は C フラグにセット(未定義命令)
; * SRL: 右に1ビットシフト、bit7は0、はみ出た値は C フラグにセット
;
; 以上を１つのマクロで実現するため、isLeft, insert という２つの引数を使っている
; * isLeft: 1の時は左シフト、0の時は右シフト
; * insert : 0の時は0を挿入、1の時は1を挿入、2の時は 最上位ビットの値を挿入
SXX	macro	isLeft, insert
	bsr	eval_flag_HC_C		* HC,C フラグを再評価
	move.b	target_8(a3),d0
	.if insert=0
	  andi.b	#%11101111,ccr	; Xフラグをリセット
	.elseif insert=1
	  ori.b		#%00010000,ccr	; Xフラグをセット
	.else
	  btst	#7,d0
	  bne	1f
	  andi.b	#%11101111,ccr	; Xフラグをリセット
	  bra	2f
1: 	  ori.b		#%00010000,ccr	; Xフラグをセット
2:
	.endif
	.if isLeft
	  roxl.b	#1,d0			; Xフラグを使えるのはローテートだけなのでローテートを使う
	.else
	  roxr.b	#1,d0			; Xフラグを使えるのはローテートだけなのでローテートを使う	
	.endif

	; はみ出したキャリーをCフラグにセット
	bcs	1f
	; b18 : don't care
	; b17 : 論理演算なので1
	; b16 : don't care
	andi.l	#%000_11000100_11000100,d6	* F5,HC,F3,N,Cをクリア
	ori.l	#%010_11101100_00000000,d6	* Cは0、S,Z,F5,F3,PVはダーティビットを立てる
	bra	2f
1:
	andi.l	#%000_11000100_11000100,d6	* 5,HC,F3,N,Cをクリア
	ori.l	#%010_11101100_00000001,d6	* Cは1、S,Z,F5,F3,PVはダーティビットを立てる
2:	move.b	d0,d5				* 論理演算結果を保存
	endm

*	------ ＳＬＡ ------
SLA_A:
	move.b	d4,target_8(a3)
	SXX	1, 0
	move.b	d0,d4
	rts
SLA_B:
	move.b	b(a3),target_8(a3)
	SXX	1, 0
	move.b	d0,b(a3)
	rts
SLA_C:
	move.b	c(a3),target_8(a3)
	SXX	1, 0
	move.b	d0,c(a3)
	rts
SLA_D:
	move.b	d(a3),target_8(a3)
	SXX	1, 0
	move.b	d0,d(a3)
	rts
SLA_E:
	move.b	e(a3),target_8(a3)
	SXX	1, 0
	move.b	d0,e(a3)
	rts
SLA_H:
	move.b	h(a3),target_8(a3)
	SXX	1, 0
	move.b	d0,h(a3)
	rts
SLA_L:
	move.b	l(a3),target_8(a3)
	SXX	1, 0
	move.b	d0,l(a3)
	rts
SLA_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	1, 0
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

*	------ ＳＲＡ ------
SRA_A:
	move.b	d4,target_8(a3)
	SXX	0, 2
	move.b	d0,d4
	rts
SRA_B:
	move.b	b(a3),target_8(a3)
	SXX	0, 2
	move.b	d0,b(a3)
	rts
SRA_C:
	move.b	c(a3),target_8(a3)
	SXX	0, 2
	move.b	d0,c(a3)
	rts
SRA_D:
	move.b	d(a3),target_8(a3)
	SXX	0, 2
	move.b	d0,d(a3)
	rts
SRA_E:
	move.b	e(a3),target_8(a3)
	SXX	0, 2
	move.b	d0,e(a3)
	rts
SRA_H:
	move.b	h(a3),target_8(a3)
	SXX	0, 2
	move.b	d0,h(a3)
	rts
SRA_L:
	move.b	l(a3),target_8(a3)
	SXX	0, 2
	move.b	d0,l(a3)
	rts
SRA_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	0, 2
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

*	------ ＳＲＬ ------
SRL_A:
	move.b	d4,target_8(a3)
	SXX	0, 0
	move.b	d0,d4
	rts
SRL_B:
	move.b	b(a3),target_8(a3)
	SXX	0, 0
	move.b	d0,b(a3)
	rts
SRL_C:
	move.b	c(a3),target_8(a3)
	SXX	0, 0
	move.b	d0,c(a3)
	rts
SRL_D:
	move.b	d(a3),target_8(a3)
	SXX	0, 0
	move.b	d0,d(a3)
	rts
SRL_E:
	move.b	e(a3),target_8(a3)
	SXX	0, 0
	move.b	d0,e(a3)
	rts
SRL_H:
	move.b	h(a3),target_8(a3)
	SXX	0, 0
	move.b	d0,h(a3)
	rts
SRL_L:
	move.b	l(a3),target_8(a3)
	SXX	0, 0
	move.b	d0,l(a3)
	rts
SRL_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	0, 0
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

*	------ ＳＬＩ ------
SLI_A:
	move.b	d4,target_8(a3)
	SXX	1, 1
	move.b	d0,d4
	rts
SLI_B:
	move.b	b(a3),target_8(a3)
	SXX	1, 1
	move.b	d0,b(a3)
	rts
SLI_C:
	move.b	c(a3),target_8(a3)
	SXX	1, 1
	move.b	d0,c(a3)
	rts
SLI_D:
	move.b	d(a3),target_8(a3)
	SXX	1, 1
	move.b	d0,d(a3)
	rts
SLI_E:
	move.b	e(a3),target_8(a3)
	SXX	1, 1
	move.b	d0,e(a3)
	rts
SLI_H:
	move.b	h(a3),target_8(a3)
	SXX	1, 1
	move.b	d0,h(a3)
	rts
SLI_L:
	move.b	l(a3),target_8(a3)
	SXX	1, 1
	move.b	d0,l(a3)
	rts
SLI_lHLl:
	; (HL) の場合はサイクル数が15なので7を足す
	add.l	#7,cpu_cycle
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	1, 1
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	rts

********************************************************************
*
*	＄ＥＤライン命令
*
********************************************************************
;	EDライン命令のサイクル数は不定なので0にしておき、各命令ごとに加算する
;	EDラインの命令語長は2-4バイトなので、ここは2にしておき、各命令ごとに加算する
	.dc.w	0			* サイクル数
	.dc.w	2-1			* 命令語長-1
ED:	* 先読みした値から第二オペコードを取り出す
	clr.w	d0
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d0
	subi.w	#$40,d0
	bcs	other			* ＄３ｆ以下の時は特殊命令へ
	movea.l	ED_JPT(pc,d0.w*4),a0	* ジャンプ先を取得
	move.w	-4(a0),d0		* 命令のサイクル数を取得
	ext.l	d0
	add.l	d0,cpu_cycle		* サイクル数を加算
	move.w	-2(a0),d0		* 命令語長-1を取得
	subq.w	#1,d0
	ble	@f			* 2バイトの場合
	; 3バイト以上の時
	add.w	d0,d7
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f
	PC_page_inc
	andi.w	#PAGEADDRMASK,d7
@@:	; この時点のレジスタは以下の通り
	; d0.l : N/A
	; d1.l : 命令語長が2の時はN/A。それ以外は3バイト目から5バイト目の値が入っている
	; d7.l : 命令語長だけ進めたPCの値
	jmp	(a0)

ED_JPT:	.dc.l	IN_B_c			* $40
	.dc.l	OUT_c_B
	.dc.l	SBC_HL_BC
	.dc.l	LD_lnnl_BC
	.dc.l	NEG
	.dc.l	RETN
	.dc.l	IM_0
	.dc.l	LD_I_A
	.dc.l	IN_C_c			* $48
	.dc.l	OUT_c_C
	.dc.l	ADC_HL_BC
	.dc.l	LD_BC_lnnl
	.dc.l	none_ED
	.dc.l	RETI
	.dc.l	none_ED
	.dc.l	LD_R_A			* $4f

	.dc.l	IN_D_c			* $50
	.dc.l	OUT_c_D
	.dc.l	SBC_HL_DE
	.dc.l	LD_lnnl_DE
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	IM_1
	.dc.l	LD_A_I
	.dc.l	IN_E_c			* $58
	.dc.l	OUT_c_E
	.dc.l	ADC_HL_DE
	.dc.l	LD_DE_lnnl
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	IM_2
	.dc.l	LD_A_R			* $5f

	.dc.l	IN_H_c			* $60
	.dc.l	OUT_c_H
	.dc.l	SBC_HL_HL
	.dc.l	LD_lnnl_HL_2
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	RRD_lHLl
	.dc.l	IN_L_c			* $68
	.dc.l	OUT_c_L
	.dc.l	ADC_HL_HL
	.dc.l	LD_HL_lnnl_2
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	RLD_lHLl		* $6f

	.dc.l	IN_F_c			* $70
	.dc.l	none_ED
	.dc.l	SBC_HL_SP
	.dc.l	LD_lnnl_SP
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	IN_A_c			* $78
	.dc.l	OUT_c_A
	.dc.l	ADC_HL_SP
	.dc.l	LD_SP_lnnl
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $7f

	.dc.l	none_ED			* $80
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $88
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $8f

	.dc.l	none_ED			* $90
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $98
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $9f

	.dc.l	LDI			* $a0
	.dc.l	CPI
	.dc.l	INI
	.dc.l	OUTI
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	LDD			* $a8
	.dc.l	CPD
	.dc.l	IND
	.dc.l	OUTD
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $af

	.dc.l	LDIR			* $b0
	.dc.l	CPIR
	.dc.l	INIR
	.dc.l	OTIR
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	LDDR			* $b8
	.dc.l	CPDR
	.dc.l	INDR
	.dc.l	OTDR
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $bf

	.dc.l	none_ED			* $c0
	.dc.l	MULB_A_B
	.dc.l	none_ED
	.dc.l	MULW_HL_BC
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $c8
	.dc.l	MULB_A_C
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $cf

	.dc.l	none_ED			* $d0
	.dc.l	MULB_A_D
	.dc.l	none_ED
	.dc.l	MULW_HL_DE
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $d8
	.dc.l	MULB_A_E
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $df

	.dc.l	none_ED			* $e0
	.dc.l	MULB_A_H
	.dc.l	none_ED
	.dc.l	MULW_HL_HL
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $e8
	.dc.l	MULB_A_L
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $ef

	.dc.l	none_ED			* $f0
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	MULW_HL_SP
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $f8
	.dc.l	MULB_A_A
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED
	.dc.l	none_ED			* $ff

	.dc.w	8			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
none_ED:				* おかしな命令を実行しました
	move.w	d0,d1
	lsr.w	#4,d0
	lea.l	HEX,a0
	move.b	(a0,d0.w),number_ed+0
	andi.w	#$0f,d1
	move.b	(a0,d1.w),number_ed+1

	pea.l	errms_ed
	DOS	__PRINT
	lea.l	4(sp),sp
	move.b	#$ff,d0
	rts

errms_ed:
	.dc.b	'おかしな命令を実行しました。0xed,0x'
number_ed:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00

	.even

*
*	６８０ｘ０ネイティブルーチンの呼びだし
*
*
	.dc.w	0			* サイクル数
	.dc.w	2-1			* 命令語長-1
other:					* ＭＳ用に拡張した命令
	; この時点の d0 には、0x00-0x3f の値に -0x40 した値が入っている
	move.b	d0,-(sp)
	move.l	native_jpt_add,d1
	beq	none_ED			* ネイティブルーチンがセットされていなければ未定義エラー
	;	AF レジスタをセット
	bsr	eval_flag_all
	move.b	d4,a(a3)
	move.b	d6,f(a3)

	move.b	(sp)+,d0
	add.w	#$20,d0			* 0x20を足してプラスの場合、つまり元々0x20-0x3fの時は CALL
	bpl	CALL68

JP68:	add.w	#$20,d0			* 0x20を足すと、元々の0x00-0x1fの値が得られる
	lsl.w	#8,d0			* d0 = d0 * 256
	move.b	0(a4,d7.w),d0		* d0 = ルーチン番号 (0x0000-0x1fff)
	addq.w	#1,d7
	andi.w	#PAGEADDRMASK,d7	* PC がページ境界をまたいだか？
	bne	@f
	PC_page_inc
@@:
	lsl.w	#2,d0			* d0 = d0 * 4
	movea.l	native_jpt_add,a1
	move.l	0(a1,d0.w),a1

	movem.l	d4-d6/a3-a4,-(sp)
	jsr	(a1)
	movem.l	(sp)+,d4-d6/a3-a4

	move.w	d0,d7			* d0.w に戻り先の番地が入っている
	PC_page_set
	bra	next_jp_call_68

CALL68:	add.w	#$20,d0			* d0には、元々の0x20-0x3fが入っている
	lsl.w	#8,d0			* d0 = d0 * 256
	move.b	0(a4,d7.w),d0		* d0 = ルーチン番号 (0x2000-0x3fff)
	addq.w	#1,d7
	andi.w	#PAGEADDRMASK,d7	* PC がページ境界をまたいだか？
	bne	@f
	PC_page_inc
@@:
	lsl.w	#2,d0			* d0 = d0 * 4
	lea.l	native_jpt_add,a1
	move.l	0(a1,d0.w),a1

	movem.l	d4-d6/a3-a4,-(sp)
	jsr	(a1)
	movem.l	(sp)+,d4-d6/a3-a4

*
*	フラグの描き戻しなどの後処理
*
next_jp_call_68:
	move.b	a(a3),d4		* Aレジスタをセット
	move.b	f(a3),d6		* フラグのロード
	andi.l	#000_00000000_11111111,d6	* フラグのダーティビットをクリア
	rts
	


*	------ ＲＬＤ,ＲＲＤ ------
;
; RLD, RRD の挙動は以下の通り
; * S : 結果の最上位ビット
; * Z : 結果が0なら1。それ以外の時は0
; * F5: 結果のAレジスタのbit5
; * H : 0
; * F3: 結果のAレジスタのbit3
; * PV: 結果のAレジスタのパリティ
; * N : 0
; * C : 変化しない
	.dc.w	18			* サイクル数
	.dc.w	2-1			* 命令語長-1
RLD_lHLl:
	move.w	hl(a3),d0		* d0.w = |00|00|(H|L)|
	jsr	ms_read_mem_8
	andi.w	#%00000000_11111111,d0

	lsl.w	#4,d0			* d0.w = |00|(H|L)|00|
	move.b	d4,d1
	andi.w 	#%00000000_00001111,d1
	or.b	d0,d1			* d1.w = |00|(H|L)|Al|

	andi.b	#%11110000,d4		* d4.b = |Ah|00|
	lsr.w	#8,d0			* d0.b = |00|(H|
	or.b	d0,d4			* d4.b = |Ah|(H|

	move.w	hl(a3),d0
	write_mem_8

	andi.l	#%000_11101101_11101101,d6	* HC,Nをクリア
	ori.l	#%010_11101100_00000000,d6	* S,Z,F5,F5,PVのダーティビットを立てる
	move.b	d4,d5			* 論理演算結果を保存
	rts

	.dc.w	18			* サイクル数
	.dc.w	2-1			* 命令語長-1
RRD_lHLl:
	move.w	hl(a3),d0		* d0.w = |??|??|(H|L)|
	jsr	ms_read_mem_8

	move.b	d4,d1
	lsl.w	#8,d1			* d1.w = |Ah|Al|00|00|
	move.b	d0,d1			* d1.w = |Ah|Al|(H|L)|

	lsr.w	#4,d1			* d1.w = |00|Ah|Al|(H|
	andi.w 	#%00000000_00001111,d0	
					* d0.w = |00|00|00|L)| 
	andi.b	#%11110000,d4		* d4.b =       |Ah|00|
	or.b	d0,d4			* d4.b =       |Ah|L)|

	move.w	hl(a3),d0
	write_mem_8

	andi.l	#%000_11101101_11101101,d6	* HC,Nをクリア
	ori.l	#%010_11101100_00000000,d6	* S,Z,F5,F5,PVのダーティビットを立てる
	move.b	d4,d5			* 論理演算結果を保存

	rts

*	------ ＩＭ ------
	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
IM_0:	move.b	#0,interrupt_mode
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
IM_1:	move.b	#1,interrupt_mode
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
IM_2:	move.b	#2,interrupt_mode
	rts

*	------ ＬＤ ＸＸ,(nn) ------
	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_BC_lnnl:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	jsr	ms_read_mem_16
	move.w	d0,bc(a3)
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_DE_lnnl:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	jsr	ms_read_mem_16
	move.w	d0,de(a3)
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_HL_lnnl_2:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	jsr	ms_read_mem_16
	move.w	d0,hl(a3)
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_SP_lnnl:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	jsr	ms_read_mem_16
	move.w	d0,sp_(a3)
	rts

*	------ ＬＤ (nn),ＸＸ ------
	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_lnnl_BC:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	move.w	bc(a3),d1
	write_mem_16
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_lnnl_DE:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	move.w	de(a3),d1
	write_mem_16
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_lnnl_HL_2:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	move.w	hl(a3),d1
	write_mem_16
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_lnnl_SP:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0			* d0.w = nn
	move.w	sp_(a3),d1
	write_mem_16
	rts

*	------ ＡＤＣ ------

;---------------------------------------------------------------------------------------
; ADC HL,XX の挙動は以下の通り
; * S : 結果のHLのbit15
; * Z : 結果のHLが0の時1、それ以外の時0
; * F5: 上位8bitの加算の結果のbit5
; * H : 上位8bitの加算の実行によるハーフキャリー
; * F3: 上位8bitの加算の結果のbit5
; * PV: 上位8bitの加算の実行によるオーバーフロー
; * N : 0
; * C : 上位8bitの加算の実行によるキャリー
ADC_HL_XX macro
	bsr	eval_flag_HC_C
	; b18 : 加算なので0
	; b17 : 算術演算なので0
	; b16 : キャリーなしなので0
	; b1  : 加算なのでN=0
	andi.l	#%000_10111101_10111101,d6	* 16bit演算の時は Zフラグを直接セットするので、Zのダーティビットを立てずに0に初期化する
	ori.l	#%000_10111101_00000000,d6	* S,F5,H,F3,PV,Cのダーティビットを立てる
	move.w	hl(a3),d0
	move.w	target_16(a3),d1
	; Xフラグにキャリーをセットし、addx命令を使う
	btst.l	#0,d6
	bne	1f
	andi.b	#%11101111,ccr		* Xフラグをクリア
	bra	2f
1:  	ori.b	#%00010000,ccr		* Xフラグをセット
2:
	addx.b	d1,d0			* 下位８ビット+キャリーを加算
	bcc	@f			* キャリーが発生していない場合はスキップ
	ori.l	#%001_00000000_00000000,d6	* 再計算用キャリーをセット
@@:	move.b	d0,l(a3)		* 下位８ビットを保存
	lsr.w	#8,d0
	lsr.w	#8,d1
	move.b	d0,d5			* 第1項
	lsl.w	#8,d5
	move.b	d1,d5			* 足す数を 第2項に
	swap	d5
	btst	#16,d6
	bne	1f
	and.b	#%11101111,ccr		* Xフラグをクリア
	bra	2f
1:	or.b	#%00010000,ccr		* Xフラグをセット
2:	addx.b	d1,d0			* 演算実行
	move.b	d0,d5			* 結果を保存
	move.b	d0,h(a3)		* 上位８ビットを保存
	move.w	hl(a3),d0
	bne	1f
	ori.l	#%000_00000000_01000000,d6	* Zフラグをセット
1:
	endm
;---------------------------------------------------------------------------------------

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADC_HL_BC:
	move.w	bc(a3),target_16(a3)
	ADC_HL_XX
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADC_HL_DE:
	move.w	de(a3),target_16(a3)
	ADC_HL_XX
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADC_HL_HL:
	move.w	hl(a3),target_16(a3)
	ADC_HL_XX
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADC_HL_SP:
	move.w	sp_(a3),target_16(a3)
	ADC_HL_XX
	rts

*	------ ＳＢＣ ------

;---------------------------------------------------------------------------------------
; SBC HL,XX の挙動は以下の通り
; * S : 結果のHLのbit15
; * Z : 結果のHLが0の時1、それ以外の時0
; * F5: 上位8bitの減算の結果のbit5
; * H : 上位8bitの減算の実行によるハーフキャリー
; * F3: 上位8bitの減算の結果のbit5
; * PV: 上位8bitの減算の実行によるオーバーフロー
; * N : 1
; * C : 上位8bitの減算の実行によるキャリー
SBC_HL_XX macro
	bsr	eval_flag_HC_C
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : キャリーなしなので0
	; b1  : 減算なのでN=1
	andi.l	#%100_10111101_10111101,d6	* 16bit演算の時は Zフラグを直接セットするので、Zのダーティビットを立てずに0に初期化する
	ori.l	#%100_10111101_00000010,d6	* S,F5,H,F3,PV,Cのダーティビットを立てる、N=1にする
	move.w	hl(a3),d0
	move.w	target_16(a3),d1
	; Xフラグにキャリーをセットし、addx命令を使う
	btst.l	#0,d6
	bne	1f
	andi.b	#%11101111,ccr		* Xフラグをクリア
	bra	2f
1:  	ori.b	#%00010000,ccr		* Xフラグをセット
2:
	subx.b	d1,d0			* 下位８ビット+キャリーを減算
	bcc	@f			* キャリーが発生していない場合はスキップ
	ori.l	#%001_00000000_00000000,d6	* 再計算用キャリーをセット
@@:	move.b	d0,l(a3)		* 下位８ビットを保存
	lsr.w	#8,d0
	lsr.w	#8,d1
	move.b	d0,d5			* 第1項
	lsl.w	#8,d5
	move.b	d1,d5			* 引く数を 第2項に
	swap	d5
	btst	#16,d6
	bne	1f
	and.b	#%11101111,ccr		* Xフラグをクリア
	bra	2f
1:
	or.b	#%00010000,ccr		* Xフラグをセット
2:	subx.b	d1,d0			* 演算実行
	move.b	d0,d5			* 結果を保存
	move.b	d0,h(a3)		* 上位８ビットを保存
	move.w	hl(a3),d0
	bne	1f
	ori.l	#%000_00000000_01000000,d6	* Zフラグをセット
1:
	endm
;---------------------------------------------------------------------------------------

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
SBC_HL_BC:
	move.w	bc(a3),target_16(a3)
	SBC_HL_XX
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
SBC_HL_DE:
	move.w	de(a3),target_16(a3)
	SBC_HL_XX
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
SBC_HL_HL:
	move.w	hl(a3),target_16(a3)
	SBC_HL_XX
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
SBC_HL_SP:
	move.w	sp_(a3),target_16(a3)
	SBC_HL_XX
	rts

*	------ ＬＤＩ ------
; LDI の挙動は以下の通り
; (de) <= (hl)
; hl += 1, de += 1, bc -= 1
; フラグ変化は以下の通り
; * S : 変化しない
; * Z : 変化しない
; * F5: (転送された値にAレジスタを足した値)のbit1 (5ではなく1)
; * H : 0
; * F3: (転送された値にAレジスタを足した値)のbit3
; * PV: bc が 0 の時0、それ以外の時1
; * N : 0
; * C : 変化しない
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
LDI:	andi.l	#%111_11000001_11000001,d6	* S,Z,C以外をクリア
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,d1
	add.b	d4,d0			* 転送値にAレジスタを足す
	move.b	d0,d2
	andi.b	#%00001000,d0
	or.b	d0,d6			* F3をセット
	andi.b	#%00000010,d2
	lsl.b	#4,d2
	or.b	d2,d6			* F5をセット
	move.w	de(a3),d0
	write_mem_8
	addq.w	#1,hl(a3)
	addq.w	#1,de(a3)
	subq.w	#1,bc(a3)
	beq	@f
	ori.b	#%00000100,d6		* PVをセット
@@:	rts


; LDIR の挙動は以下の通り
; LDI実行後、
; if bc != 0 then
;     PC -=2 (LDIRを繰り返す)
; else
;     終了
;
; LDIRの命令内で転送を繰り返すのではなく、PCを-2するというのがポイント
; なのでLDIRの実行中に割り込みが入ることも想定される(はず)
	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
LDIR:
	bsr	LDI
	cmpi.w	#0,bc(a3)
	bne	@f
	; 最終の場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7	* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts

; LDD の挙動は以下の通り
; (de) <= (hl)
; hl -= 1, de -= 1, bc -= 1
; フラグ変化は以下の通り
; * S : 変化しない
; * Z : 変化しない
; * F5: (転送された値にAレジスタを足した値)のbit1 (5ではなく1)
; * H : 0
; * F3: (転送された値にAレジスタを足した値)のbit3
; * PV: bc が 0 の時0、それ以外の時1
; * N : 0
; * C : 変化しない
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
LDD:	andi.l	#%111_11000001_11000001,d6	* S,Z,C以外をクリア
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,d1
	add.b	d4,d0			* 転送値にAレジスタを足す
	move.b	d0,d2
	andi.b	#%00001000,d0
	or.b	d0,d6			* F3をセット
	andi.b	#%00000010,d2
	lsl.b	#4,d2
	or.b	d2,d6			* F5をセット
	move.w	de(a3),d0
	write_mem_8
	subq.w	#1,hl(a3)
	subq.w	#1,de(a3)
	subq.w	#1,bc(a3)
	beq	@f
	ori.b	#%00000100,d6		* PVをセット
@@:	rts

; LDDR の挙動は以下の通り
; LDD実行後、
; if bc != 0 then
;     PC -=2 (LDDRを繰り返す)
; else
;     終了
;
; LDDRの命令内で転送を繰り返すのではなく、PCを-2するというのがポイント
; なのでLDDRの実行中に割り込みが入ることも想定される(はず)
	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
LDDR:
	bsr	LDD
	cmpi.w	#0,bc(a3)
	bne	@f
	; 最終の場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7	* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts


*	------ ＣＰＩ ------
; CPI の挙動は以下の通り
; A - (HL) を実行した結果をフラグに反映(S,Z,HC)
; hl += 1, bc -= 1
; フラグ変化は以下の通り
; * S : 結果のbit7
; * Z : 結果が0の時1、それ以外の時0
; * F5: (A - (HL) - HC)のbit1 (5ではなく1)
; * H : 結果のハーフキャリー
; * F3: (A - (HL) - HC)のbit3
; * PV: BC が 0 の時0、それ以外の時1
; * N : 1
; * C : 変化しない
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
CPI:	bsr	eval_flag_HC_C		* HC,Cの再評価
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 減算なのでN=1
	andi.l	#%000_00000000_00000001,d6	* C以外のフラグクリア
	ori.l	#%100_11010000_00000010,d6	* S,Z,HCのダーティビットを立てる、N=1にする
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 足す数を 第2項に
	swap	d5
	move.b	d4,d1
	sub.b	d0,d1			* A - (HL)を実行
	move.b	d1,d5			* 結果を保存
	bsr	eval_flag_HC_C		* HCを取得するために評価する
	move.b	d5,d1
	btst.l	#4,d6			* HCを評価
	beq	1f
	sub.b	#1,d1			* HCが立っている場合はさらに1を引く(F5,F3の評価のため)
1:	move.b	d1,d2			* 結果のbit3を取り出す
	andi.b	#%00001000,d2
	or.b	d2,d6			* F3をセット
	andi.b	#%00000010,d1
	lsl.b	#4,d1
	or.b	d1,d6			* F5をセット
	addq.w	#1,hl(a3)
	subq.w	#1,bc(a3)
	beq	@f
	ori.b	#%00000100,d6		* PVをセット
@@:	rts

	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
CPIR:	bsr	CPI
	cmpi.w	#0,bc(a3)
	bne	@f
	; 最終の場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	bsr	eval_flag_SZ
	btst.l	#6,d6			* Zフラグを評価
	beq	@f
	; 最終の場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7	* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts

*	------ ＣＰＤ ------
; CPD の挙動は以下の通り
; A - (HL) を実行した結果をフラグに反映(S,Z,HC)
; hl -= 1, bc -= 1
; フラグ変化は以下の通り
; * S : 結果のbit7
; * Z : 結果が0の時1、それ以外の時0
; * F5: (A - (HL) - HC)のbit1 (5ではなく1)
; * H : 結果のハーフキャリー
; * F3: (A - (HL) - HC)のbit3
; * PV: BC が 0 の時0、それ以外の時1
; * N : 1
; * C : 変化しない
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
CPD:	bsr	eval_flag_HC_C		* HC,Cの再評価
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 減算なのでN=1
	andi.l	#%000_00000000_00010001,d6	* C, HC以外のフラグクリア
	ori.l	#%100_11010000_00000010,d6	* S,Z,HCのダーティビットを立てる、N=1にする
	move.b	d4,d5			* 第1項
	lsl.w	#8,d5
	move.b	d0,d5			* 引く数を 第2項に
	swap	d5
	move.b	d4,d1
	sub.b	d0,d1			* A - (HL)を実行
	move.b	d1,d5			* 結果を保存
	bsr	eval_flag_HC_C		* HCを取得するために評価する
	move.b	d5,d1
	btst.l	#4,d6			* HCを評価
	beq	1f
	sub.b	#1,d1			* HCが立っている場合はさらに1を引く(F5,F3の評価のため)
1:	move.b	d1,d2			* 結果のbit3を取り出す
	andi.b	#%00001000,d2
	or.b	d2,d6			* F3をセット
	andi.b	#%00000010,d1
	lsl.b	#4,d1
	or.b	d1,d6			* F5をセット
	subq.w	#1,hl(a3)
	subq.w	#1,bc(a3)
	beq	@f
	ori.b	#%00000100,d6		* PVをセット
@@:	rts


	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
CPDR:	bsr	CPD
	cmpi.w	#0,bc(a3)
	bne	@f
	; 最終の場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	bsr	eval_flag_SZ
	btst.l	#6,d6			* Zフラグを評価
	beq	@f
	; 最終の場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7	* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts



*	------ ＮＥＧ ------
; NEG の挙動は以下の通り
; A = 0 - A
; フラグ変化は以下の通り
; * S : 結果のbit7
; * Z : 結果が0の時1、それ以外の時0
; * F5: 結果のbit5
; * H : 結果のハーフキャリー
; * F3: 結果のbit3
; * PV: 結果がオーバーフローした時1、それ以外の時0
; * N : 1
; * C : 結果がキャリーした時1、それ以外の時0
	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
NEG:
	; b18 : 減算なので1
	; b17 : 算術演算なので0
	; b16 : 事前キャリーなしなので0
	; b1  : 減算なのでN=1
	andi.l	#%000_11111101_11111101,d6
	ori.l	#%100_11111101_00000010,d6	* S,Z,F5,H,F3,PV,Cのダーティビットを立てる、N=1にする
	move.b	#0,d5			* 第1項
	lsl.w	#8,d5
	move.b	d4,d5			* 引く数を 第2項に
	swap	d5
	moveq.l	#0,d0
	sub.b	d4,d0			* 演算実行
	move.b	d0,d5			* 結果を保存
	move.b	d0,d4			* 結果をAレジスタに保存
	rts

*	------ 掛け算命令 ------

;---------------------------------------------------------------------------------------
; MULB A,X の挙動は以下の通り https://www.msx.org/forum/development/msx-development/r800-multiply-instruction
; HL <= A * X
; ※ ただしXがb,c,d,eのとき以外は動作が保証されないという仕様がある
; フラグ変化は以下の通り
; * S : 0
; * Z : 結果が0の時1、それ以外の時0
; * F5: 変化しない
; * H : 変化しない
; * F3: 変化しない
; * PV: 0
; * N : 変化しない
; * C : 掛け算の結果が8bitを超えた時1、それ以外の時0
;
MULB_A_X macro
	andi.l	#%000_00111010_00111010,d6	* F5,H,H3,N以外をクリア
	clr.w	d0
	clr.w	d1
	move.b	d4,d0			* d0 <- A
	move.b	target_8(a3),d1		* d1 <- target
	mulu.w	d1,d0
	bne	@f
	ori.w	#%01000000,d6		* Zフラグをセット
@@:	move.w	d0,hl(a3)		* 結果をHLに保存
	andi.w	#$ff00,d0
	beq	@f
	ori.w	#%00000001,d6		* Cフラグをセット
@@:
	endm
;---------------------------------------------------------------------------------------

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULB_A_A:
	move.b	d4,target_8(a3)
	MULB_A_X
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULB_A_B:
	move.b	b(a3),target_8(a3)
	MULB_A_X
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULB_A_C:
	move.b	c(a3),target_8(a3)
	MULB_A_X
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULB_A_D:
	move.b	d(a3),target_8(a3)
	MULB_A_X
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULB_A_E:
	move.b	e(a3),target_8(a3)
	MULB_A_X
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULB_A_H:
	move.b	h(a3),target_8(a3)
	MULB_A_X
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULB_A_L:
	move.b	l(a3),target_8(a3)
	MULB_A_X
	rts

;---------------------------------------------------------------------------------------
; MULW HL,XX の挙動は以下の通り https://www.msx.org/forum/development/msx-development/r800-multiply-instruction
; DE:HL <= HL * XX
; ※ ただしXがBC,SPのとき以外は動作が保証されないという仕様がある
; フラグ変化は以下の通り
; * S : 0
; * Z : 結果が0の時1、それ以外の時0
; * F5: 変化しない
; * H : 変化しない
; * F3: 変化しない
; * PV: 0
; * N : 変化しない
; * C : 掛け算の結果が16bitを超えた時1、それ以外の時0
MULW_HL_XX macro
	andi.l	#%000_00111010_00111010,d6	* F5,H,H3,N以外をクリア
	move.w	hl(a3),d0		* d0 <- HL
	move.w	target_16(a3),d1	* d1 <- target
	mulu.w	d1,d0			* d0.l <= d0.w * d1.w (mulu.wは結果が32bitでd0に格納されるので注意)
	bne	@f
	ori.w	#%01000000,d6		* Zフラグをセット
@@:	move.w	d0,hl(a3)		* 結果の下位16bitをHLに保存
	swap	d0
	move.w	d0,de(a3)		* 結果の上位16bitをDEに保存
	beq	@f
	ori.w	#%00000001,d6		* 上位16bitが0じゃない場合はCフラグをセット
@@:
	endm
;---------------------------------------------------------------------------------------

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULW_HL_BC:
	move.w	bc(a3),target_16(a3)
	MULW_HL_XX
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULW_HL_DE:
	move.w	de(a3),target_16(a3)
	MULW_HL_XX
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULW_HL_HL:
	move.w	hl(a3),target_16(a3)
	MULW_HL_XX
	rts

	.dc.w	0			* サイクル数は仮
	.dc.w	2-1			* 命令語長-1
MULW_HL_SP:
	move.w	sp_(a3),target_16(a3)
	MULW_HL_XX
	rts


*	------ ＬＤ Ｒ ------
*	RレジスタはM1サイクルごとにインクリメントされるレジスタ
*	LD R,A で代入も可能。インクリメントされるのは下位7bit(Z80)のため、
*	bit7は LR R,Aで代入した値がそのまま残る
*	ms.x では、M1サイクルを正確に数えていないので、emu_counterで代用
; LD A,R の挙動は以下の通り
; * S : Rのbit7
; * Z : Rが0の時1、それ以外の時0
; * F5: 変化しない
; * H : 0
; * F3: 変化しない
; * PV: IFF2の値
; * N : 0
; * C : 変化しない
	.dc.w	9			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_R:	bsr	eval_flag_all
	andi.l	#%000_00000000_00101001,d6	* S,Z,HC,PV,Nをクリア
	move.b	r(a3),d4
	; bit7はLD R,Aで代入した値がそのまま残る
	andi.b	#%10000000,d4		* bit7 を取り出す
	; Rレジスタは下位7bitのみがインクリメントされる
	move.l	emu_counter,d0
	sub.l	emu_counter_latch_r,d0
	add.b	r(a3),d0
	andi.b	#%01111111,d0		* 下位7bitのみ
	or.b	d0,d4
	bne	1f
	ori.w	#%01000000,d6		* Zフラグをセット
1:	btst.l	#7,d4
	beq	1f
	ori.w	#%10000000,d6		* Sフラグをセット
1:
	cmpi.b	#0,interrupt_enable	* IFF の状態を反映
	beq	1f			* DI 状態の時 P/V <= 0
	ori.w	#%00000100,d6		* EI 状態の時 P/V <= 1
1:	rts

	.dc.w	9			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_R_A:	move.b	d4,r(a3)
	move.l	emu_counter,emu_counter_latch_r	* Rレジスタがセットされたときのカウンタを覚えておく
	rts

*	------ ＬＤ Ｉ ------
	.dc.w	9			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_I: bsr	eval_flag_all
	andi.l	#%000_00000000_00101001,d6	* S,Z,HC,PV,Nをクリア
	move.b	i(a3),d4
	bne	1f
	ori.w	#%01000000,d6		* Zフラグをセット
1:	btst.l	#7,d4
	beq	1f
	ori.w	#%10000000,d6		* Sフラグをセット
1:
	cmpi.b	#0,interrupt_enable	* IFF の状態を反映
	beq	1f			* DI 状態の時 P/V <= 0
	ori.w	#%00000100,d6		* EI 状態の時 P/V <= 1
1:	rts

	.dc.w	9			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_I_A:	move.b	d4,i(a3)
	rts

*	ちゃんとやってない
*	------ ＲＥＴＮ ------
	.dc.w	14			* サイクル数
	.dc.w	2-1			* 命令語長-1
RETN:	move.w	sp_(a3),d0
	jsr	ms_read_mem_16
	addq.w	#2,sp_(a3)
	move.w	d0,d7
	PC_page_set
	rts

*	------ ＲＥＴＩ ------
	.dc.w	14			* サイクル数
	.dc.w	2-1			* 命令語長-1
RETI:	move.w	sp_(a3),d0
	jsr	ms_read_mem_16
	addq.w	#2,sp_(a3)
	cmp.w	interrupt_return,d0	* 割り込み発生時にセットした戻り先アドレスに戻ったか？
	bne	@f
	move.w	#0,interrupt_return
@@:	move.w	d0,d7
	PC_page_set
	rts

*************************************************************************
*
*	＄ＤＤ,＄ＦＤライン命令
*		（Ｉｎｄｅｘ関係）
*
*************************************************************************
;	DDライン命令のサイクル数は不定なので0にしておき、各命令ごとに加算する
;	DDラインの命令語長は2-4バイトなので、ここは2にしておき、各命令ごとに加算する
	.dc.w	0			* サイクル数
	.dc.w	2-1			* 命令語長-1
DD:	moveq.l	#0,d2
	bra	@f

;	FDライン命令のサイクル数は不定なので0にしておき、各命令ごとに加算する
;	FDラインの命令語長は2-4バイトなので、ここは2にしておき、各命令ごとに加算する
	.dc.w	0			* サイクル数
	.dc.w	2-1			* 命令語長-1
FD:	moveq.l	#2,d2
	bra	@f

	* 先読みした値から第二オペコードを取り出す
@@:	clr.w	d0
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d0
	movea.l	DDFD_JPT(pc,d0.w*4),a0	* ジャンプ先を取得
	move.w	-4(a0),d0		* 命令のサイクル数を取得
	ext.l	d0
	add.l	d0,cpu_cycle		* サイクル数を加算
	move.w	-2(a0),d0		* 命令語長-1を取得
	subq.w	#1,d0
	ble	@f			* 2バイトの場合
	; 3バイト以上の時
	add.w	d0,d7
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f
	PC_page_inc
	andi.w	#PAGEADDRMASK,d7
@@:	; この時点のレジスタは以下の通り
	; d0.l : N/A
	; d1.l : 命令語長が2の時はN/A。それ以外は3バイト目から5バイト目の値が入っている
	; d2.l : DDの場合は0、FDの場合は2
	; d7.l : 命令語長だけ進めたPCの値
	jmp	(a0)

DDFD_JPT:
	.dc.l	none_DDFD		* $00
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	LD_B_n_2
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $08
	.dc.l	ADD_Idx_BC
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	LD_C_n_2
	.dc.l	none_DDFD		* $0f

	.dc.l	none_DDFD		* $10
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	LD_D_n_2
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $18
	.dc.l	ADD_Idx_DE
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	LD_E_n_2
	.dc.l	none_DDFD		* $1f

	.dc.l	none_DDFD		* $20
	.dc.l	LD_Idx_nn
	.dc.l	LD_lnnl_Idx
	.dc.l	INC_Idx
	.dc.l	INC_IdxH
	.dc.l	DEC_IdxH
	.dc.l	LD_IdxH_n
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $28
	.dc.l	ADD_Idx_Idx
	.dc.l	LD_Idx_lnnl
	.dc.l	DEC_Idx
	.dc.l	INC_IdxL
	.dc.l	DEC_IdxL
	.dc.l	LD_IdxL_n
	.dc.l	none_DDFD		* $2f

	.dc.l	none_DDFD		* $30
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	INC_lIdx_dl
	.dc.l	DEC_lIdx_dl
	.dc.l	LD_lIdx_dl_n
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $38
	.dc.l	ADD_Idx_SP
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	LD_A_n_2
	.dc.l	none_DDFD		* $3f

	.dc.l	LD_B_B_2		* $40
	.dc.l	LD_B_C_2
	.dc.l	LD_B_D_2
	.dc.l	LD_B_E_2
	.dc.l	LD_B_IdxH
	.dc.l	LD_B_IdxL
	.dc.l	LD_B_lIdx_dl
	.dc.l	LD_B_A_2
	.dc.l	LD_C_B_2		* $48
	.dc.l	LD_C_C_2
	.dc.l	LD_C_D_2
	.dc.l	LD_C_E_2
	.dc.l	LD_C_IdxH
	.dc.l	LD_C_IdxL
	.dc.l	LD_C_lIdx_dl
	.dc.l	LD_C_A_2		* $4f

	.dc.l	LD_D_B_2		* $50
	.dc.l	LD_D_C_2
	.dc.l	LD_D_D_2
	.dc.l	LD_D_E_2
	.dc.l	LD_D_IdxH
	.dc.l	LD_D_IdxL
	.dc.l	LD_D_lIdx_dl
	.dc.l	LD_D_A_2
	.dc.l	LD_E_B_2		* $58
	.dc.l	LD_E_C_2
	.dc.l	LD_E_D_2
	.dc.l	LD_E_E_2
	.dc.l	LD_E_IdxH
	.dc.l	LD_E_IdxL
	.dc.l	LD_E_lIdx_dl
	.dc.l	LD_E_A_2		* $5f

	.dc.l	LD_IdxH_B		* $60
	.dc.l	LD_IdxH_C
	.dc.l	LD_IdxH_D
	.dc.l	LD_IdxH_E
	.dc.l	LD_IdxH_IdxH
	.dc.l	LD_IdxH_IdxL
	.dc.l	LD_H_lIdx_dl
	.dc.l	LD_IdxH_A
	.dc.l	LD_IdxL_B		* $68
	.dc.l	LD_IdxL_C
	.dc.l	LD_IdxL_D
	.dc.l	LD_IdxL_E
	.dc.l	LD_IdxL_IdxH
	.dc.l	LD_IdxL_IdxL
	.dc.l	LD_L_lIdx_dl
	.dc.l	LD_IdxL_A		* $6f

	.dc.l	LD_lIdx_dl_B	* $70
	.dc.l	LD_lIdx_dl_C
	.dc.l	LD_lIdx_dl_D
	.dc.l	LD_lIdx_dl_E
	.dc.l	LD_lIdx_dl_H
	.dc.l	LD_lIdx_dl_L
	.dc.l	none_DDFD
	.dc.l	LD_lIdx_dl_A
	.dc.l	LD_A_B_2		* $78
	.dc.l	LD_A_C_2
	.dc.l	LD_A_D_2
	.dc.l	LD_A_E_2
	.dc.l	LD_A_IdxH
	.dc.l	LD_A_IdxL
	.dc.l	LD_A_lIdx_dl
	.dc.l	LD_A_A_2		* $7f

	.dc.l	none_DDFD		* $80
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	ADD_A_IdxH
	.dc.l	ADD_A_IdxL
	.dc.l	ADD_A_lIdx_dl
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $88
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	ADC_A_IdxH
	.dc.l	ADC_A_IdxL
	.dc.l	ADC_A_lIdx_dl
	.dc.l	none_DDFD		* $8f

	.dc.l	none_DDFD		* $90
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	SUB_IdxH
	.dc.l	SUB_IdxL
	.dc.l	SUB_lIdx_dl
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $98
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	SBC_A_IdxH
	.dc.l	SBC_A_IdxL
	.dc.l	SBC_A_lIdx_dl
	.dc.l	none_DDFD		* $9f

	.dc.l	none_DDFD		* $a0
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	AND_IdxH
	.dc.l	AND_IdxL
	.dc.l	AND_lIdx_dl
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $a8
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	XOR_IdxH
	.dc.l	XOR_IdxL
	.dc.l	XOR_lIdx_dl
	.dc.l	none_DDFD		* $af

	.dc.l	none_DDFD		* $b0
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	OR_IdxH
	.dc.l	OR_IdxL
	.dc.l	OR_lIdx_dl
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $b8
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	CP_IdxH
	.dc.l	CP_IdxL
	.dc.l	CP_lIdx_dl
	.dc.l	none_DDFD		* $bf

	.dc.l	none_DDFD		* $c0
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $c8
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	DDFD_CB
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $cf

	.dc.l	none_DDFD		* $d0
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $d8
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $df

	.dc.l	none_DDFD		* $e0
	.dc.l	POP_Idx
	.dc.l	none_DDFD
	.dc.l	EX_lSPl_Idx
	.dc.l	none_DDFD
	.dc.l	PUSH_Idx
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $e8
	.dc.l	JP_lIdxl
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $ef

	.dc.l	none_DDFD		* $f0
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $f8
	.dc.l	LD_SP_Idx
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD
	.dc.l	none_DDFD		* $ff

	.dc.w	4			* サイクル数は+4されるので4をセットしておく
	.dc.w	2-1			* 命令語長-1
none_DDFD:				* その他の DD/FD系の命令は、DD/FDを除いた命令を実行する(例: 0xdd 0x00 なら 0x00 のNOPになる)
	subq.w	#1,d7			* DD/FDなしの命令を呼び出すが、すでにPCを+2しているので、-1し、再解釈する
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f			* PC -1 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	bsr 	cpu_exec_core
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_A_2:
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_B_2:
	move.b	b(a3),d4
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_C_2:
	move.b	c(a3),d4
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_D_2:
	move.b	d(a3),d4
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_E_2:
	move.b	e(a3),d4
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_IdxH:
	move.b	ix_h(a3,d2.w),d4
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_A_IdxL:
	move.b	ix_l(a3,d2.w),d4
	rts

	.dc.w	11			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_A_n_2:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d4
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_A_2:
	move.b	d4,b(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_B_2:
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_C_2:
	move.b	c(a3),b(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_D_2:
	move.b	d(a3),b(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_E_2:
	move.b	e(a3),b(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_IdxH:
	move.b	ix_h(a3,d2.w),b(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_B_IdxL:
	move.b	ix_l(a3,d2.w),b(a3)
	rts

	.dc.w	11			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_B_n_2:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,b(a3)
	rts


	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_A_2:
	move.b	d4,c(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_B_2:
	move.b	b(a3),c(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_C_2:
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_D_2:
	move.b	d(a3),c(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_E_2:
	move.b	e(a3),c(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_IdxH:
	move.b	ix_h(a3,d2.w),c(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_C_IdxL:
	move.b	ix_l(a3,d2.w),c(a3)
	rts

	.dc.w	11			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_C_n_2:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,c(a3)
	rts


	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_A_2:
	move.b	d4,d(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_B_2:
	move.b	b(a3),d(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_C_2:
	move.b	c(a3),d(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_D_2:
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_E_2:
	move.b	e(a3),d(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_IdxH:
	move.b	ix_h(a3,d2.w),d(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_D_IdxL:
	move.b	ix_l(a3,d2.w),d(a3)
	rts

	.dc.w	11			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_D_n_2:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_A_2:
	move.b	d4,e(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_B_2:
	move.b	b(a3),e(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_C_2:
	move.b	c(a3),e(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_D_2:
	move.b	d(a3),e(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_E_2:
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_IdxH:
	move.b	ix_h(a3,d2.w),e(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_E_IdxL:
	move.b	ix_l(a3,d2.w),e(a3)
	rts

	.dc.w	11			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_E_n_2:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,e(a3)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxH_A:
	move.b	d4,ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxL_A:
	move.b	d4,ix_l(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxH_B:
	move.b	b(a3),ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxL_B:
	move.b	b(a3),ix_l(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxH_C:
	move.b	c(a3),ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxL_C:
	move.b	c(a3),ix_l(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxH_D:
	move.b	d(a3),ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxL_D:
	move.b	d(a3),ix_l(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxH_E:
	move.b	e(a3),ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxL_E:
	move.b	e(a3),ix_l(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxH_IdxH:
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxL_IdxH:
	move.b	ix_h(a3,d2.w),ix_l(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxH_IdxL:
	move.b	ix_l(a3,d2.w),ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_IdxL_IdxL:
	rts

	.dc.w	11			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_IdxH_n:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,ix_h(a3,d2.w)
	rts

	.dc.w	11			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_IdxL_n:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,ix_l(a3,d2.w)
	rts

;---------------------------------------------------------------------------------------
DECPC__	macro
	subq.w	#1,d7
	btst.l	#PAGEADDRBIT,d7	* PC がページ境界をまたいだか？
	beq	@f			* PC -1 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:
	endm
;---------------------------------------------------------------------------------------

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_A_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	ADD_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_A_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	ADD_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADC_A_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	ADC_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADC_A_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	ADC_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
SUB_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	SUB_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
SUB_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	SUB_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
SBC_A_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	SBC_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
SBC_A_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	SBC_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
AND_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	AND_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
AND_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	AND_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
XOR_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
XOR_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	_OR_X	eor
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
OR_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	_OR_X	or
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
OR_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	_OR_X	or
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
CP_IdxH:
	move.b	ix_h(a3,d2.w),target_8(a3)
	CP_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
CP_IdxL:
	move.b	ix_l(a3,d2.w),target_8(a3)
	CP_A_X
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
INC_IdxH:
	move.w	d1,-(sp)
	move.b	ix_h(a3,d2.w),target_8(a3)
	INC_X
	move.w	(sp)+,d1
	move.b	d0,ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
INC_IdxL:
	move.w	d1,-(sp)
	move.b	ix_l(a3,d2.w),target_8(a3)
	INC_X
	move.w	(sp)+,d1
	move.b	d0,ix_l(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
DEC_IdxH:
	move.w	d2,-(sp)
	move.b	ix_h(a3,d2.w),target_8(a3)
	DEC_X
	move.w	(sp)+,d2
	move.b	d0,ix_h(a3,d2.w)
	rts

	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
DEC_IdxL:
	move.w	d2,-(sp)
	move.b	ix_l(a3,d2.w),target_8(a3)
	DEC_X
	move.w	(sp)+,d2
	move.b	d0,ix_l(a3,d2.w)
	rts


	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
ADD_A_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	ADD_A_X
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
ADC_A_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	ADC_A_X	ADC_A_lIdx_dl_fallback
	rts

ADC_A_lIdx_dl_fallback:
	ADD_A_X
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
SUB_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SUB_A_X
	rts


	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
SBC_A_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SBC_A_X	SBC_A_lIdx_dl_fallback
	rts

SBC_A_lIdx_dl_fallback:
	SUB_A_X
	rts


	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
AND_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	AND_X
	rts	

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
XOR_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	_OR_X	eor
	rts		

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
OR_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	_OR_X	or
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
CP_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	CP_A_X
	rts

	.dc.w	23			* サイクル数
	.dc.w	3-1			* 命令語長-1
INC_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.w	d0,-(sp)
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	INC_X
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	3-1			* 命令語長-1
DEC_lIdx_dl:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.w	d0,-(sp)
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	DEC_X
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts


;---------------------------------------------------------------------------------------
; ADD Idx,XX の挙動は以下の通り
; * S : 変化しない
; * Z : 変化しない
; * F5: 上位8bitの加算の結果のbit5
; * H : 上位8bitの加算の実行によるハーフキャリー
; * F3: 上位8bitの加算の結果のbit5
; * PV: 変化しない
; * N : 0
; * C : 上位8bitの加算の実行によるキャリー
ADD_Idx_XX macro	ixiy
	bsr	eval_flag_all
	; b18 : 加算なので0
	; b17 : 算術演算なので0
	; b16 : キャリーなしなので0
	; b1  : 加算なのでN=0
	andi.l	#%000_00000000_11000100,d6	* S,Z,PVのみ保存
	ori.l	#%000_00111001_00000000,d6	* F5,H,F3,Cのダーティビットを立てる
	move.w	ixiy(a3),d0
	move.w	target_16(a3),d1
	add.b	d1,d0			* 下位８ビットを加算
	bcc	@f			* キャリーが発生していない場合はスキップ
	ori.l	#%001_00000000_00000000,d6	* 再計算用キャリーをセット
@@:	move.b	d0,(ixiy+1)(a3)		* 下位８ビットを保存
	lsr.w	#8,d0
	lsr.w	#8,d1
	move.b	d0,d5			* 第1項
	lsl.w	#8,d5
	move.b	d1,d5			* 足す数を 第2項に
	swap	d5
	and.b	#%11101111,ccr		* Xフラグをクリア
	btst	#16,d6
	beq	1f
	or.b	#%00010000,ccr		* Xフラグをセット
1:	addx.b	d1,d0			* 演算実行
	move.b	d0,d5			* 結果を保存
	move.b	d0,(ixiy+0)(a3)		* 上位８ビットを保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_Idx_BC:
	move.w	bc(a3),target_16(a3)
	cmpi.w	#0,d2
	bne	ADD_IY_XX
	ADD_Idx_XX	ix
	rts
ADD_IY_XX:
	ADD_Idx_XX	iy
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_Idx_DE:
	move.w	de(a3),target_16(a3)
	cmpi.w	#0,d2
	bne	ADD_IY_XX
	ADD_Idx_XX	ix
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_Idx_SP:
	move.w	sp_(a3),target_16(a3)
	cmpi.w	#0,d2
	bne	ADD_IY_XX
	ADD_Idx_XX	ix
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_Idx_Idx:
	cmpi.w	#0,d2
	bne	ADD_IY_IY
	move.w	ix(a3),target_16(a3)
	ADD_Idx_XX	ix
	rts

	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
ADD_IY_IY:
	move.w	iy(a3),target_16(a3)
	ADD_Idx_XX	iy
	rts


*	------ ＬＤ Ｉｄｘ ------
	.dc.w	14			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_Idx_nn:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,ix(a3,d2.w)
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_Idx_lnnl:
	move.w	d2,-(sp)
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0
	jsr	ms_read_mem_16
	move.w	(sp)+,d2
	move.w	d0,ix(a3,d2.w)
	rts

	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_lnnl_Idx:
	* 先読みした値からnnを取り出す
	swap	d1			* 下位ワードへ移動
	rol.w	#8,d1			* エンディアンを逆に
	move.w	d1,d0
	move.w	ix(a3,d2.w),d1
	write_mem_16
	rts

	.dc.w	10			* サイクル数
	.dc.w	2-1			* 命令語長-1
LD_SP_Idx:
	move.w	ix(a3,d2.w),sp_(a3)
	rts


*	------ ＩＮＣ ------
	.dc.w	10			* サイクル数
	.dc.w	2-1			* 命令語長-1
INC_Idx:				* フラグは不変
	addq.w	#1,ix(a3,d2.w)
	rts

	.dc.w	10			* サイクル数
	.dc.w	2-1			* 命令語長-1
DEC_Idx:
	subq.w	#1,ix(a3,d2.w)
	rts

*	------ ＬＤ ？,（Ｉｄｘ＋ｄ） ------
	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_A_lIdx_dl:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d4
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_B_lIdx_dl:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,b(a3)
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_C_lIdx_dl:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,c(a3)
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_D_lIdx_dl:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,d(a3)
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_E_lIdx_dl:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,e(a3)
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_H_lIdx_dl:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,h(a3)
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_L_lIdx_dl:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	jsr	ms_read_mem_8		*メモリから 8ビットのデータを d0に読み込む。
	move.b	d0,l(a3)
	rts


*	------ ＬＤ （Ｉｄｘ＋ｄ）,？ ------
	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lIdx_dl_A:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.b	d4,d1
	write_mem_8
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lIdx_dl_B:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.b	b(a3),d1
	write_mem_8
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lIdx_dl_C:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.b	c(a3),d1
	write_mem_8
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lIdx_dl_D:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.b	d(a3),d1
	write_mem_8
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lIdx_dl_E:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.b	e(a3),d1
	write_mem_8
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lIdx_dl_H:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.b	h(a3),d1
	write_mem_8
	rts

	.dc.w	19			* サイクル数
	.dc.w	3-1			* 命令語長-1
LD_lIdx_dl_L:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	move.b	l(a3),d1
	write_mem_8
	rts

	.dc.w	19			* サイクル数
	.dc.w	4-1			* 命令語長-1
LD_lIdx_dl_n:
	move.w	ix(a3,d2.w),d0
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0
	* 先読みした値から nを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	write_mem_8
	rts


*	------ ＰＵＳＨ Ｉｄｘ
	.dc.w	15			* サイクル数
	.dc.w	2-1			* 命令語長-1
PUSH_Idx:
	subq.w	#2,sp_(a3)
	move.w	sp_(a3),d0
	move.w	ix(a3,d2.w),d1
	write_mem_16
	rts

	.dc.w	14			* サイクル数
	.dc.w	2-1			* 命令語長-1
POP_Idx:
	move.w	d2,-(sp)
	move.w	sp_(a3),d0
	jsr	ms_read_mem_16
	addq.w	#2,sp_(a3)
	move.w	(sp)+,d2
	move.w	d0,ix(a3,d2.w)
	rts


*	------ ＪＰ (Ｉｄｘ) ------
	.dc.w	8			* サイクル数
	.dc.w	2-1			* 命令語長-1
JP_lIdxl:
	move.w	ix(a3,d2.w),d7
	PC_page_set
	rts


*	------ ＥＸ ------
	.dc.w	23			* サイクル数
	.dc.w	2-1			* 命令語長-1
EX_lSPl_Idx:
	move.w	d2,-(sp)
	move.w	sp_(a3),d0
	jsr	ms_read_mem_16
	move.w	(sp)+,d2
	move.w	ix(a3,d2.w),d1
	move.w	d0,ix(a3,d2.w)
	move.w	sp_(a3),d0
	write_mem_16
	rts

*	------ Ｓｙｓｔｅｍ Ｅｎｄ ------
system_end:
	bra	emu_end

*	------ デバッガに制御を渡す ------
stop:
	rts



**********************************************************************
*
*	ＤＤ/ＦＤ ＣＢライン命令
*
**********************************************************************
;	DD/FD CBライン命令のサイクル数は不定なので0にしておき、各命令ごとに加算する
;	DD/FD CBラインの命令語長は4バイトなので、ここで4にしておき、各命令ごとに加算しなくて済むようにする
	.dc.w	0			* サイクル数
	.dc.w	4-1			* 命令語長-1
DDFD_CB:
	move.w	ix(a3,d2.w),d0		* IX or IYを読む
	* 先読みした値から dを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	ext.w	d1
	add.w	d1,d0			* d0 = Idx + d
	* 先読みした値から OP CODEを取り出す
	clr.w	d1
	rol.l	#8,d1			* 最下位バイトに移動
	movea.l	DDFD_CB_JPT(pc,d1.w*4),a0	* ジャンプ先を取得
	move.w	-4(a0),d3		* 命令のサイクル数を取得
	ext.l	d3
	add.l	d3,cpu_cycle		* サイクル数を加算
	; この時点のレジスタは以下の通り
	; d0.l : IX or IY + d
	; d1.l : OP CODE
	; d2.l : DDの場合は0、FDの場合は2
	; d7.l : 命令語長だけ進めたPCの値
	jmp	(a0)

DDFD_CB_JPT:
	.dc.l	none_DDFD_CB	* $00
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	RLC_lIdx_dl	* $06
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB	* $08
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	RRC_lIdx_dl	* $0e
	.dc.l	none_DDFD_CB	* $0f

	.dc.l	none_DDFD_CB	* $10
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	RL_lIdx_dl		* $16
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB	* $18
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	RR_lIdx_dl		* $1e
	.dc.l	none_DDFD_CB	* $1f

	.dc.l	none_DDFD_CB	* $20
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	SLA_lIdx_dl	* $26
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB	* $28
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	SRA_lIdx_dl	* $2e
	.dc.l	none_DDFD_CB	* $2f

	.dc.l	none_DDFD_CB	* $30
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	SLI_lIdx_dl	* $36
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB	* $38
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	none_DDFD_CB
	.dc.l	SRL_lIdx_dl	* $3e
	.dc.l	none_DDFD_CB	* $3f

	.dc.l	BIT_lIdx_dl	* $40
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $46
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $48
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $4e
	.dc.l	BIT_lIdx_dl	* $4f

	.dc.l	BIT_lIdx_dl	* $50
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $56
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $58
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $5e
	.dc.l	BIT_lIdx_dl	* $5f

	.dc.l	BIT_lIdx_dl	* $60
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $66
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $68
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $6e
	.dc.l	BIT_lIdx_dl	* $6f

	.dc.l	BIT_lIdx_dl	* $70
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $76
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $78
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl
	.dc.l	BIT_lIdx_dl	* $7e
	.dc.l	BIT_lIdx_dl	* $7f

	.dc.l	RES_lIdx_dl_B	* $80
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl	* $86
	.dc.l	RES_lIdx_dl_A
	.dc.l	RES_lIdx_dl_B	* $88
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl
	.dc.l	RES_lIdx_dl_A	* $8f

	.dc.l	RES_lIdx_dl_B	* $90
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl
	.dc.l	RES_lIdx_dl_A
	.dc.l	RES_lIdx_dl_B	* $98
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl
	.dc.l	RES_lIdx_dl_A	* $9f

	.dc.l	RES_lIdx_dl_B	* $a0
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl
	.dc.l	RES_lIdx_dl_A
	.dc.l	RES_lIdx_dl_B	* $a8
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl
	.dc.l	RES_lIdx_dl_A	* $af

	.dc.l	RES_lIdx_dl_B	* $b0
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl
	.dc.l	RES_lIdx_dl_A
	.dc.l	RES_lIdx_dl_B	* $b8
	.dc.l	RES_lIdx_dl_C
	.dc.l	RES_lIdx_dl_D
	.dc.l	RES_lIdx_dl_E
	.dc.l	RES_lIdx_dl_H
	.dc.l	RES_lIdx_dl_L
	.dc.l	RES_lIdx_dl	* $be
	.dc.l	RES_lIdx_dl_A	* $bf

	.dc.l	SET_lIdx_dl_B	* $c0
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl	* $c6
	.dc.l	SET_lIdx_dl_A
	.dc.l	SET_lIdx_dl_B	* $c8
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl
	.dc.l	SET_lIdx_dl_A	* $cf

	.dc.l	SET_lIdx_dl_B	* $d0
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl
	.dc.l	SET_lIdx_dl_A
	.dc.l	SET_lIdx_dl_B	* $d8
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl
	.dc.l	SET_lIdx_dl_A	* $df

	.dc.l	SET_lIdx_dl_B	* $e0
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl
	.dc.l	SET_lIdx_dl_A
	.dc.l	SET_lIdx_dl_B	* $e8
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl
	.dc.l	SET_lIdx_dl_A	* $ef

	.dc.l	SET_lIdx_dl_B	* $f0
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl
	.dc.l	SET_lIdx_dl_A
	.dc.l	SET_lIdx_dl_B	* $f8
	.dc.l	SET_lIdx_dl_C
	.dc.l	SET_lIdx_dl_D
	.dc.l	SET_lIdx_dl_E
	.dc.l	SET_lIdx_dl_H
	.dc.l	SET_lIdx_dl_L
	.dc.l	SET_lIdx_dl	* $fe
	.dc.l	SET_lIdx_dl_A	* $ff

; d0 には Idx + d がセットされて呼ばれる

	.dc.w	0			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
none_DDFD_CB:				* おかしな命令を実行しました
	move.w	d1,d0			* d1はOP CODE
	lsr.w	#4,d0
	lea.l	HEX,a0
	move.b	(a0,d0.w),number_ddfdcb+0
	andi.w	#$0f,d1
	move.b	(a0,d1.w),number_ddfdcb+1

	pea.l	errms_ddfdcb
	DOS	__PRINT
	lea.l	4(sp),sp
	move.b	#$ff,d0
	rts

errms_ddfdcb:
	.dc.b	'おかしな命令を実行しました。0xdd or 0xfd,0xcb,nn,0x'
number_ddfdcb:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00

	.even


; d0 には Idx + d がセットされて呼ばれる
	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RLC_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	1, 1
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RRC_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	0, 1
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RL_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	1, 0
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RR_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	RXX_	0, 0
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SLA_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	1, 0
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SRA_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	0, 2
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SRL_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	0, 0
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SLI_lIdx_dl:
	move.w	d0,-(sp)		* Idx + d を退避
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)
	SXX	1, 1
	move.b	d0,d1
	move.w	(sp)+,d0
	write_mem_8
	rts

*	------ ＢＩＴ n,(Idx+d) ------
; ＢＩＴ命令の挙動は以下の通り
; * S : BIT 7,?の時だけ、対象のbit7が1なら1。それ以外の時は0
; * Z : 対象のbitが0なら1。それ以外の時は0
; * F5: Idx+d の上位8bitの値(bit13)が入る
; * H : 1
; * F3: Idx+d の上位8bitの値(bit11)が入る
; * PV: Zフラグと同じ
; * N : 0
; * C : 変化しない
; ただし、対象が(HL)の場合だけ、F5,F3は内部のWZレジスタの上位8bitの値(bit13,11)が入るらしい

; d0 には Idx + d がセットされて呼ばれる
; d1 には DD CB dd XX の XX (OP CODE)が入っている
	.dc.w	20			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
BIT_lIdx_dl:
	andi.w	#%00000000_00111000,d1	* BIT_n_? の n を d1にロード
	lsr.w	#3,d1
	moveq.l	#1,d2
	lsl	d1,d2			* 対象位置のビットをセット
	move.w	d0,-(sp)		* Idx + d を退避
	move.w	d2,-(sp)
	move.w	d0,-(sp)		* Idx + d を退避
	bsr	eval_flag_HC_C		* HC,C フラグを再評価
	andi.l	#%000_00000000_00000001,d6	* Cフラグ以外をクリア
	ori.l	#%000_00000000_00010000,d6	* Hフラグをセット
	move.w	(sp)+,d0		* Idx + d を復帰
	jsr	ms_read_mem_8
	move.w	(sp)+,d2
	move.w	(sp)+,d1		* Idx + d を復帰
	lsr.w	#8,d1			* (Idx)の時、F5,F3には読み出したアドレス(=Idx+d)の上位8bitを使う
	andi.b	#%00101000,d1		* F5,F3を取得
	or.b	d1,d6			* F5,F3をFレジスタに反映
	and.b	d2,d0			* レジスタの nビット目をテストするためにマスク
	bne	1f
	ori.l	#%000_00000000_01000100,d6	* Z,PVフラグをセット
1:	andi.b	#%10000000,d0		* bit7のみ残す
	or.b	d0,d6			* bit7を Sフラグに反映
	rts


*	------ ＳＥＴ n,(Idx+d) ------
; d0 には Idx + d がセットされて呼ばれる
; d1 には DD CB dd XX の XX (OP CODE)が入っている
	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl:
	andi.w	#%00000000_00111000,d1		* BIT_n_? の n を d1にロード
	lsr.w	#3,d1
	move.w	d0,-(sp)			* Idx + d を退避
	move.w	d1,-(sp)
	jsr	ms_read_mem_8
	move.w	(sp)+,d1
	bset.l	d1,d0				* (Idx + d)の nビット目をセット
	move.b	d0,d1
	move.w	(sp)+,d0
	move.b	d1,-(sp)			* 結果を残しておく
	write_mem_8
	move.b	(sp)+,d0			* 結果を d0に入れて戻る(SET n,(Idx+d),Xのため)
	rts

*	------ ＳＥＴ n,(Idx+d),X ------
;---------------------------------------------------------------------------------------
; 未定義命令。SET n,(Idx+d)の実行後、結果をXレジスタにストアする命令。
; XはOP Codeの下位3ビットで指定され、以下のように対応している。
; 0: Bレジスタ
; 1: Cレジスタ
; 2: Dレジスタ
; 3: Eレジスタ
; 4: Hレジスタ
; 5: Lレジスタ
; 6: RES n,(Idx+d)
; 7: Aレジスタ
SET_lIdx_dl_X	macro	target
	bsr	SET_lIdx_dl			* SET n,(Idx+d) を実行
	; 実行結果が d0 に入っているので、それをXレジスタにストア
	move.b	d0,target
	endm
;---------------------------------------------------------------------------------------
	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl_B:
	SET_lIdx_dl_X	b(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl_C:
	SET_lIdx_dl_X	c(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl_D:
	SET_lIdx_dl_X	d(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl_E:
	SET_lIdx_dl_X	e(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl_H:
	SET_lIdx_dl_X	h(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl_L:
	SET_lIdx_dl_X	l(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
SET_lIdx_dl_A:
	SET_lIdx_dl_X	d4
	rts



*	------ ＲＥＳ n,(Idx+d) ------
	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl:
	andi.w	#%00000000_00111000,d1		* BIT_n_? の n を d1にロード
	lsr.w	#3,d1
	move.w	d0,-(sp)			* Idx + d をプッシュ
	move.w	d1,-(sp)
	jsr	ms_read_mem_8
	move.w	(sp)+,d1
	bclr.l	d1,d0				* (Idx + d)の nビット目をクリア
	move.b	d0,d1
	move.w	(sp)+,d0
	move.b	d1,-(sp)			* 結果を残しておく
	write_mem_8
	move.b	(sp)+,d0			* 結果を d0に入れて戻る(RES n,(Idx+d),Xのため)
	rts

*	------ ＲＥＳ n,(Idx+d),X ------
;---------------------------------------------------------------------------------------
; 未定義命令。RES n,(Idx+d)の実行後、結果をXレジスタにストアする命令。
; XはOP Codeの下位3ビットで指定され、以下のように対応している。
; 0: Bレジスタ
; 1: Cレジスタ
; 2: Dレジスタ
; 3: Eレジスタ
; 4: Hレジスタ
; 5: Lレジスタ
; 6: RES n,(Idx+d)
; 7: Aレジスタ
RES_lIdx_dl_X	macro	target
	bsr	RES_lIdx_dl			* RES n,(Idx+d) を実行
	; 実行結果が d0 に入っているので、それをXレジスタにストア
	move.b	d0,target
	endm
;---------------------------------------------------------------------------------------
	
	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl_B:
	RES_lIdx_dl_X	b(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl_C:
	RES_lIdx_dl_X	c(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl_D:
	RES_lIdx_dl_X	d(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl_E:
	RES_lIdx_dl_X	e(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl_H:
	RES_lIdx_dl_X	h(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl_L:
	RES_lIdx_dl_X	l(a3)
	rts

	.dc.w	23			* サイクル数
	.dc.w	4-1			* 命令語長-1 (使っていない)
RES_lIdx_dl_A:
	RES_lIdx_dl_X	d4
	rts



*****************************************************
*
*		Ｉ/Ｏ関係のルーチン
*
*****************************************************

*	------ ＩＮ ------
	.dc.w	11			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_A_n:	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d0
	bsr	input
	move.b	d0,d4
	rts

;---------------------------------------------------------------------------------------
; IN r,(C) の挙動
; * S : 読み込んだ値のbit7
; * Z : 読み込んだ値が0なら1。それ以外の時は0
; * F5: 変化しない
; * H : 0
; * F3: 変化しない
; * PV: 読み込んだ値のパリティ
; * N : 0
; * C : 変化しない
IN_X_C	macro
	bsr	eval_flag_all			* 全フラグを再評価
	; b18 : don't care
	; b17 : 論理演算なので1
	; b16 : don't care
	andi.l	#%000_00000000_00101001,d6	* F5,F3,Cフラグ以外をクリア
	ori.l	#%010_11000100_00000000,d6	* SZとPVはダーティビットを立てる
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d5				* 論理演算結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_A_c:	IN_X_C
	move.b	d0,d4
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_B_c:	IN_X_C
	move.b	d0,b(a3)
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_C_c:	IN_X_C
	move.b	d0,c(a3)
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_D_c:	IN_X_C
	move.b	d0,d(a3)
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_E_c:	IN_X_C
	move.b	d0,e(a3)
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_H_c:	IN_X_C
	move.b	d0,h(a3)
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_L_c:	IN_X_C
	move.b	d0,l(a3)
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
IN_F_c:	IN_X_C
	; IN F,(C) は、読み込んだ値に対してフラグが変化するだけでどこにも結果は保存されない
	rts

*	------ ＩＮＩ ------
; INI の挙動
; * S : 不変(?)
; * Z : Bレジスタをデクリメントした結果が0なら1。それ以外の時は0
; * F5: 変化しない
; * H : 変化しない
; * F3: 変化しない
; * PV: 変化しない
; * N : 1
; * C : 変化しない
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
INI:	bsr	eval_flag_all		* 全フラグを再評価
	andi.l	#%000_00000000_10111111,d6	* Zをクリア
	ori.l	#%000_00000000_00000010,d6	* N=1にセット
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	addq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@f
	ori.w	#%01000000,d6		* Z をセット
@@:	rts

*	------ ＩＮＤ ------
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
IND:	bsr	eval_flag_all		* 全フラグを再評価
	andi.l	#%000_00000000_10111111,d6	* Zをクリア
	ori.l	#%000_00000000_00000010,d6	* N=1にセット
	move.b	c(a3),d0
	bsr	input
	move.b	d0,d1
	move.w	hl(a3),d0
	write_mem_8
	subq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@f
	ori.w	#%01000000,d6		* Z をセット
@@:	rts

*	------ ＩＮＩＲ ------
	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
INIR:	bsr	INI
	cmpi.b	#0,b(a3)
	bne	@f
	; 最終読み込みの場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts

*	------ ＩＮＤＲ ------
	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
INDR:	bsr	IND
	cmpi.b	#0,b(a3)
	bne	@f
	; 最終読み込みの場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts

	
*	------ ＯＵＴ ------
	.dc.w	11			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_n_A:
	* 先読みした値からnを取り出す
	rol.l	#8,d1			* 最下位バイトに移動
	move.b	d1,d0
	move.b	d4,d1
	bsr	output
	rts

;---------------------------------------------------------------------------------------
; OUT (C),r の挙動
; フラグ変化はしない
OUT_C_X	macro
	move.b	target_8(a3),d1
	move.b	c(a3),d0
	bsr	output
	move.b	d0,d5				* 論理演算結果を保存
	endm
;---------------------------------------------------------------------------------------

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_c_A:
	move.b	d4,target_8(a3)
	OUT_C_X
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_c_B:
	move.b	b(a3),target_8(a3)
	OUT_C_X
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_c_C:
	move.b	c(a3),target_8(a3)
	OUT_C_X
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_c_D:
	move.b	d(a3),target_8(a3)
	OUT_C_X
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_c_E:
	move.b	e(a3),target_8(a3)
	OUT_C_X
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_c_H:
	move.b	h(a3),target_8(a3)
	OUT_C_X
	rts

	.dc.w	12			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUT_c_L:
	move.b	l(a3),target_8(a3)
	OUT_C_X
	rts

*	------ ＯＵＴＩ ------
; OUTI の挙動
; * S : 不変(?)
; * Z : Bレジスタをデクリメントした結果が0なら1。それ以外の時は0
; * F5: 変化しない
; * H : 変化しない
; * F3: 変化しない
; * PV: 変化しない
; * N : 1
; * C : 変化しない
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUTI:	bsr	eval_flag_all		* 全フラグを再評価
	andi.l	#%000_00000000_10111111,d6	* Zをクリア
	ori.l	#%000_00000000_00000010,d6	* N=1にセット
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)		* 書き込む値
	OUT_C_X
	addq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@f
	ori.w	#%01000000,d6		* Z をセット
@@:	rts

*	------ ＯＵＴＤ ------
	.dc.w	16			* サイクル数
	.dc.w	2-1			* 命令語長-1
OUTD:	bsr	eval_flag_all		* 全フラグを再評価
	andi.l	#%000_00000000_10111111,d6	* Zをクリア
	ori.l	#%000_00000000_00000010,d6	* N=1にセット
	move.w	hl(a3),d0
	jsr	ms_read_mem_8
	move.b	d0,target_8(a3)		* 書き込む値
	OUT_C_X
	subq.w	#1,hl(a3)
	subq.b	#1,b(a3)
	bne	@f
	ori.w	#%01000000,d6		* Z をセット
@@:	rts

*	------ ＯＴＩＲ ------
	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
OTIR:	bsr	OUTI
	cmpi.b	#0,b(a3)
	bne	@f
	; 最終書き込みの場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts

*	------ ＯＴＤＲ ------
	.dc.w	21			* サイクル数
	.dc.w	2-1			* 命令語長-1
OTDR:	bsr	OUTD
	cmpi.b	#0,b(a3)
	bne	@f
	; 最終書き込みの場合はサイクル数が16なので5サイクル引く
	subq.l	#5,cpu_cycle
	rts
@@:	subq.w	#2,d7
	btst.l	#PAGEADDRBIT,d7		* PC がページ境界をまたいだか？
	beq	@f			* PC -2 でページ境界をまたいだか？
	PC_page_dec			* またいだ時
	andi.w	#PAGEADDRMASK,d7	* 命令がページ境界をまたぐ時
@@:	rts


*****************************************************************
*
*	ポートからの読み込み
*
*  (引数)
*	.d0.b	ポート番号
*  (帰り値)
*	.d0.b	読み込んだ値
*
*	d1,d2,d3 破壊可能性あり
*
*****************************************************************	
input:
	movem.l	d2-d7/a0-a5,-(sp)
	andi.l	#$ff,d0				* 上位バイトを０でクリア
	lea.l	ms_io_input_table,a0
	movea.l	(a0,d0.w*4),a0			* d0 の値を変えちゃだめ（68030用→68000用にする時注意）
.ifdef	DEBUG
	bsr	print_debug_in
.endif
	move.l	d0,-(sp)			* Cの関数でも呼べるように引数をセット
	jsr	(a0)
	lea	4(sp),sp
	movem.l	(sp)+,d2-d7/a0-a5
	rts

*****************************************************************
*
*	ポートへの書き込み
*
*  (引数)
*	.d0.b	ポート番号
*	.d1.b	書き込む値
*
*	d1 破壊
*
*****************************************************************	
output:
	movem.l	d2-d7/a0-a5,-(sp)

	andi.l	#$ff,d0				* 上位バイトを０でクリア
	andi.l	#$ff,d1				* 上位バイトを０でクリア
	lea	ms_io_output_table,a0
	movea.l	(a0,d0.w*4),a0			* d0 の値を変えちゃだめ（68030用→68000用にする時注意）
.ifdef	DEBUG
	bsr	print_debug_out
.endif
	move.l	d1,-(sp)			* Cの関数でも呼べるように引数をセット
	move.l	d0,-(sp)			* Cの関数でも呼べるように引数をセット
	jsr	(a0)
	lea	8(sp),sp
	movem.l	(sp)+,d2-d7/a0-a5
	jsr	refresh_PC_if_needed		* I/Oの出力によってページ切り替えが発生している可能性があるので調べる
	rts

print_debug_in:
	cmp.w	#MS_LOG_TRACE,debug_log_level
	;bge	@f
	rts
@@:	movem.l	d0-d3/a0-a3,-(sp)
	move.b	d0,d2
	lsr.w	#4,d0
	lea.l	HEX,a0
	move.b	(a0,d0.w),debug_in_number+0	* ポート番号の上位4bit
	andi.w	#$0f,d2
	move.b	(a0,d2.w),debug_in_number+1	* ポート番号の下位4bit

	pea.l	debug_in_msg
	DOS	__PRINT
	lea.l	4(sp),sp
	movem.l	(sp)+,d0-d3/a0-a3
	rts

print_debug_out:
	cmp.w	#MS_LOG_TRACE,debug_log_level		* TRACE以上の時
	;bge	@f
	rts
@@:	movem.l	d0-d3/a0-a3,-(sp)
	move.b	d0,d2
	lsr.w	#4,d0
	lea.l	HEX,a0
	move.b	(a0,d0.w),debug_out_number+0	* ポート番号の上位4bit
	andi.w	#$0f,d2
	move.b	(a0,d2.w),debug_out_number+1	* ポート番号の下位4bit
	move.w	d1,d2
	lsr.w	#4,d1
	lea.l	HEX,a0
	move.b	(a0,d1.w),debug_out_value+0	* 書き込む値の上位4bit
	andi.w	#$0f,d2
	move.b	(a0,d2.w),debug_out_value+1	* 書き込む値の下位4bit

	pea.l	debug_out_msg
	DOS	__PRINT
	lea.l	4(sp),sp
	movem.l	(sp)+,d0-d3/a0-a3
	rts

	.data


debug_in_msg:
	.dc.b	'I/O read P:0x'
debug_in_number:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00

debug_out_msg:
	.dc.b	'I/O write P:0x'
debug_out_number:
	.dc.b	'00'
	.dc.b	' V:0x'
debug_out_value:
	.dc.b	'00'
	.dc.b	0x0d,0x0a,0x00



*************** ワークエリア ******************

	.data
	.even

PC_page:
	.dc.w	0	* 現在ＰＣが存在するページ

emu_loop_func:
	.dc.l	0	* エミュレータのループ関数のアドレス

ms_cpu_registers_ptr:
	.dc.l	registers

base:			* a3 の指すアドレス
registers:
	.dc.b	0	* a
	.dc.b	0	* f
	.dc.b	0	* b
	.dc.b	0	* c
	.dc.b	0	* d
	.dc.b	0	* e
	.dc.b	0	* h
	.dc.b	0	* l

	.dc.b	0	* ix_h
	.dc.b	0	* ix_l
	.dc.b	0	* iy_h
	.dc.b	0	* iy_l

	.dc.b	0	* s
	.dc.b	0	* p

pair_registers:		* 裏レジスタの保存場所
	.dc.b	0	* a'
	.dc.b	0	* f'
	.dc.b	0	* b'
	.dc.b	0	* c'
	.dc.b	0	* d'
	.dc.b	0	* e'
	.dc.b	0	* h'
	.dc.b	0	* l'


r_:	.dc.b	0	* Ｒレジスタ
i_:	.dc.b	0	* Ｉレジスタ

wz_:
w_:	.dc.b	0	* Ｗレジスタ
z_:	.dc.b	0	* Ｚレジスタ

target_16_:		* 各命令の演算で使用する値を保持する領域
	.dc.b	0
target_8_:
	.dc.b	0

; CPUのメインループを極力高速化するため、Z80の割り込みや、エミュレータの割り込み(キーボード処理など)を
; yieldフラグを見て分岐するようにしています。
; yieldフラグには cpu_yield、sub_yield、emu_yieldがあり、すべてが0の場合は、CPUのメインループが
; 割り込まれずに実行されます。
; このフラグは、以下のような動作をします。
;
; ● cpu_yield, sub_yield
; cpu_yield、sub_yieldに1以上をセットすると、1命令処理するごとにカウントダウンし、0になるタイミングで、
; 以下の動作をします:
;   * EI状態で、VDPからの割り込み要求があるなら、割り込みを発生させる
;   * DI状態なら無視する(割り込みは取りこぼされる)
;
; 通常はX68000側のVSYNC割り込みでcpu_yieldに1をセットし、即座にZ80側の割り込みがかかるようにします。
; タイミング調整が必要になった場合は、このフラグを使って調整可能です。
; 走査線割り込みをサポートする場合は、sub_yieldをセットしますこのフラグに1以上の値をセットして
; 走査線割り込みのタイミングを 調整することが可能です。
;
; ● emu_yield
; emu_yieldに1以上をセットすると、1命令処理するごとにカウントダウンし、0になるタイミングで、
; 以下の動作をします:
;    * X68000側のキーボード入力の処理を行う
;
; 通常はX68000側のVSYNC割り込みで cpu_yieldより100くらい大きめの値をセットします。これにより、
; cpu_yieldの方が先に処理され、Z80の割り込み処理ルーチンが優先的に動くようになります。
; emu_yieldの頻度を調整したい場合は、VSYNC割り込み以外のタイマー割り込みを使ってセットするように
; しても良いです。
	.quad
cpu_sub_emu_yield:		* cpu_yield, sub_yield, emu_yield を同時にロングワードアクセスするときはこちらのラベルを使用する
cpu_yield:
	.dc.b	0
sub_yield:
	.dc.b	0
emu_yield:
	.dc.w	0

debug_log_level:
	.dc.w	0		* ms.c の main() の最初で上書きしている

;	割り込み許可状態を示すフラグ
;	0 ・・・ DI
;	1 ・・・ EI
interrupt_enable:
	.dc.b	0

;	最後に実行した命令のオペコード (最初の1バイトのみ)
;	正確には命令フェッチした直後にセットされるので、メインループの中やエミュレータの
;	割り込み処理の中では「最後に実行した命令」ですが、各命令の処理中は
;	「今実行中の命令」となります。
last_opcode:
	.dc.b	0

interrupt_mode:
	.dc.b	0		* インタラプトモード 0, 1, 2

	.even

interrupt_return:
	.dc.w	0		* 割り込み処理の戻り先アドレス。割り込みが終わったら0クリアされます。

	.end
